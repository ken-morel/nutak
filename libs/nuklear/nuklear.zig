pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_labs = @import("std").zig.c_builtins.__builtin_labs;
pub const __builtin_llabs = @import("std").zig.c_builtins.__builtin_llabs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const nk_char = i8;
pub const nk_uchar = u8;
pub const nk_byte = u8;
pub const nk_short = c_short;
pub const nk_ushort = c_ushort;
pub const nk_int = c_int;
pub const nk_uint = c_uint;
pub const nk_size = c_ulong;
pub const nk_ptr = c_ulong;
pub const nk_bool = c_int;
pub const nk_hash = nk_uint;
pub const nk_flags = nk_uint;
pub const nk_rune = nk_uint;
pub const _dummy_array437 = [1]u8;
pub const _dummy_array438 = [1]u8;
pub const _dummy_array439 = [1]u8;
pub const _dummy_array440 = [1]u8;
pub const _dummy_array441 = [1]u8;
pub const _dummy_array442 = [1]u8;
pub const _dummy_array443 = [1]u8;
pub const _dummy_array444 = [1]u8;
pub const _dummy_array445 = [1]u8;
pub const _dummy_array449 = [1]u8;
pub const struct_nk_buffer_marker = extern struct {
    active: nk_bool = @import("std").mem.zeroes(nk_bool),
    offset: nk_size = @import("std").mem.zeroes(nk_size),
};
pub const nk_plugin_alloc = ?*const fn (nk_handle, ?*anyopaque, nk_size) callconv(.c) ?*anyopaque;
pub const nk_plugin_free = ?*const fn (nk_handle, ?*anyopaque) callconv(.c) void;
pub const struct_nk_allocator = extern struct {
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    alloc: nk_plugin_alloc = @import("std").mem.zeroes(nk_plugin_alloc),
    free: nk_plugin_free = @import("std").mem.zeroes(nk_plugin_free),
};
pub const NK_BUFFER_FIXED: c_int = 0;
pub const NK_BUFFER_DYNAMIC: c_int = 1;
pub const enum_nk_allocation_type = c_uint;
pub const struct_nk_memory = extern struct {
    ptr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    size: nk_size = @import("std").mem.zeroes(nk_size),
};
pub const struct_nk_buffer = extern struct {
    marker: [2]struct_nk_buffer_marker = @import("std").mem.zeroes([2]struct_nk_buffer_marker),
    pool: struct_nk_allocator = @import("std").mem.zeroes(struct_nk_allocator),
    type: enum_nk_allocation_type = @import("std").mem.zeroes(enum_nk_allocation_type),
    memory: struct_nk_memory = @import("std").mem.zeroes(struct_nk_memory),
    grow_factor: f32 = @import("std").mem.zeroes(f32),
    allocated: nk_size = @import("std").mem.zeroes(nk_size),
    needed: nk_size = @import("std").mem.zeroes(nk_size),
    calls: nk_size = @import("std").mem.zeroes(nk_size),
    size: nk_size = @import("std").mem.zeroes(nk_size),
};
pub const struct_nk_rect = extern struct {
    x: f32 = @import("std").mem.zeroes(f32),
    y: f32 = @import("std").mem.zeroes(f32),
    w: f32 = @import("std").mem.zeroes(f32),
    h: f32 = @import("std").mem.zeroes(f32),
};
pub const struct_nk_command_buffer = extern struct {
    base: [*c]struct_nk_buffer = @import("std").mem.zeroes([*c]struct_nk_buffer),
    clip: struct_nk_rect = @import("std").mem.zeroes(struct_nk_rect),
    use_clipping: c_int = @import("std").mem.zeroes(c_int),
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    begin: nk_size = @import("std").mem.zeroes(nk_size),
    end: nk_size = @import("std").mem.zeroes(nk_size),
    last: nk_size = @import("std").mem.zeroes(nk_size),
};
pub const struct_nk_draw_command = opaque {};
pub const NK_ANTI_ALIASING_OFF: c_int = 0;
pub const NK_ANTI_ALIASING_ON: c_int = 1;
pub const enum_nk_anti_aliasing = c_uint;
pub const struct_nk_vec2 = extern struct {
    x: f32 = @import("std").mem.zeroes(f32),
    y: f32 = @import("std").mem.zeroes(f32),
};
pub const struct_nk_draw_null_texture = extern struct {
    texture: nk_handle = @import("std").mem.zeroes(nk_handle),
    uv: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
};
pub const struct_nk_draw_vertex_layout_element = opaque {};
pub const struct_nk_convert_config = extern struct {
    global_alpha: f32 = @import("std").mem.zeroes(f32),
    line_AA: enum_nk_anti_aliasing = @import("std").mem.zeroes(enum_nk_anti_aliasing),
    shape_AA: enum_nk_anti_aliasing = @import("std").mem.zeroes(enum_nk_anti_aliasing),
    circle_segment_count: c_uint = @import("std").mem.zeroes(c_uint),
    arc_segment_count: c_uint = @import("std").mem.zeroes(c_uint),
    curve_segment_count: c_uint = @import("std").mem.zeroes(c_uint),
    tex_null: struct_nk_draw_null_texture = @import("std").mem.zeroes(struct_nk_draw_null_texture),
    vertex_layout: ?*const struct_nk_draw_vertex_layout_element = @import("std").mem.zeroes(?*const struct_nk_draw_vertex_layout_element),
    vertex_size: nk_size = @import("std").mem.zeroes(nk_size),
    vertex_alignment: nk_size = @import("std").mem.zeroes(nk_size),
};
pub const NK_STYLE_ITEM_COLOR: c_int = 0;
pub const NK_STYLE_ITEM_IMAGE: c_int = 1;
pub const NK_STYLE_ITEM_NINE_SLICE: c_int = 2;
pub const enum_nk_style_item_type = c_uint;
pub const struct_nk_color = extern struct {
    r: nk_byte = @import("std").mem.zeroes(nk_byte),
    g: nk_byte = @import("std").mem.zeroes(nk_byte),
    b: nk_byte = @import("std").mem.zeroes(nk_byte),
    a: nk_byte = @import("std").mem.zeroes(nk_byte),
};
pub const struct_nk_image = extern struct {
    handle: nk_handle = @import("std").mem.zeroes(nk_handle),
    w: nk_ushort = @import("std").mem.zeroes(nk_ushort),
    h: nk_ushort = @import("std").mem.zeroes(nk_ushort),
    region: [4]nk_ushort = @import("std").mem.zeroes([4]nk_ushort),
};
pub const struct_nk_nine_slice = extern struct {
    img: struct_nk_image = @import("std").mem.zeroes(struct_nk_image),
    l: nk_ushort = @import("std").mem.zeroes(nk_ushort),
    t: nk_ushort = @import("std").mem.zeroes(nk_ushort),
    r: nk_ushort = @import("std").mem.zeroes(nk_ushort),
    b: nk_ushort = @import("std").mem.zeroes(nk_ushort),
};
pub const union_nk_style_item_data = extern union {
    color: struct_nk_color,
    image: struct_nk_image,
    slice: struct_nk_nine_slice,
};
pub const struct_nk_style_item = extern struct {
    type: enum_nk_style_item_type = @import("std").mem.zeroes(enum_nk_style_item_type),
    data: union_nk_style_item_data = @import("std").mem.zeroes(union_nk_style_item_data),
};
pub const nk_plugin_paste = ?*const fn (nk_handle, [*c]struct_nk_text_edit) callconv(.c) void;
pub const nk_plugin_copy = ?*const fn (nk_handle, [*c]const u8, c_int) callconv(.c) void;
pub const struct_nk_clipboard = extern struct {
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    paste: nk_plugin_paste = @import("std").mem.zeroes(nk_plugin_paste),
    copy: nk_plugin_copy = @import("std").mem.zeroes(nk_plugin_copy),
};
pub const struct_nk_str = extern struct {
    buffer: struct_nk_buffer = @import("std").mem.zeroes(struct_nk_buffer),
    len: c_int = @import("std").mem.zeroes(c_int),
};
pub const nk_plugin_filter = ?*const fn ([*c]const struct_nk_text_edit, nk_rune) callconv(.c) nk_bool;
pub const struct_nk_text_undo_record = extern struct {
    where: c_int = @import("std").mem.zeroes(c_int),
    insert_length: c_short = @import("std").mem.zeroes(c_short),
    delete_length: c_short = @import("std").mem.zeroes(c_short),
    char_storage: c_short = @import("std").mem.zeroes(c_short),
};
pub const struct_nk_text_undo_state = extern struct {
    undo_rec: [99]struct_nk_text_undo_record = @import("std").mem.zeroes([99]struct_nk_text_undo_record),
    undo_char: [999]nk_rune = @import("std").mem.zeroes([999]nk_rune),
    undo_point: c_short = @import("std").mem.zeroes(c_short),
    redo_point: c_short = @import("std").mem.zeroes(c_short),
    undo_char_point: c_short = @import("std").mem.zeroes(c_short),
    redo_char_point: c_short = @import("std").mem.zeroes(c_short),
};
pub const struct_nk_text_edit = extern struct {
    clip: struct_nk_clipboard = @import("std").mem.zeroes(struct_nk_clipboard),
    string: struct_nk_str = @import("std").mem.zeroes(struct_nk_str),
    filter: nk_plugin_filter = @import("std").mem.zeroes(nk_plugin_filter),
    scrollbar: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    cursor: c_int = @import("std").mem.zeroes(c_int),
    select_start: c_int = @import("std").mem.zeroes(c_int),
    select_end: c_int = @import("std").mem.zeroes(c_int),
    mode: u8 = @import("std").mem.zeroes(u8),
    cursor_at_end_of_line: u8 = @import("std").mem.zeroes(u8),
    initialized: u8 = @import("std").mem.zeroes(u8),
    has_preferred_x: u8 = @import("std").mem.zeroes(u8),
    single_line: u8 = @import("std").mem.zeroes(u8),
    active: u8 = @import("std").mem.zeroes(u8),
    padding1: u8 = @import("std").mem.zeroes(u8),
    preferred_x: f32 = @import("std").mem.zeroes(f32),
    undo: struct_nk_text_undo_state = @import("std").mem.zeroes(struct_nk_text_undo_state),
};
pub const struct_nk_draw_list = opaque {};
pub const nk_text_width_f = ?*const fn (nk_handle, f32, [*c]const u8, c_int) callconv(.c) f32;
pub const struct_nk_user_font = extern struct {
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    height: f32 = @import("std").mem.zeroes(f32),
    width: nk_text_width_f = @import("std").mem.zeroes(nk_text_width_f),
};
pub const NK_PANEL_NONE: c_int = 0;
pub const NK_PANEL_WINDOW: c_int = 1;
pub const NK_PANEL_GROUP: c_int = 2;
pub const NK_PANEL_POPUP: c_int = 4;
pub const NK_PANEL_CONTEXTUAL: c_int = 16;
pub const NK_PANEL_COMBO: c_int = 32;
pub const NK_PANEL_MENU: c_int = 64;
pub const NK_PANEL_TOOLTIP: c_int = 128;
pub const enum_nk_panel_type = c_uint;
pub const struct_nk_scroll = extern struct {
    x: nk_uint = @import("std").mem.zeroes(nk_uint),
    y: nk_uint = @import("std").mem.zeroes(nk_uint),
};
pub const struct_nk_menu_state = extern struct {
    x: f32 = @import("std").mem.zeroes(f32),
    y: f32 = @import("std").mem.zeroes(f32),
    w: f32 = @import("std").mem.zeroes(f32),
    h: f32 = @import("std").mem.zeroes(f32),
    offset: struct_nk_scroll = @import("std").mem.zeroes(struct_nk_scroll),
};
pub const NK_LAYOUT_DYNAMIC_FIXED: c_int = 0;
pub const NK_LAYOUT_DYNAMIC_ROW: c_int = 1;
pub const NK_LAYOUT_DYNAMIC_FREE: c_int = 2;
pub const NK_LAYOUT_DYNAMIC: c_int = 3;
pub const NK_LAYOUT_STATIC_FIXED: c_int = 4;
pub const NK_LAYOUT_STATIC_ROW: c_int = 5;
pub const NK_LAYOUT_STATIC_FREE: c_int = 6;
pub const NK_LAYOUT_STATIC: c_int = 7;
pub const NK_LAYOUT_TEMPLATE: c_int = 8;
pub const NK_LAYOUT_COUNT: c_int = 9;
pub const enum_nk_panel_row_layout_type = c_uint;
pub const struct_nk_row_layout = extern struct {
    type: enum_nk_panel_row_layout_type = @import("std").mem.zeroes(enum_nk_panel_row_layout_type),
    index: c_int = @import("std").mem.zeroes(c_int),
    height: f32 = @import("std").mem.zeroes(f32),
    min_height: f32 = @import("std").mem.zeroes(f32),
    columns: c_int = @import("std").mem.zeroes(c_int),
    ratio: [*c]const f32 = @import("std").mem.zeroes([*c]const f32),
    item_width: f32 = @import("std").mem.zeroes(f32),
    item_height: f32 = @import("std").mem.zeroes(f32),
    item_offset: f32 = @import("std").mem.zeroes(f32),
    filled: f32 = @import("std").mem.zeroes(f32),
    item: struct_nk_rect = @import("std").mem.zeroes(struct_nk_rect),
    tree_depth: c_int = @import("std").mem.zeroes(c_int),
    templates: [16]f32 = @import("std").mem.zeroes([16]f32),
};
pub const NK_CHART_LINES: c_int = 0;
pub const NK_CHART_COLUMN: c_int = 1;
pub const NK_CHART_MAX: c_int = 2;
pub const enum_nk_chart_type = c_uint;
pub const struct_nk_chart_slot = extern struct {
    type: enum_nk_chart_type = @import("std").mem.zeroes(enum_nk_chart_type),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    highlight: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    min: f32 = @import("std").mem.zeroes(f32),
    max: f32 = @import("std").mem.zeroes(f32),
    range: f32 = @import("std").mem.zeroes(f32),
    count: c_int = @import("std").mem.zeroes(c_int),
    last: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    index: c_int = @import("std").mem.zeroes(c_int),
    show_markers: nk_bool = @import("std").mem.zeroes(nk_bool),
};
pub const struct_nk_chart = extern struct {
    slot: c_int = @import("std").mem.zeroes(c_int),
    x: f32 = @import("std").mem.zeroes(f32),
    y: f32 = @import("std").mem.zeroes(f32),
    w: f32 = @import("std").mem.zeroes(f32),
    h: f32 = @import("std").mem.zeroes(f32),
    slots: [4]struct_nk_chart_slot = @import("std").mem.zeroes([4]struct_nk_chart_slot),
};
pub const struct_nk_panel = extern struct {
    type: enum_nk_panel_type = @import("std").mem.zeroes(enum_nk_panel_type),
    flags: nk_flags = @import("std").mem.zeroes(nk_flags),
    bounds: struct_nk_rect = @import("std").mem.zeroes(struct_nk_rect),
    offset_x: [*c]nk_uint = @import("std").mem.zeroes([*c]nk_uint),
    offset_y: [*c]nk_uint = @import("std").mem.zeroes([*c]nk_uint),
    at_x: f32 = @import("std").mem.zeroes(f32),
    at_y: f32 = @import("std").mem.zeroes(f32),
    max_x: f32 = @import("std").mem.zeroes(f32),
    footer_height: f32 = @import("std").mem.zeroes(f32),
    header_height: f32 = @import("std").mem.zeroes(f32),
    border: f32 = @import("std").mem.zeroes(f32),
    has_scrolling: c_uint = @import("std").mem.zeroes(c_uint),
    clip: struct_nk_rect = @import("std").mem.zeroes(struct_nk_rect),
    menu: struct_nk_menu_state = @import("std").mem.zeroes(struct_nk_menu_state),
    row: struct_nk_row_layout = @import("std").mem.zeroes(struct_nk_row_layout),
    chart: struct_nk_chart = @import("std").mem.zeroes(struct_nk_chart),
    buffer: [*c]struct_nk_command_buffer = @import("std").mem.zeroes([*c]struct_nk_command_buffer),
    parent: [*c]struct_nk_panel = @import("std").mem.zeroes([*c]struct_nk_panel),
};
pub const struct_nk_key = extern struct {
    down: nk_bool = @import("std").mem.zeroes(nk_bool),
    clicked: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_nk_keyboard = extern struct {
    keys: [30]struct_nk_key = @import("std").mem.zeroes([30]struct_nk_key),
    text: [16]u8 = @import("std").mem.zeroes([16]u8),
    text_len: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_nk_mouse_button = extern struct {
    down: nk_bool = @import("std").mem.zeroes(nk_bool),
    clicked: c_uint = @import("std").mem.zeroes(c_uint),
    clicked_pos: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
};
pub const struct_nk_mouse = extern struct {
    buttons: [4]struct_nk_mouse_button = @import("std").mem.zeroes([4]struct_nk_mouse_button),
    pos: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    prev: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    delta: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    scroll_delta: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    grab: u8 = @import("std").mem.zeroes(u8),
    grabbed: u8 = @import("std").mem.zeroes(u8),
    ungrab: u8 = @import("std").mem.zeroes(u8),
};
pub const struct_nk_input = extern struct {
    keyboard: struct_nk_keyboard = @import("std").mem.zeroes(struct_nk_keyboard),
    mouse: struct_nk_mouse = @import("std").mem.zeroes(struct_nk_mouse),
};
pub const struct_nk_cursor = extern struct {
    img: struct_nk_image = @import("std").mem.zeroes(struct_nk_image),
    size: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    offset: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
};
pub const struct_nk_style_text = extern struct {
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
};
pub const struct_nk_style_button = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    color_factor_background: f32 = @import("std").mem.zeroes(f32),
    text_background: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_alignment: nk_flags = @import("std").mem.zeroes(nk_flags),
    color_factor_text: f32 = @import("std").mem.zeroes(f32),
    border: f32 = @import("std").mem.zeroes(f32),
    rounding: f32 = @import("std").mem.zeroes(f32),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    image_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    touch_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    draw_begin: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
    draw_end: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
};
pub const struct_nk_style_toggle = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    cursor_hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    text_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_background: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_alignment: nk_flags = @import("std").mem.zeroes(nk_flags),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    touch_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    spacing: f32 = @import("std").mem.zeroes(f32),
    border: f32 = @import("std").mem.zeroes(f32),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    draw_begin: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
    draw_end: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
};
pub const struct_nk_style_selectable = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    pressed: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    normal_active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover_active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    pressed_active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    text_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_pressed: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_normal_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_hover_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_pressed_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_background: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_alignment: nk_flags = @import("std").mem.zeroes(nk_flags),
    rounding: f32 = @import("std").mem.zeroes(f32),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    touch_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    image_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    draw_begin: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
    draw_end: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
};
pub const NK_SYMBOL_NONE: c_int = 0;
pub const NK_SYMBOL_X: c_int = 1;
pub const NK_SYMBOL_UNDERSCORE: c_int = 2;
pub const NK_SYMBOL_CIRCLE_SOLID: c_int = 3;
pub const NK_SYMBOL_CIRCLE_OUTLINE: c_int = 4;
pub const NK_SYMBOL_RECT_SOLID: c_int = 5;
pub const NK_SYMBOL_RECT_OUTLINE: c_int = 6;
pub const NK_SYMBOL_TRIANGLE_UP: c_int = 7;
pub const NK_SYMBOL_TRIANGLE_DOWN: c_int = 8;
pub const NK_SYMBOL_TRIANGLE_LEFT: c_int = 9;
pub const NK_SYMBOL_TRIANGLE_RIGHT: c_int = 10;
pub const NK_SYMBOL_PLUS: c_int = 11;
pub const NK_SYMBOL_MINUS: c_int = 12;
pub const NK_SYMBOL_TRIANGLE_UP_OUTLINE: c_int = 13;
pub const NK_SYMBOL_TRIANGLE_DOWN_OUTLINE: c_int = 14;
pub const NK_SYMBOL_TRIANGLE_LEFT_OUTLINE: c_int = 15;
pub const NK_SYMBOL_TRIANGLE_RIGHT_OUTLINE: c_int = 16;
pub const NK_SYMBOL_MAX: c_int = 17;
pub const enum_nk_symbol_type = c_uint;
pub const struct_nk_style_slider = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    bar_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    bar_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    bar_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    bar_filled: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    cursor_hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    cursor_active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border: f32 = @import("std").mem.zeroes(f32),
    rounding: f32 = @import("std").mem.zeroes(f32),
    bar_height: f32 = @import("std").mem.zeroes(f32),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    spacing: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    cursor_size: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
    show_buttons: c_int = @import("std").mem.zeroes(c_int),
    inc_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    dec_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    inc_symbol: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    dec_symbol: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    draw_begin: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
    draw_end: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
};
pub const struct_nk_style_knob = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    knob_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    knob_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    knob_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    knob_border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    border: f32 = @import("std").mem.zeroes(f32),
    knob_border: f32 = @import("std").mem.zeroes(f32),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    spacing: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    cursor_width: f32 = @import("std").mem.zeroes(f32),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    draw_begin: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
    draw_end: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
};
pub const struct_nk_style_progress = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    cursor_hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    cursor_active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    cursor_border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    rounding: f32 = @import("std").mem.zeroes(f32),
    border: f32 = @import("std").mem.zeroes(f32),
    cursor_border: f32 = @import("std").mem.zeroes(f32),
    cursor_rounding: f32 = @import("std").mem.zeroes(f32),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    draw_begin: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
    draw_end: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
};
pub const struct_nk_style_scrollbar = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    cursor_hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    cursor_active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    cursor_border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    border: f32 = @import("std").mem.zeroes(f32),
    rounding: f32 = @import("std").mem.zeroes(f32),
    border_cursor: f32 = @import("std").mem.zeroes(f32),
    rounding_cursor: f32 = @import("std").mem.zeroes(f32),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
    show_buttons: c_int = @import("std").mem.zeroes(c_int),
    inc_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    dec_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    inc_symbol: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    dec_symbol: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    draw_begin: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
    draw_end: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
};
pub const struct_nk_style_edit = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    scrollbar: struct_nk_style_scrollbar = @import("std").mem.zeroes(struct_nk_style_scrollbar),
    cursor_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_text_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    cursor_text_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    selected_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    selected_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    selected_text_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    selected_text_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    border: f32 = @import("std").mem.zeroes(f32),
    rounding: f32 = @import("std").mem.zeroes(f32),
    cursor_size: f32 = @import("std").mem.zeroes(f32),
    scrollbar_size: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    row_padding: f32 = @import("std").mem.zeroes(f32),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
};
pub const struct_nk_style_property = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    label_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    label_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    label_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    sym_left: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    sym_right: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    border: f32 = @import("std").mem.zeroes(f32),
    rounding: f32 = @import("std").mem.zeroes(f32),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
    edit: struct_nk_style_edit = @import("std").mem.zeroes(struct_nk_style_edit),
    inc_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    dec_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    userdata: nk_handle = @import("std").mem.zeroes(nk_handle),
    draw_begin: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
    draw_end: ?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]struct_nk_command_buffer, nk_handle) callconv(.c) void),
};
pub const struct_nk_style_chart = extern struct {
    background: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    selected_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    border: f32 = @import("std").mem.zeroes(f32),
    rounding: f32 = @import("std").mem.zeroes(f32),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
    show_markers: nk_bool = @import("std").mem.zeroes(nk_bool),
};
pub const struct_nk_style_tab = extern struct {
    background: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    tab_maximize_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    tab_minimize_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    node_maximize_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    node_minimize_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    sym_minimize: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    sym_maximize: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    border: f32 = @import("std").mem.zeroes(f32),
    rounding: f32 = @import("std").mem.zeroes(f32),
    indent: f32 = @import("std").mem.zeroes(f32),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    spacing: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
};
pub const struct_nk_style_combo = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    label_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    label_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    label_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    symbol_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    symbol_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    symbol_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    sym_normal: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    sym_hover: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    sym_active: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    border: f32 = @import("std").mem.zeroes(f32),
    rounding: f32 = @import("std").mem.zeroes(f32),
    content_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    button_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    spacing: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    color_factor: f32 = @import("std").mem.zeroes(f32),
    disabled_factor: f32 = @import("std").mem.zeroes(f32),
};
pub const NK_HEADER_LEFT: c_int = 0;
pub const NK_HEADER_RIGHT: c_int = 1;
pub const enum_nk_style_header_align = c_uint;
pub const struct_nk_style_window_header = extern struct {
    normal: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    hover: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    active: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    close_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    minimize_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    close_symbol: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    minimize_symbol: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    maximize_symbol: enum_nk_symbol_type = @import("std").mem.zeroes(enum_nk_symbol_type),
    label_normal: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    label_hover: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    label_active: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    @"align": enum_nk_style_header_align = @import("std").mem.zeroes(enum_nk_style_header_align),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    label_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    spacing: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
};
pub const struct_nk_style_window = extern struct {
    header: struct_nk_style_window_header = @import("std").mem.zeroes(struct_nk_style_window_header),
    fixed_background: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    background: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    popup_border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    combo_border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    contextual_border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    menu_border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    group_border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    tooltip_border_color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    scaler: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
    border: f32 = @import("std").mem.zeroes(f32),
    combo_border: f32 = @import("std").mem.zeroes(f32),
    contextual_border: f32 = @import("std").mem.zeroes(f32),
    menu_border: f32 = @import("std").mem.zeroes(f32),
    group_border: f32 = @import("std").mem.zeroes(f32),
    tooltip_border: f32 = @import("std").mem.zeroes(f32),
    popup_border: f32 = @import("std").mem.zeroes(f32),
    min_row_height_padding: f32 = @import("std").mem.zeroes(f32),
    rounding: f32 = @import("std").mem.zeroes(f32),
    spacing: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    scrollbar_size: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    min_size: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    group_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    popup_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    combo_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    contextual_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    menu_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    tooltip_padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
};
pub const struct_nk_style = extern struct {
    font: [*c]const struct_nk_user_font = @import("std").mem.zeroes([*c]const struct_nk_user_font),
    cursors: [7][*c]const struct_nk_cursor = @import("std").mem.zeroes([7][*c]const struct_nk_cursor),
    cursor_active: [*c]const struct_nk_cursor = @import("std").mem.zeroes([*c]const struct_nk_cursor),
    cursor_last: [*c]struct_nk_cursor = @import("std").mem.zeroes([*c]struct_nk_cursor),
    cursor_visible: c_int = @import("std").mem.zeroes(c_int),
    text: struct_nk_style_text = @import("std").mem.zeroes(struct_nk_style_text),
    button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    contextual_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    menu_button: struct_nk_style_button = @import("std").mem.zeroes(struct_nk_style_button),
    option: struct_nk_style_toggle = @import("std").mem.zeroes(struct_nk_style_toggle),
    checkbox: struct_nk_style_toggle = @import("std").mem.zeroes(struct_nk_style_toggle),
    selectable: struct_nk_style_selectable = @import("std").mem.zeroes(struct_nk_style_selectable),
    slider: struct_nk_style_slider = @import("std").mem.zeroes(struct_nk_style_slider),
    knob: struct_nk_style_knob = @import("std").mem.zeroes(struct_nk_style_knob),
    progress: struct_nk_style_progress = @import("std").mem.zeroes(struct_nk_style_progress),
    property: struct_nk_style_property = @import("std").mem.zeroes(struct_nk_style_property),
    edit: struct_nk_style_edit = @import("std").mem.zeroes(struct_nk_style_edit),
    chart: struct_nk_style_chart = @import("std").mem.zeroes(struct_nk_style_chart),
    scrollh: struct_nk_style_scrollbar = @import("std").mem.zeroes(struct_nk_style_scrollbar),
    scrollv: struct_nk_style_scrollbar = @import("std").mem.zeroes(struct_nk_style_scrollbar),
    tab: struct_nk_style_tab = @import("std").mem.zeroes(struct_nk_style_tab),
    combo: struct_nk_style_combo = @import("std").mem.zeroes(struct_nk_style_combo),
    window: struct_nk_style_window = @import("std").mem.zeroes(struct_nk_style_window),
};
pub const NK_BUTTON_DEFAULT: c_int = 0;
pub const NK_BUTTON_REPEATER: c_int = 1;
pub const enum_nk_button_behavior = c_uint;
pub const struct_nk_config_stack_style_item_element = extern struct {
    address: [*c]struct_nk_style_item = @import("std").mem.zeroes([*c]struct_nk_style_item),
    old_value: struct_nk_style_item = @import("std").mem.zeroes(struct_nk_style_item),
};
pub const struct_nk_config_stack_style_item = extern struct {
    head: c_int = @import("std").mem.zeroes(c_int),
    elements: [16]struct_nk_config_stack_style_item_element = @import("std").mem.zeroes([16]struct_nk_config_stack_style_item_element),
};
pub const struct_nk_config_stack_float_element = extern struct {
    address: [*c]f32 = @import("std").mem.zeroes([*c]f32),
    old_value: f32 = @import("std").mem.zeroes(f32),
};
pub const struct_nk_config_stack_float = extern struct {
    head: c_int = @import("std").mem.zeroes(c_int),
    elements: [32]struct_nk_config_stack_float_element = @import("std").mem.zeroes([32]struct_nk_config_stack_float_element),
};
pub const struct_nk_config_stack_vec2_element = extern struct {
    address: [*c]struct_nk_vec2 = @import("std").mem.zeroes([*c]struct_nk_vec2),
    old_value: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
};
pub const struct_nk_config_stack_vec2 = extern struct {
    head: c_int = @import("std").mem.zeroes(c_int),
    elements: [16]struct_nk_config_stack_vec2_element = @import("std").mem.zeroes([16]struct_nk_config_stack_vec2_element),
};
pub const struct_nk_config_stack_flags_element = extern struct {
    address: [*c]nk_flags = @import("std").mem.zeroes([*c]nk_flags),
    old_value: nk_flags = @import("std").mem.zeroes(nk_flags),
};
pub const struct_nk_config_stack_flags = extern struct {
    head: c_int = @import("std").mem.zeroes(c_int),
    elements: [32]struct_nk_config_stack_flags_element = @import("std").mem.zeroes([32]struct_nk_config_stack_flags_element),
};
pub const struct_nk_config_stack_color_element = extern struct {
    address: [*c]struct_nk_color = @import("std").mem.zeroes([*c]struct_nk_color),
    old_value: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_config_stack_color = extern struct {
    head: c_int = @import("std").mem.zeroes(c_int),
    elements: [32]struct_nk_config_stack_color_element = @import("std").mem.zeroes([32]struct_nk_config_stack_color_element),
};
pub const struct_nk_config_stack_user_font_element = extern struct {
    address: [*c][*c]const struct_nk_user_font = @import("std").mem.zeroes([*c][*c]const struct_nk_user_font),
    old_value: [*c]const struct_nk_user_font = @import("std").mem.zeroes([*c]const struct_nk_user_font),
};
pub const struct_nk_config_stack_user_font = extern struct {
    head: c_int = @import("std").mem.zeroes(c_int),
    elements: [8]struct_nk_config_stack_user_font_element = @import("std").mem.zeroes([8]struct_nk_config_stack_user_font_element),
};
pub const struct_nk_config_stack_button_behavior_element = extern struct {
    address: [*c]enum_nk_button_behavior = @import("std").mem.zeroes([*c]enum_nk_button_behavior),
    old_value: enum_nk_button_behavior = @import("std").mem.zeroes(enum_nk_button_behavior),
};
pub const struct_nk_config_stack_button_behavior = extern struct {
    head: c_int = @import("std").mem.zeroes(c_int),
    elements: [8]struct_nk_config_stack_button_behavior_element = @import("std").mem.zeroes([8]struct_nk_config_stack_button_behavior_element),
};
pub const struct_nk_configuration_stacks = extern struct {
    style_items: struct_nk_config_stack_style_item = @import("std").mem.zeroes(struct_nk_config_stack_style_item),
    floats: struct_nk_config_stack_float = @import("std").mem.zeroes(struct_nk_config_stack_float),
    vectors: struct_nk_config_stack_vec2 = @import("std").mem.zeroes(struct_nk_config_stack_vec2),
    flags: struct_nk_config_stack_flags = @import("std").mem.zeroes(struct_nk_config_stack_flags),
    colors: struct_nk_config_stack_color = @import("std").mem.zeroes(struct_nk_config_stack_color),
    fonts: struct_nk_config_stack_user_font = @import("std").mem.zeroes(struct_nk_config_stack_user_font),
    button_behaviors: struct_nk_config_stack_button_behavior = @import("std").mem.zeroes(struct_nk_config_stack_button_behavior),
};
pub const struct_nk_table = extern struct {
    seq: c_uint = @import("std").mem.zeroes(c_uint),
    size: c_uint = @import("std").mem.zeroes(c_uint),
    keys: [60]nk_hash = @import("std").mem.zeroes([60]nk_hash),
    values: [60]nk_uint = @import("std").mem.zeroes([60]nk_uint),
    next: [*c]struct_nk_table = @import("std").mem.zeroes([*c]struct_nk_table),
    prev: [*c]struct_nk_table = @import("std").mem.zeroes([*c]struct_nk_table),
};
pub const struct_nk_property_state = extern struct {
    active: c_int = @import("std").mem.zeroes(c_int),
    prev: c_int = @import("std").mem.zeroes(c_int),
    buffer: [64]u8 = @import("std").mem.zeroes([64]u8),
    length: c_int = @import("std").mem.zeroes(c_int),
    cursor: c_int = @import("std").mem.zeroes(c_int),
    select_start: c_int = @import("std").mem.zeroes(c_int),
    select_end: c_int = @import("std").mem.zeroes(c_int),
    name: nk_hash = @import("std").mem.zeroes(nk_hash),
    seq: c_uint = @import("std").mem.zeroes(c_uint),
    old: c_uint = @import("std").mem.zeroes(c_uint),
    state: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_nk_popup_buffer = extern struct {
    begin: nk_size = @import("std").mem.zeroes(nk_size),
    parent: nk_size = @import("std").mem.zeroes(nk_size),
    last: nk_size = @import("std").mem.zeroes(nk_size),
    end: nk_size = @import("std").mem.zeroes(nk_size),
    active: nk_bool = @import("std").mem.zeroes(nk_bool),
};
pub const struct_nk_popup_state = extern struct {
    win: [*c]struct_nk_window = @import("std").mem.zeroes([*c]struct_nk_window),
    type: enum_nk_panel_type = @import("std").mem.zeroes(enum_nk_panel_type),
    buf: struct_nk_popup_buffer = @import("std").mem.zeroes(struct_nk_popup_buffer),
    name: nk_hash = @import("std").mem.zeroes(nk_hash),
    active: nk_bool = @import("std").mem.zeroes(nk_bool),
    combo_count: c_uint = @import("std").mem.zeroes(c_uint),
    con_count: c_uint = @import("std").mem.zeroes(c_uint),
    con_old: c_uint = @import("std").mem.zeroes(c_uint),
    active_con: c_uint = @import("std").mem.zeroes(c_uint),
    header: struct_nk_rect = @import("std").mem.zeroes(struct_nk_rect),
};
pub const struct_nk_edit_state = extern struct {
    name: nk_hash = @import("std").mem.zeroes(nk_hash),
    seq: c_uint = @import("std").mem.zeroes(c_uint),
    old: c_uint = @import("std").mem.zeroes(c_uint),
    active: c_int = @import("std").mem.zeroes(c_int),
    prev: c_int = @import("std").mem.zeroes(c_int),
    cursor: c_int = @import("std").mem.zeroes(c_int),
    sel_start: c_int = @import("std").mem.zeroes(c_int),
    sel_end: c_int = @import("std").mem.zeroes(c_int),
    scrollbar: struct_nk_scroll = @import("std").mem.zeroes(struct_nk_scroll),
    mode: u8 = @import("std").mem.zeroes(u8),
    single_line: u8 = @import("std").mem.zeroes(u8),
};
pub const struct_nk_window = extern struct {
    seq: c_uint = @import("std").mem.zeroes(c_uint),
    name: nk_hash = @import("std").mem.zeroes(nk_hash),
    name_string: [64]u8 = @import("std").mem.zeroes([64]u8),
    flags: nk_flags = @import("std").mem.zeroes(nk_flags),
    bounds: struct_nk_rect = @import("std").mem.zeroes(struct_nk_rect),
    scrollbar: struct_nk_scroll = @import("std").mem.zeroes(struct_nk_scroll),
    buffer: struct_nk_command_buffer = @import("std").mem.zeroes(struct_nk_command_buffer),
    layout: [*c]struct_nk_panel = @import("std").mem.zeroes([*c]struct_nk_panel),
    scrollbar_hiding_timer: f32 = @import("std").mem.zeroes(f32),
    property: struct_nk_property_state = @import("std").mem.zeroes(struct_nk_property_state),
    popup: struct_nk_popup_state = @import("std").mem.zeroes(struct_nk_popup_state),
    edit: struct_nk_edit_state = @import("std").mem.zeroes(struct_nk_edit_state),
    scrolled: c_uint = @import("std").mem.zeroes(c_uint),
    widgets_disabled: nk_bool = @import("std").mem.zeroes(nk_bool),
    tables: [*c]struct_nk_table = @import("std").mem.zeroes([*c]struct_nk_table),
    table_count: c_uint = @import("std").mem.zeroes(c_uint),
    next: [*c]struct_nk_window = @import("std").mem.zeroes([*c]struct_nk_window),
    prev: [*c]struct_nk_window = @import("std").mem.zeroes([*c]struct_nk_window),
    parent: [*c]struct_nk_window = @import("std").mem.zeroes([*c]struct_nk_window),
};
pub const union_nk_page_data = extern union {
    tbl: struct_nk_table,
    pan: struct_nk_panel,
    win: struct_nk_window,
};
pub const struct_nk_page_element = extern struct {
    data: union_nk_page_data = @import("std").mem.zeroes(union_nk_page_data),
    next: [*c]struct_nk_page_element = @import("std").mem.zeroes([*c]struct_nk_page_element),
    prev: [*c]struct_nk_page_element = @import("std").mem.zeroes([*c]struct_nk_page_element),
};
pub const struct_nk_page = extern struct {
    size: c_uint = @import("std").mem.zeroes(c_uint),
    next: [*c]struct_nk_page = @import("std").mem.zeroes([*c]struct_nk_page),
    win: [1]struct_nk_page_element = @import("std").mem.zeroes([1]struct_nk_page_element),
};
pub const struct_nk_pool = extern struct {
    alloc: struct_nk_allocator = @import("std").mem.zeroes(struct_nk_allocator),
    type: enum_nk_allocation_type = @import("std").mem.zeroes(enum_nk_allocation_type),
    page_count: c_uint = @import("std").mem.zeroes(c_uint),
    pages: [*c]struct_nk_page = @import("std").mem.zeroes([*c]struct_nk_page),
    freelist: [*c]struct_nk_page_element = @import("std").mem.zeroes([*c]struct_nk_page_element),
    capacity: c_uint = @import("std").mem.zeroes(c_uint),
    size: nk_size = @import("std").mem.zeroes(nk_size),
    cap: nk_size = @import("std").mem.zeroes(nk_size),
};
pub const struct_nk_context = extern struct {
    input: struct_nk_input = @import("std").mem.zeroes(struct_nk_input),
    style: struct_nk_style = @import("std").mem.zeroes(struct_nk_style),
    memory: struct_nk_buffer = @import("std").mem.zeroes(struct_nk_buffer),
    clip: struct_nk_clipboard = @import("std").mem.zeroes(struct_nk_clipboard),
    last_widget_state: nk_flags = @import("std").mem.zeroes(nk_flags),
    button_behavior: enum_nk_button_behavior = @import("std").mem.zeroes(enum_nk_button_behavior),
    stacks: struct_nk_configuration_stacks = @import("std").mem.zeroes(struct_nk_configuration_stacks),
    delta_time_seconds: f32 = @import("std").mem.zeroes(f32),
    text_edit: struct_nk_text_edit = @import("std").mem.zeroes(struct_nk_text_edit),
    overlay: struct_nk_command_buffer = @import("std").mem.zeroes(struct_nk_command_buffer),
    build: c_int = @import("std").mem.zeroes(c_int),
    use_pool: c_int = @import("std").mem.zeroes(c_int),
    pool: struct_nk_pool = @import("std").mem.zeroes(struct_nk_pool),
    begin: [*c]struct_nk_window = @import("std").mem.zeroes([*c]struct_nk_window),
    end: [*c]struct_nk_window = @import("std").mem.zeroes([*c]struct_nk_window),
    active: [*c]struct_nk_window = @import("std").mem.zeroes([*c]struct_nk_window),
    current: [*c]struct_nk_window = @import("std").mem.zeroes([*c]struct_nk_window),
    freelist: [*c]struct_nk_page_element = @import("std").mem.zeroes([*c]struct_nk_page_element),
    count: c_uint = @import("std").mem.zeroes(c_uint),
    seq: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_nk_style_slide = opaque {};
pub const nk_false: c_int = 0;
pub const nk_true: c_int = 1;
const enum_unnamed_1 = c_uint;
pub const struct_nk_colorf = extern struct {
    r: f32 = @import("std").mem.zeroes(f32),
    g: f32 = @import("std").mem.zeroes(f32),
    b: f32 = @import("std").mem.zeroes(f32),
    a: f32 = @import("std").mem.zeroes(f32),
};
pub const struct_nk_vec2i = extern struct {
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
};
pub const struct_nk_recti = extern struct {
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    w: c_short = @import("std").mem.zeroes(c_short),
    h: c_short = @import("std").mem.zeroes(c_short),
};
pub const nk_glyph = [4]u8;
pub const nk_handle = extern union {
    ptr: ?*anyopaque,
    id: c_int,
};
pub const NK_UP: c_int = 0;
pub const NK_RIGHT: c_int = 1;
pub const NK_DOWN: c_int = 2;
pub const NK_LEFT: c_int = 3;
pub const enum_nk_heading = c_uint;
pub const NK_FIXED: c_int = 0;
pub const NK_MODIFIABLE: c_int = 1;
pub const enum_nk_modify = c_uint;
pub const NK_VERTICAL: c_int = 0;
pub const NK_HORIZONTAL: c_int = 1;
pub const enum_nk_orientation = c_uint;
pub const NK_MINIMIZED: c_int = 0;
pub const NK_MAXIMIZED: c_int = 1;
pub const enum_nk_collapse_states = c_uint;
pub const NK_HIDDEN: c_int = 0;
pub const NK_SHOWN: c_int = 1;
pub const enum_nk_show_states = c_uint;
pub const NK_CHART_HOVERING: c_int = 1;
pub const NK_CHART_CLICKED: c_int = 2;
pub const enum_nk_chart_event = c_uint;
pub const NK_RGB: c_int = 0;
pub const NK_RGBA: c_int = 1;
pub const enum_nk_color_format = c_uint;
pub const NK_POPUP_STATIC: c_int = 0;
pub const NK_POPUP_DYNAMIC: c_int = 1;
pub const enum_nk_popup_type = c_uint;
pub const NK_DYNAMIC: c_int = 0;
pub const NK_STATIC: c_int = 1;
pub const enum_nk_layout_format = c_uint;
pub const NK_TREE_NODE: c_int = 0;
pub const NK_TREE_TAB: c_int = 1;
pub const enum_nk_tree_type = c_uint;
pub fn nk_init_fixed(arg_ctx: [*c]struct_nk_context, arg_memory: ?*anyopaque, arg_size: nk_size, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var memory = arg_memory;
    _ = &memory;
    var size = arg_size;
    _ = &size;
    var font = arg_font;
    _ = &font;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (memory != null) {} else {
                __assert_fail("memory", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19367))), "nk_bool nk_init_fixed(struct nk_context *, void *, nk_size, const struct nk_user_font *)");
            };
        };
    };
    if (!(memory != null)) return 0;
    nk_setup(ctx, font);
    nk_buffer_init_fixed(&ctx.*.memory, memory, size);
    ctx.*.use_pool = nk_false;
    return 1;
}
pub fn nk_init(arg_ctx: [*c]struct_nk_context, arg_alloc: [*c]const struct_nk_allocator, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var alloc = arg_alloc;
    _ = &alloc;
    var font = arg_font;
    _ = &font;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (alloc != null) {} else {
                __assert_fail("alloc", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19399))), "nk_bool nk_init(struct nk_context *, const struct nk_allocator *, const struct nk_user_font *)");
            };
        };
    };
    if (!(alloc != null)) return 0;
    nk_setup(ctx, font);
    nk_buffer_init(&ctx.*.memory, alloc, @as(nk_size, @bitCast(@as(c_long, @as(c_int, 4) * @as(c_int, 1024)))));
    nk_pool_init(&ctx.*.pool, alloc, @as(c_uint, @bitCast(@as(c_int, 16))));
    ctx.*.use_pool = nk_true;
    return 1;
}
pub fn nk_init_custom(arg_ctx: [*c]struct_nk_context, arg_cmds: [*c]struct_nk_buffer, arg_pool: [*c]struct_nk_buffer, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var cmds = arg_cmds;
    _ = &cmds;
    var pool = arg_pool;
    _ = &pool;
    var font = arg_font;
    _ = &font;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (cmds != null) {} else {
                __assert_fail("cmds", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19378))), "nk_bool nk_init_custom(struct nk_context *, struct nk_buffer *, struct nk_buffer *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (pool != null) {} else {
                __assert_fail("pool", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19379))), "nk_bool nk_init_custom(struct nk_context *, struct nk_buffer *, struct nk_buffer *, const struct nk_user_font *)");
            };
        };
    };
    if (!(cmds != null) or !(pool != null)) return 0;
    nk_setup(ctx, font);
    ctx.*.memory = cmds.*;
    if (pool.*.type == @as(c_uint, @bitCast(NK_BUFFER_FIXED))) {
        nk_pool_init_fixed(&ctx.*.pool, pool.*.memory.ptr, pool.*.memory.size);
    } else {
        var alloc: [*c]struct_nk_allocator = &pool.*.pool;
        _ = &alloc;
        nk_pool_init(&ctx.*.pool, alloc, @as(c_uint, @bitCast(@as(c_int, 16))));
    }
    ctx.*.use_pool = nk_true;
    return 1;
}
pub fn nk_clear(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var iter: [*c]struct_nk_window = undefined;
    _ = &iter;
    var next: [*c]struct_nk_window = undefined;
    _ = &next;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19444))), "void nk_clear(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return;
    if (ctx.*.use_pool != 0) {
        nk_buffer_clear(&ctx.*.memory);
    } else {
        nk_buffer_reset(&ctx.*.memory, @as(c_uint, @bitCast(NK_BUFFER_FRONT)));
    }
    ctx.*.build = 0;
    ctx.*.memory.calls = 0;
    ctx.*.last_widget_state = 0;
    ctx.*.style.cursor_active = ctx.*.style.cursors[@as(c_uint, @intCast(NK_CURSOR_ARROW))];
    nk_memset(@as(?*anyopaque, @ptrCast(&ctx.*.overlay)), @as(c_int, 0), @sizeOf(struct_nk_command_buffer));
    iter = ctx.*.begin;
    while (iter != null) {
        if ((((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0) and !((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSED))) != 0)) and (iter.*.seq == ctx.*.seq)) {
            iter = iter.*.next;
            continue;
        }
        if ((((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) or ((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSED))) != 0)) and (iter == ctx.*.active)) {
            ctx.*.active = iter.*.prev;
            ctx.*.end = iter.*.prev;
            if (!(ctx.*.end != null)) {
                ctx.*.begin = null;
            }
            if (ctx.*.active != null) {
                ctx.*.active.*.flags &= @as(nk_flags, @bitCast(~@as(c_uint, @bitCast(NK_WINDOW_ROM))));
            }
        }
        if ((iter.*.popup.win != null) and (iter.*.popup.win.*.seq != ctx.*.seq)) {
            nk_free_window(ctx, iter.*.popup.win);
            iter.*.popup.win = null;
        }
        {
            var n: [*c]struct_nk_table = undefined;
            _ = &n;
            var it: [*c]struct_nk_table = iter.*.tables;
            _ = &it;
            while (it != null) {
                n = it.*.next;
                if (it.*.seq != ctx.*.seq) {
                    nk_remove_table(iter, it);
                    nk_zero(@as(?*anyopaque, @ptrCast(it)), @sizeOf(union_nk_page_data));
                    nk_free_table(ctx, it);
                    if (it == iter.*.tables) {
                        iter.*.tables = n;
                    }
                }
                it = n;
            }
        }
        if ((iter.*.seq != ctx.*.seq) or ((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSED))) != 0)) {
            next = iter.*.next;
            nk_remove_window(ctx, iter);
            nk_free_window(ctx, iter);
            iter = next;
        } else {
            iter = iter.*.next;
        }
    }
    ctx.*.seq +%= 1;
}
pub fn nk_free(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19420))), "void nk_free(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return;
    nk_buffer_free(&ctx.*.memory);
    if (ctx.*.use_pool != 0) {
        nk_pool_free(&ctx.*.pool);
    }
    nk_zero(@as(?*anyopaque, @ptrCast(&ctx.*.input)), @sizeOf(struct_nk_input));
    nk_zero(@as(?*anyopaque, @ptrCast(&ctx.*.style)), @sizeOf(struct_nk_style));
    nk_zero(@as(?*anyopaque, @ptrCast(&ctx.*.memory)), @sizeOf(struct_nk_buffer));
    ctx.*.seq = 0;
    ctx.*.build = 0;
    ctx.*.begin = null;
    ctx.*.end = null;
    ctx.*.active = null;
    ctx.*.current = null;
    ctx.*.freelist = null;
    ctx.*.count = 0;
}
pub const NK_KEY_NONE: c_int = 0;
pub const NK_KEY_SHIFT: c_int = 1;
pub const NK_KEY_CTRL: c_int = 2;
pub const NK_KEY_DEL: c_int = 3;
pub const NK_KEY_ENTER: c_int = 4;
pub const NK_KEY_TAB: c_int = 5;
pub const NK_KEY_BACKSPACE: c_int = 6;
pub const NK_KEY_COPY: c_int = 7;
pub const NK_KEY_CUT: c_int = 8;
pub const NK_KEY_PASTE: c_int = 9;
pub const NK_KEY_UP: c_int = 10;
pub const NK_KEY_DOWN: c_int = 11;
pub const NK_KEY_LEFT: c_int = 12;
pub const NK_KEY_RIGHT: c_int = 13;
pub const NK_KEY_TEXT_INSERT_MODE: c_int = 14;
pub const NK_KEY_TEXT_REPLACE_MODE: c_int = 15;
pub const NK_KEY_TEXT_RESET_MODE: c_int = 16;
pub const NK_KEY_TEXT_LINE_START: c_int = 17;
pub const NK_KEY_TEXT_LINE_END: c_int = 18;
pub const NK_KEY_TEXT_START: c_int = 19;
pub const NK_KEY_TEXT_END: c_int = 20;
pub const NK_KEY_TEXT_UNDO: c_int = 21;
pub const NK_KEY_TEXT_REDO: c_int = 22;
pub const NK_KEY_TEXT_SELECT_ALL: c_int = 23;
pub const NK_KEY_TEXT_WORD_LEFT: c_int = 24;
pub const NK_KEY_TEXT_WORD_RIGHT: c_int = 25;
pub const NK_KEY_SCROLL_START: c_int = 26;
pub const NK_KEY_SCROLL_END: c_int = 27;
pub const NK_KEY_SCROLL_DOWN: c_int = 28;
pub const NK_KEY_SCROLL_UP: c_int = 29;
pub const NK_KEY_MAX: c_int = 30;
pub const enum_nk_keys = c_uint;
pub const NK_BUTTON_LEFT: c_int = 0;
pub const NK_BUTTON_MIDDLE: c_int = 1;
pub const NK_BUTTON_RIGHT: c_int = 2;
pub const NK_BUTTON_DOUBLE: c_int = 3;
pub const NK_BUTTON_MAX: c_int = 4;
pub const enum_nk_buttons = c_uint;
pub fn nk_input_begin(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var i: c_int = undefined;
    _ = &i;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18195))), "void nk_input_begin(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return;
    in = &ctx.*.input;
    {
        i = 0;
        while (i < NK_BUTTON_MAX) : (i += 1) {
            in.*.mouse.buttons[@as(c_uint, @intCast(i))].clicked = 0;
        }
    }
    in.*.keyboard.text_len = 0;
    in.*.mouse.scroll_delta = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    in.*.mouse.prev.x = in.*.mouse.pos.x;
    in.*.mouse.prev.y = in.*.mouse.pos.y;
    in.*.mouse.delta.x = 0;
    in.*.mouse.delta.y = 0;
    {
        i = 0;
        while (i < NK_KEY_MAX) : (i += 1) {
            in.*.keyboard.keys[@as(c_uint, @intCast(i))].clicked = 0;
        }
    }
}
pub fn nk_input_motion(arg_ctx: [*c]struct_nk_context, arg_x: c_int, arg_y: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18229))), "void nk_input_motion(struct nk_context *, int, int)");
            };
        };
    };
    if (!(ctx != null)) return;
    in = &ctx.*.input;
    in.*.mouse.pos.x = @as(f32, @floatFromInt(x));
    in.*.mouse.pos.y = @as(f32, @floatFromInt(y));
    in.*.mouse.delta.x = in.*.mouse.pos.x - in.*.mouse.prev.x;
    in.*.mouse.delta.y = in.*.mouse.pos.y - in.*.mouse.prev.y;
}
pub fn nk_input_key(arg_ctx: [*c]struct_nk_context, arg_key: enum_nk_keys, arg_down: nk_bool) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var key = arg_key;
    _ = &key;
    var down = arg_down;
    _ = &down;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18241))), "void nk_input_key(struct nk_context *, enum nk_keys, nk_bool)");
            };
        };
    };
    if (!(ctx != null)) return;
    in = &ctx.*.input;
    in.*.keyboard.keys[key].clicked +%= 1;
    in.*.keyboard.keys[key].down = down;
}
pub fn nk_input_button(arg_ctx: [*c]struct_nk_context, arg_id: enum_nk_buttons, arg_x: c_int, arg_y: c_int, arg_down: nk_bool) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var id = arg_id;
    _ = &id;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var down = arg_down;
    _ = &down;
    var btn: [*c]struct_nk_mouse_button = undefined;
    _ = &btn;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18257))), "void nk_input_button(struct nk_context *, enum nk_buttons, int, int, nk_bool)");
            };
        };
    };
    if (!(ctx != null)) return;
    in = &ctx.*.input;
    if (in.*.mouse.buttons[id].down == down) return;
    btn = &in.*.mouse.buttons[id];
    btn.*.clicked_pos.x = @as(f32, @floatFromInt(x));
    btn.*.clicked_pos.y = @as(f32, @floatFromInt(y));
    btn.*.down = down;
    btn.*.clicked +%= 1;
    in.*.mouse.delta.x = 0;
    in.*.mouse.delta.y = 0;
}
pub fn nk_input_scroll(arg_ctx: [*c]struct_nk_context, arg_val: struct_nk_vec2) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var val = arg_val;
    _ = &val;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18282))), "void nk_input_scroll(struct nk_context *, struct nk_vec2)");
            };
        };
    };
    if (!(ctx != null)) return;
    ctx.*.input.mouse.scroll_delta.x += val.x;
    ctx.*.input.mouse.scroll_delta.y += val.y;
}
pub fn nk_input_char(arg_ctx: [*c]struct_nk_context, arg_c: u8) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var c = arg_c;
    _ = &c;
    var glyph: nk_glyph = [1]u8{
        0,
    } ++ [1]u8{0} ** 3;
    _ = &glyph;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18309))), "void nk_input_char(struct nk_context *, char)");
            };
        };
    };
    if (!(ctx != null)) return;
    glyph[@as(c_uint, @intCast(@as(c_int, 0)))] = c;
    nk_input_glyph(ctx, @as([*c]u8, @ptrCast(@alignCast(&glyph))));
}
pub fn nk_input_glyph(arg_ctx: [*c]struct_nk_context, glyph: [*c]const u8) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = &glyph;
    var len: c_int = 0;
    _ = &len;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18294))), "void nk_input_glyph(struct nk_context *, const char *)");
            };
        };
    };
    if (!(ctx != null)) return;
    in = &ctx.*.input;
    len = nk_utf_decode(glyph, &unicode, @as(c_int, 4));
    if ((len != 0) and ((in.*.keyboard.text_len + len) < @as(c_int, 16))) {
        _ = nk_utf_encode(unicode, &in.*.keyboard.text[@as(c_uint, @intCast(in.*.keyboard.text_len))], @as(c_int, 16) - in.*.keyboard.text_len);
        in.*.keyboard.text_len += len;
    }
}
pub fn nk_input_unicode(arg_ctx: [*c]struct_nk_context, arg_unicode: nk_rune) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var unicode = arg_unicode;
    _ = &unicode;
    var rune: nk_glyph = undefined;
    _ = &rune;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18318))), "void nk_input_unicode(struct nk_context *, nk_rune)");
            };
        };
    };
    if (!(ctx != null)) return;
    _ = nk_utf_encode(unicode, @as([*c]u8, @ptrCast(@alignCast(&rune))), @as(c_int, 4));
    nk_input_glyph(ctx, @as([*c]u8, @ptrCast(@alignCast(&rune))));
}
pub fn nk_input_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18214))), "void nk_input_end(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return;
    in = &ctx.*.input;
    if (in.*.mouse.grab != 0) {
        in.*.mouse.grab = 0;
    }
    if (in.*.mouse.ungrab != 0) {
        in.*.mouse.grabbed = 0;
        in.*.mouse.ungrab = 0;
        in.*.mouse.grab = 0;
    }
}
pub const NK_CONVERT_SUCCESS: c_int = 0;
pub const NK_CONVERT_INVALID_PARAM: c_int = 1;
pub const NK_CONVERT_COMMAND_BUFFER_FULL: c_int = 2;
pub const NK_CONVERT_VERTEX_BUFFER_FULL: c_int = 4;
pub const NK_CONVERT_ELEMENT_BUFFER_FULL: c_int = 8;
pub const enum_nk_convert_result = c_uint;
pub const NK_COMMAND_NOP: c_int = 0;
pub const NK_COMMAND_SCISSOR: c_int = 1;
pub const NK_COMMAND_LINE: c_int = 2;
pub const NK_COMMAND_CURVE: c_int = 3;
pub const NK_COMMAND_RECT: c_int = 4;
pub const NK_COMMAND_RECT_FILLED: c_int = 5;
pub const NK_COMMAND_RECT_MULTI_COLOR: c_int = 6;
pub const NK_COMMAND_CIRCLE: c_int = 7;
pub const NK_COMMAND_CIRCLE_FILLED: c_int = 8;
pub const NK_COMMAND_ARC: c_int = 9;
pub const NK_COMMAND_ARC_FILLED: c_int = 10;
pub const NK_COMMAND_TRIANGLE: c_int = 11;
pub const NK_COMMAND_TRIANGLE_FILLED: c_int = 12;
pub const NK_COMMAND_POLYGON: c_int = 13;
pub const NK_COMMAND_POLYGON_FILLED: c_int = 14;
pub const NK_COMMAND_POLYLINE: c_int = 15;
pub const NK_COMMAND_TEXT: c_int = 16;
pub const NK_COMMAND_IMAGE: c_int = 17;
pub const NK_COMMAND_CUSTOM: c_int = 18;
pub const enum_nk_command_type = c_uint;
pub const struct_nk_command = extern struct {
    type: enum_nk_command_type = @import("std").mem.zeroes(enum_nk_command_type),
    next: nk_size = @import("std").mem.zeroes(nk_size),
};
pub fn nk__begin(arg_ctx: [*c]struct_nk_context) callconv(.c) [*c]const struct_nk_command {
    var ctx = arg_ctx;
    _ = &ctx;
    var iter: [*c]struct_nk_window = undefined;
    _ = &iter;
    var buffer: [*c]nk_byte = undefined;
    _ = &buffer;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19644))), "const struct nk_command *nk__begin(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return null;
    if (!(ctx.*.count != 0)) return null;
    buffer = @as([*c]nk_byte, @ptrCast(@alignCast(ctx.*.memory.memory.ptr)));
    if (!(ctx.*.build != 0)) {
        nk_build(ctx);
        ctx.*.build = nk_true;
    }
    iter = ctx.*.begin;
    while ((iter != null) and (((iter.*.buffer.begin == iter.*.buffer.end) or ((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) or (iter.*.seq != ctx.*.seq))) {
        iter = iter.*.next;
    }
    if (!(iter != null)) return null;
    return @as([*c]const struct_nk_command, @ptrCast(@alignCast(@as(?*const anyopaque, @ptrCast(@as([*c]const nk_byte, @ptrCast(@alignCast(buffer))) + iter.*.buffer.begin)))));
}
pub fn nk__next(arg_ctx: [*c]struct_nk_context, arg_cmd: [*c]const struct_nk_command) callconv(.c) [*c]const struct_nk_command {
    var ctx = arg_ctx;
    _ = &ctx;
    var cmd = arg_cmd;
    _ = &cmd;
    var buffer: [*c]nk_byte = undefined;
    _ = &buffer;
    var next: [*c]const struct_nk_command = undefined;
    _ = &next;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19666))), "const struct nk_command *nk__next(struct nk_context *, const struct nk_command *)");
            };
        };
    };
    if ((!(ctx != null) or !(cmd != null)) or !(ctx.*.count != 0)) return null;
    if (cmd.*.next >= ctx.*.memory.allocated) return null;
    buffer = @as([*c]nk_byte, @ptrCast(@alignCast(ctx.*.memory.memory.ptr)));
    next = @as([*c]const struct_nk_command, @ptrCast(@alignCast(@as(?*const anyopaque, @ptrCast(@as([*c]const nk_byte, @ptrCast(@alignCast(buffer))) + cmd.*.next)))));
    return next;
}
pub const NK_WINDOW_BORDER: c_int = 1;
pub const NK_WINDOW_MOVABLE: c_int = 2;
pub const NK_WINDOW_SCALABLE: c_int = 4;
pub const NK_WINDOW_CLOSABLE: c_int = 8;
pub const NK_WINDOW_MINIMIZABLE: c_int = 16;
pub const NK_WINDOW_NO_SCROLLBAR: c_int = 32;
pub const NK_WINDOW_TITLE: c_int = 64;
pub const NK_WINDOW_SCROLL_AUTO_HIDE: c_int = 128;
pub const NK_WINDOW_BACKGROUND: c_int = 256;
pub const NK_WINDOW_SCALE_LEFT: c_int = 512;
pub const NK_WINDOW_NO_INPUT: c_int = 1024;
pub const enum_nk_panel_flags = c_uint;
pub fn nk_begin(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_bounds: struct_nk_rect, arg_flags: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var bounds = arg_bounds;
    _ = &bounds;
    var flags = arg_flags;
    _ = &flags;
    return nk_begin_titled(ctx, title, title, bounds, flags);
}
pub fn nk_begin_titled(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_title: [*c]const u8, arg_bounds: struct_nk_rect, arg_flags: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var title = arg_title;
    _ = &title;
    var bounds = arg_bounds;
    _ = &bounds;
    var flags = arg_flags;
    _ = &flags;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    var name_hash: nk_hash = undefined;
    _ = &name_hash;
    var name_len: c_int = undefined;
    _ = &name_len;
    var ret: c_int = 0;
    _ = &ret;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20668))), "nk_bool nk_begin_titled(struct nk_context *, const char *, const char *, struct nk_rect, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (name != null) {} else {
                __assert_fail("name", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20669))), "nk_bool nk_begin_titled(struct nk_context *, const char *, const char *, struct nk_rect, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (title != null) {} else {
                __assert_fail("title", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20670))), "nk_bool nk_begin_titled(struct nk_context *, const char *, const char *, struct nk_rect, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (((ctx.*.style.font != null) and (ctx.*.style.font.*.width != null)) and (@intFromPtr("if this triggers you forgot to add a font") != 0)) {} else {
                __assert_fail("ctx->style.font && ctx->style.font->width && \"if this triggers you forgot to add a font\"", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20671))), "nk_bool nk_begin_titled(struct nk_context *, const char *, const char *, struct nk_rect, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!(ctx.*.current != null) and (@intFromPtr("if this triggers you missed a `nk_end` call") != 0)) {} else {
                __assert_fail("!ctx->current && \"if this triggers you missed a `nk_end` call\"", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20672))), "nk_bool nk_begin_titled(struct nk_context *, const char *, const char *, struct nk_rect, nk_flags)");
            };
        };
    };
    if (((!(ctx != null) or (ctx.*.current != null)) or !(title != null)) or !(name != null)) return 0;
    style = &ctx.*.style;
    name_len = nk_strlen(name);
    name_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), name_len, @as(nk_hash, @bitCast(NK_WINDOW_TITLE)));
    win = nk_find_window(ctx, name_hash, name);
    if (!(win != null)) {
        var name_length: nk_size = @as(nk_size, @bitCast(@as(c_long, name_len)));
        _ = &name_length;
        win = @as([*c]struct_nk_window, @ptrCast(@alignCast(nk_create_window(ctx))));
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (win != null) {} else {
                    __assert_fail("win", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20685))), "nk_bool nk_begin_titled(struct nk_context *, const char *, const char *, struct nk_rect, nk_flags)");
                };
            };
        };
        if (!(win != null)) return 0;
        if ((flags & @as(nk_flags, @bitCast(NK_WINDOW_BACKGROUND))) != 0) {
            nk_insert_window(ctx, win, @as(c_uint, @bitCast(NK_INSERT_FRONT)));
        } else {
            nk_insert_window(ctx, win, @as(c_uint, @bitCast(NK_INSERT_BACK)));
        }
        nk_command_buffer_init(&win.*.buffer, &ctx.*.memory, @as(c_uint, @bitCast(NK_CLIPPING_ON)));
        win.*.flags = flags;
        win.*.bounds = bounds;
        win.*.name = name_hash;
        name_length = if (name_length < @as(nk_size, @bitCast(@as(c_long, @as(c_int, 64) - @as(c_int, 1))))) name_length else @as(nk_size, @bitCast(@as(c_long, @as(c_int, 64) - @as(c_int, 1))));
        _ = nk_memcopy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&win.*.name_string))))), @as(?*const anyopaque, @ptrCast(name)), name_length);
        win.*.name_string[name_length] = 0;
        win.*.popup.win = null;
        win.*.widgets_disabled = nk_false;
        if (!(ctx.*.active != null)) {
            ctx.*.active = win;
        }
    } else {
        win.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_PRIVATE - @as(c_int, 1)));
        win.*.flags |= flags;
        if (!((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MOVABLE | NK_WINDOW_SCALABLE))) != 0)) {
            win.*.bounds = bounds;
        }
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (win.*.seq != ctx.*.seq) {} else {
                    __assert_fail("win->seq != ctx->seq", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20716))), "nk_bool nk_begin_titled(struct nk_context *, const char *, const char *, struct nk_rect, nk_flags)");
                };
            };
        };
        win.*.seq = ctx.*.seq;
        if (!(ctx.*.active != null) and !((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) {
            ctx.*.active = win;
            ctx.*.end = win;
        }
    }
    if ((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) {
        ctx.*.current = win;
        win.*.layout = null;
        return 0;
    } else {
        nk_start(ctx, win);
    }
    if (!((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) and !((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_NO_INPUT))) != 0)) {
        var inpanel: c_int = undefined;
        _ = &inpanel;
        var ishovered: c_int = undefined;
        _ = &ishovered;
        var iter: [*c]struct_nk_window = win;
        _ = &iter;
        var h: f32 = (ctx.*.style.font.*.height + (2.0 * style.*.window.header.padding.y)) + (2.0 * style.*.window.header.label_padding.y);
        _ = &h;
        var win_bounds: struct_nk_rect = if (!((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) win.*.bounds else nk_rect(win.*.bounds.x, win.*.bounds.y, win.*.bounds.w, h);
        _ = &win_bounds;
        inpanel = nk_input_has_mouse_click_down_in_rect(&ctx.*.input, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), win_bounds, nk_true);
        inpanel = @intFromBool((inpanel != 0) and (ctx.*.input.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked != 0));
        ishovered = nk_input_is_mouse_hovering_rect(&ctx.*.input, win_bounds);
        if (((win != ctx.*.active) and (ishovered != 0)) and !(ctx.*.input.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0)) {
            iter = win.*.next;
            while (iter != null) {
                var iter_bounds: struct_nk_rect = if (!((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) iter.*.bounds else nk_rect(iter.*.bounds.x, iter.*.bounds.y, iter.*.bounds.w, h);
                _ = &iter_bounds;
                if (((((iter_bounds.x < (win_bounds.x + win_bounds.w)) and (win_bounds.x < (iter_bounds.x + iter_bounds.w))) and (iter_bounds.y < (win_bounds.y + win_bounds.h))) and (win_bounds.y < (iter_bounds.y + iter_bounds.h))) and !((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) break;
                if ((((iter.*.popup.win != null) and (iter.*.popup.active != 0)) and !((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) and ((((iter.*.popup.win.*.bounds.x < (win.*.bounds.x + win_bounds.w)) and (win.*.bounds.x < (iter.*.popup.win.*.bounds.x + iter.*.popup.win.*.bounds.w))) and (iter.*.popup.win.*.bounds.y < (win_bounds.y + win_bounds.h))) and (win_bounds.y < (iter.*.popup.win.*.bounds.y + iter.*.popup.win.*.bounds.h)))) break;
                iter = iter.*.next;
            }
        }
        if (((iter != null) and (inpanel != 0)) and (win != ctx.*.end)) {
            iter = win.*.next;
            while (iter != null) {
                var iter_bounds: struct_nk_rect = if (!((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) iter.*.bounds else nk_rect(iter.*.bounds.x, iter.*.bounds.y, iter.*.bounds.w, h);
                _ = &iter_bounds;
                if ((((iter_bounds.x <= ctx.*.input.mouse.pos.x) and (ctx.*.input.mouse.pos.x < (iter_bounds.x + iter_bounds.w))) and ((iter_bounds.y <= ctx.*.input.mouse.pos.y) and (ctx.*.input.mouse.pos.y < (iter_bounds.y + iter_bounds.h)))) and !((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) break;
                if ((((iter.*.popup.win != null) and (iter.*.popup.active != 0)) and !((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) and ((((iter.*.popup.win.*.bounds.x < (win_bounds.x + win_bounds.w)) and (win_bounds.x < (iter.*.popup.win.*.bounds.x + iter.*.popup.win.*.bounds.w))) and (iter.*.popup.win.*.bounds.y < (win_bounds.y + win_bounds.h))) and (win_bounds.y < (iter.*.popup.win.*.bounds.y + iter.*.popup.win.*.bounds.h)))) break;
                iter = iter.*.next;
            }
        }
        if (((iter != null) and !((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) and ((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_BACKGROUND))) != 0)) {
            win.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_ROM));
            iter.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_ROM));
            ctx.*.active = iter;
            if (!((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_BACKGROUND))) != 0)) {
                nk_remove_window(ctx, iter);
                nk_insert_window(ctx, iter, @as(c_uint, @bitCast(NK_INSERT_BACK)));
            }
        } else {
            if (!(iter != null) and (ctx.*.end != win)) {
                if (!((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_BACKGROUND))) != 0)) {
                    nk_remove_window(ctx, win);
                    nk_insert_window(ctx, win, @as(c_uint, @bitCast(NK_INSERT_BACK)));
                }
                win.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_ROM));
                ctx.*.active = win;
            }
            if ((ctx.*.end != win) and !((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_BACKGROUND))) != 0)) {
                win.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_ROM));
            }
        }
    }
    win.*.layout = @as([*c]struct_nk_panel, @ptrCast(@alignCast(nk_create_panel(ctx))));
    ctx.*.current = win;
    ret = nk_panel_begin(ctx, title, @as(c_uint, @bitCast(NK_PANEL_WINDOW)));
    win.*.layout.*.offset_x = &win.*.scrollbar.x;
    win.*.layout.*.offset_y = &win.*.scrollbar.y;
    return ret;
}
pub fn nk_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20817))), "void nk_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((ctx.*.current != null) and (@intFromPtr("if this triggers you forgot to call `nk_begin`") != 0)) {} else {
                __assert_fail("ctx->current && \"if this triggers you forgot to call `nk_begin`\"", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20818))), "void nk_end(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    layout = ctx.*.current.*.layout;
    if (!(layout != null) or ((layout.*.type == @as(c_uint, @bitCast(NK_PANEL_WINDOW))) and ((ctx.*.current.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0))) {
        ctx.*.current = null;
        return;
    }
    nk_panel_end(ctx);
    nk_free_panel(ctx, ctx.*.current.*.layout);
    ctx.*.current = null;
}
pub fn nk_window_find(arg_ctx: [*c]const struct_nk_context, arg_name: [*c]const u8) callconv(.c) [*c]struct_nk_window {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), title_len, @as(nk_hash, @bitCast(NK_WINDOW_TITLE)));
    return nk_find_window(ctx, title_hash, name);
}
pub fn nk_window_get_bounds(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_rect {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20834))), "struct nk_rect nk_window_get_bounds(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20835))), "struct nk_rect nk_window_get_bounds(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_rect(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    return ctx.*.current.*.bounds;
}
pub fn nk_window_get_position(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_vec2 {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20842))), "struct nk_vec2 nk_window_get_position(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20843))), "struct nk_vec2 nk_window_get_position(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    return nk_vec2(ctx.*.current.*.bounds.x, ctx.*.current.*.bounds.y);
}
pub fn nk_window_get_size(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_vec2 {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20850))), "struct nk_vec2 nk_window_get_size(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20851))), "struct nk_vec2 nk_window_get_size(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    return nk_vec2(ctx.*.current.*.bounds.w, ctx.*.current.*.bounds.h);
}
pub fn nk_window_get_width(arg_ctx: [*c]const struct_nk_context) callconv(.c) f32 {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20858))), "float nk_window_get_width(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20859))), "float nk_window_get_width(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return 0;
    return ctx.*.current.*.bounds.w;
}
pub fn nk_window_get_height(arg_ctx: [*c]const struct_nk_context) callconv(.c) f32 {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20866))), "float nk_window_get_height(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20867))), "float nk_window_get_height(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return 0;
    return ctx.*.current.*.bounds.h;
}
pub fn nk_window_get_panel(arg_ctx: [*c]const struct_nk_context) callconv(.c) [*c]struct_nk_panel {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20919))), "struct nk_panel *nk_window_get_panel(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20920))), "struct nk_panel *nk_window_get_panel(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return null;
    return ctx.*.current.*.layout;
}
pub fn nk_window_get_content_region(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_rect {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20874))), "struct nk_rect nk_window_get_content_region(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20875))), "struct nk_rect nk_window_get_content_region(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_rect(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    return ctx.*.current.*.layout.*.clip;
}
pub fn nk_window_get_content_region_min(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_vec2 {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20882))), "struct nk_vec2 nk_window_get_content_region_min(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20883))), "struct nk_vec2 nk_window_get_content_region_min(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20884))), "struct nk_vec2 nk_window_get_content_region_min(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    return nk_vec2(ctx.*.current.*.layout.*.clip.x, ctx.*.current.*.layout.*.clip.y);
}
pub fn nk_window_get_content_region_max(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_vec2 {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20891))), "struct nk_vec2 nk_window_get_content_region_max(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20892))), "struct nk_vec2 nk_window_get_content_region_max(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20893))), "struct nk_vec2 nk_window_get_content_region_max(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    return nk_vec2(ctx.*.current.*.layout.*.clip.x + ctx.*.current.*.layout.*.clip.w, ctx.*.current.*.layout.*.clip.y + ctx.*.current.*.layout.*.clip.h);
}
pub fn nk_window_get_content_region_size(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_vec2 {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20901))), "struct nk_vec2 nk_window_get_content_region_size(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20902))), "struct nk_vec2 nk_window_get_content_region_size(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20903))), "struct nk_vec2 nk_window_get_content_region_size(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    return nk_vec2(ctx.*.current.*.layout.*.clip.w, ctx.*.current.*.layout.*.clip.h);
}
pub fn nk_window_get_canvas(arg_ctx: [*c]const struct_nk_context) callconv(.c) [*c]struct_nk_command_buffer {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20910))), "struct nk_command_buffer *nk_window_get_canvas(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20911))), "struct nk_command_buffer *nk_window_get_canvas(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20912))), "struct nk_command_buffer *nk_window_get_canvas(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return null;
    return &ctx.*.current.*.buffer;
}
pub fn nk_window_get_scroll(arg_ctx: [*c]const struct_nk_context, arg_offset_x: [*c]nk_uint, arg_offset_y: [*c]nk_uint) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var offset_x = arg_offset_x;
    _ = &offset_x;
    var offset_y = arg_offset_y;
    _ = &offset_y;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20928))), "void nk_window_get_scroll(const struct nk_context *, nk_uint *, nk_uint *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20929))), "void nk_window_get_scroll(const struct nk_context *, nk_uint *, nk_uint *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    win = ctx.*.current;
    if (offset_x != null) {
        offset_x.* = win.*.scrollbar.x;
    }
    if (offset_y != null) {
        offset_y.* = win.*.scrollbar.y;
    }
}
pub fn nk_window_has_focus(arg_ctx: [*c]const struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20941))), "nk_bool nk_window_has_focus(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20942))), "nk_bool nk_window_has_focus(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20943))), "nk_bool nk_window_has_focus(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return 0;
    return @intFromBool(ctx.*.current == ctx.*.active);
}
pub fn nk_window_is_hovered(arg_ctx: [*c]const struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20950))), "nk_bool nk_window_is_hovered(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20951))), "nk_bool nk_window_is_hovered(const struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or ((ctx.*.current.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) return 0 else {
        var actual_bounds: struct_nk_rect = ctx.*.current.*.bounds;
        _ = &actual_bounds;
        if ((ctx.*.begin.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0) {
            actual_bounds.h = ctx.*.current.*.layout.*.header_height;
        }
        return nk_input_is_mouse_hovering_rect(&ctx.*.input, actual_bounds);
    }
    return @import("std").mem.zeroes(nk_bool);
}
pub fn nk_window_is_collapsed(arg_ctx: [*c]const struct_nk_context, arg_name: [*c]const u8) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21002))), "nk_bool nk_window_is_collapsed(const struct nk_context *, const char *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), title_len, @as(nk_hash, @bitCast(NK_WINDOW_TITLE)));
    win = nk_find_window(ctx, title_hash, name);
    if (!(win != null)) return 0;
    return @as(nk_bool, @bitCast(win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))));
}
pub fn nk_window_is_closed(arg_ctx: [*c]const struct_nk_context, arg_name: [*c]const u8) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21017))), "nk_bool nk_window_is_closed(const struct nk_context *, const char *)");
            };
        };
    };
    if (!(ctx != null)) return 1;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), title_len, @as(nk_hash, @bitCast(NK_WINDOW_TITLE)));
    win = nk_find_window(ctx, title_hash, name);
    if (!(win != null)) return 1;
    return @as(nk_bool, @bitCast(win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSED))));
}
pub fn nk_window_is_hidden(arg_ctx: [*c]const struct_nk_context, arg_name: [*c]const u8) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21032))), "nk_bool nk_window_is_hidden(const struct nk_context *, const char *)");
            };
        };
    };
    if (!(ctx != null)) return 1;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), title_len, @as(nk_hash, @bitCast(NK_WINDOW_TITLE)));
    win = nk_find_window(ctx, title_hash, name);
    if (!(win != null)) return 1;
    return @as(nk_bool, @bitCast(win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))));
}
pub fn nk_window_is_active(arg_ctx: [*c]const struct_nk_context, arg_name: [*c]const u8) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21047))), "nk_bool nk_window_is_active(const struct nk_context *, const char *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), title_len, @as(nk_hash, @bitCast(NK_WINDOW_TITLE)));
    win = nk_find_window(ctx, title_hash, name);
    if (!(win != null)) return 0;
    return @intFromBool(win == ctx.*.active);
}
pub fn nk_window_is_any_hovered(arg_ctx: [*c]const struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var iter: [*c]struct_nk_window = undefined;
    _ = &iter;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20966))), "nk_bool nk_window_is_any_hovered(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    iter = ctx.*.begin;
    while (iter != null) {
        if (!((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) {
            if (((iter.*.popup.active != 0) and (iter.*.popup.win != null)) and (nk_input_is_mouse_hovering_rect(&ctx.*.input, iter.*.popup.win.*.bounds) != 0)) return 1;
            if ((iter.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0) {
                var header: struct_nk_rect = iter.*.bounds;
                _ = &header;
                header.h = ctx.*.style.font.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * ctx.*.style.window.header.padding.y);
                if (nk_input_is_mouse_hovering_rect(&ctx.*.input, header) != 0) return 1;
            } else if (nk_input_is_mouse_hovering_rect(&ctx.*.input, iter.*.bounds) != 0) {
                return 1;
            }
        }
        iter = iter.*.next;
    }
    return 0;
}
pub fn nk_item_is_any_active(arg_ctx: [*c]const struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var any_hovered: c_int = nk_window_is_any_hovered(ctx);
    _ = &any_hovered;
    var any_active: c_int = @as(c_int, @bitCast(ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))));
    _ = &any_active;
    return @intFromBool((any_hovered != 0) or (any_active != 0));
}
pub fn nk_window_set_bounds(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_bounds: struct_nk_rect) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var bounds = arg_bounds;
    _ = &bounds;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21083))), "void nk_window_set_bounds(struct nk_context *, const char *, struct nk_rect)");
            };
        };
    };
    if (!(ctx != null)) return;
    win = nk_window_find(ctx, name);
    if (!(win != null)) return;
    win.*.bounds = bounds;
}
pub fn nk_window_set_position(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_pos: struct_nk_vec2) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var pos = arg_pos;
    _ = &pos;
    var win: [*c]struct_nk_window = nk_window_find(ctx, name);
    _ = &win;
    if (!(win != null)) return;
    win.*.bounds.x = pos.x;
    win.*.bounds.y = pos.y;
}
pub fn nk_window_set_size(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_size: struct_nk_vec2) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = nk_window_find(ctx, name);
    _ = &win;
    if (!(win != null)) return;
    win.*.bounds.w = size.x;
    win.*.bounds.h = size.y;
}
pub fn nk_window_set_focus(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21177))), "void nk_window_set_focus(struct nk_context *, const char *)");
            };
        };
    };
    if (!(ctx != null)) return;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), title_len, @as(nk_hash, @bitCast(NK_WINDOW_TITLE)));
    win = nk_find_window(ctx, title_hash, name);
    if ((win != null) and (ctx.*.end != win)) {
        nk_remove_window(ctx, win);
        nk_insert_window(ctx, win, @as(c_uint, @bitCast(NK_INSERT_BACK)));
    }
    ctx.*.active = win;
}
pub fn nk_window_set_scroll(arg_ctx: [*c]struct_nk_context, arg_offset_x: nk_uint, arg_offset_y: nk_uint) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var offset_x = arg_offset_x;
    _ = &offset_x;
    var offset_y = arg_offset_y;
    _ = &offset_y;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21111))), "void nk_window_set_scroll(struct nk_context *, nk_uint, nk_uint)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21112))), "void nk_window_set_scroll(struct nk_context *, nk_uint, nk_uint)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    win = ctx.*.current;
    win.*.scrollbar.x = offset_x;
    win.*.scrollbar.y = offset_y;
}
pub fn nk_window_close(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21069))), "void nk_window_close(struct nk_context *, const char *)");
            };
        };
    };
    if (!(ctx != null)) return;
    win = nk_window_find(ctx, name);
    if (!(win != null)) return;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((ctx.*.current != win) and (@intFromPtr("You cannot close a currently active window") != 0)) {} else {
                __assert_fail("ctx->current != win && \"You cannot close a currently active window\"", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21073))), "void nk_window_close(struct nk_context *, const char *)");
            };
        };
    };
    if (ctx.*.current == win) return;
    win.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN));
    win.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_CLOSED));
}
pub fn nk_window_collapse(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_c: enum_nk_collapse_states) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var c = arg_c;
    _ = &c;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21126))), "void nk_window_collapse(struct nk_context *, const char *, enum nk_collapse_states)");
            };
        };
    };
    if (!(ctx != null)) return;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), title_len, @as(nk_hash, @bitCast(NK_WINDOW_TITLE)));
    win = nk_find_window(ctx, title_hash, name);
    if (!(win != null)) return;
    if (c == @as(c_uint, @bitCast(NK_MINIMIZED))) {
        win.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED));
    } else {
        win.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED));
    }
}
pub fn nk_window_collapse_if(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_c: enum_nk_collapse_states, arg_cond: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var c = arg_c;
    _ = &c;
    var cond = arg_cond;
    _ = &cond;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21141))), "void nk_window_collapse_if(struct nk_context *, const char *, enum nk_collapse_states, int)");
            };
        };
    };
    if (!(ctx != null) or !(cond != 0)) return;
    nk_window_collapse(ctx, name, c);
}
pub fn nk_window_show(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_s: enum_nk_show_states) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var s = arg_s;
    _ = &s;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21151))), "void nk_window_show(struct nk_context *, const char *, enum nk_show_states)");
            };
        };
    };
    if (!(ctx != null)) return;
    title_len = nk_strlen(name);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), title_len, @as(nk_hash, @bitCast(NK_WINDOW_TITLE)));
    win = nk_find_window(ctx, title_hash, name);
    if (!(win != null)) return;
    if (s == @as(c_uint, @bitCast(NK_HIDDEN))) {
        win.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN));
    } else {
        win.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_HIDDEN));
    }
}
pub fn nk_window_show_if(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_s: enum_nk_show_states, arg_cond: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var s = arg_s;
    _ = &s;
    var cond = arg_cond;
    _ = &cond;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21166))), "void nk_window_show_if(struct nk_context *, const char *, enum nk_show_states, int)");
            };
        };
    };
    if (!(ctx != null) or !(cond != 0)) return;
    nk_window_show(ctx, name, s);
}
pub const NK_WIDGET_INVALID: c_int = 0;
pub const NK_WIDGET_VALID: c_int = 1;
pub const NK_WIDGET_ROM: c_int = 2;
pub const NK_WIDGET_DISABLED: c_int = 3;
pub const enum_nk_widget_layout_states = c_uint;
pub fn nk_rule_horizontal(arg_ctx: [*c]struct_nk_context, arg_color: struct_nk_color, arg_rounding: nk_bool) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var color = arg_color;
    _ = &color;
    var rounding = arg_rounding;
    _ = &rounding;
    var space: struct_nk_rect = undefined;
    _ = &space;
    var state: enum_nk_widget_layout_states = nk_widget(&space, ctx);
    _ = &state;
    var canvas: [*c]struct_nk_command_buffer = nk_window_get_canvas(ctx);
    _ = &canvas;
    if (!(state != 0)) return;
    nk_fill_rect(canvas, space, if ((rounding != 0) and (space.h > 1.5)) space.h / 2.0 else @as(f32, @floatFromInt(@as(c_int, 0))), color);
}
pub const NK_WIDGET_ALIGN_LEFT: c_int = 1;
pub const NK_WIDGET_ALIGN_CENTERED: c_int = 2;
pub const NK_WIDGET_ALIGN_RIGHT: c_int = 4;
pub const NK_WIDGET_ALIGN_TOP: c_int = 8;
pub const NK_WIDGET_ALIGN_MIDDLE: c_int = 16;
pub const NK_WIDGET_ALIGN_BOTTOM: c_int = 32;
pub const enum_nk_widget_align = c_uint;
pub const NK_WIDGET_LEFT: c_int = 17;
pub const NK_WIDGET_CENTERED: c_int = 18;
pub const NK_WIDGET_RIGHT: c_int = 20;
pub const enum_nk_widget_alignment = c_uint;
pub fn nk_layout_set_min_row_height(arg_ctx: [*c]struct_nk_context, arg_height: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var height = arg_height;
    _ = &height;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22002))), "void nk_layout_set_min_row_height(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22003))), "void nk_layout_set_min_row_height(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22004))), "void nk_layout_set_min_row_height(struct nk_context *, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    layout.*.row.min_height = height;
}
pub fn nk_layout_reset_min_row_height(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22018))), "void nk_layout_reset_min_row_height(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22019))), "void nk_layout_reset_min_row_height(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22020))), "void nk_layout_reset_min_row_height(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    layout.*.row.min_height = ctx.*.style.font.*.height;
    layout.*.row.min_height += ctx.*.style.text.padding.y * @as(f32, @floatFromInt(@as(c_int, 2)));
    layout.*.row.min_height += ctx.*.style.window.min_row_height_padding * @as(f32, @floatFromInt(@as(c_int, 2)));
}
pub fn nk_layout_widget_bounds(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_rect {
    var ctx = arg_ctx;
    _ = &ctx;
    var ret: struct_nk_rect = undefined;
    _ = &ret;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22478))), "struct nk_rect nk_layout_widget_bounds(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22479))), "struct nk_rect nk_layout_widget_bounds(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22480))), "struct nk_rect nk_layout_widget_bounds(const struct nk_context *)");
            };
        };
    };
    win = ctx.*.current;
    layout = win.*.layout;
    ret.x = layout.*.at_x;
    ret.y = layout.*.at_y;
    ret.w = layout.*.bounds.w - (if ((layout.*.at_x - layout.*.bounds.x) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else layout.*.at_x - layout.*.bounds.x);
    ret.h = layout.*.row.height;
    return ret;
}
pub fn nk_layout_ratio_from_pixel(arg_ctx: [*c]const struct_nk_context, arg_pixel_width: f32) callconv(.c) f32 {
    var ctx = arg_ctx;
    _ = &ctx;
    var pixel_width = arg_pixel_width;
    _ = &pixel_width;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22127))), "float nk_layout_ratio_from_pixel(const struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (pixel_width != 0) {} else {
                __assert_fail("pixel_width", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22128))), "float nk_layout_ratio_from_pixel(const struct nk_context *, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    return if ((if ((pixel_width / win.*.bounds.x) < 1.0) pixel_width / win.*.bounds.x else 1.0) < 0.0) 0.0 else if ((pixel_width / win.*.bounds.x) < 1.0) pixel_width / win.*.bounds.x else 1.0;
}
pub fn nk_layout_row_dynamic(arg_ctx: [*c]struct_nk_context, arg_height: f32, arg_cols: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var height = arg_height;
    _ = &height;
    var cols = arg_cols;
    _ = &cols;
    nk_row_layout(ctx, @as(c_uint, @bitCast(NK_DYNAMIC)), height, cols, @as(c_int, 0));
}
pub fn nk_layout_row_static(arg_ctx: [*c]struct_nk_context, arg_height: f32, arg_item_width: c_int, arg_cols: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var height = arg_height;
    _ = &height;
    var item_width = arg_item_width;
    _ = &item_width;
    var cols = arg_cols;
    _ = &cols;
    nk_row_layout(ctx, @as(c_uint, @bitCast(NK_STATIC)), height, cols, item_width);
}
pub fn nk_layout_row_begin(arg_ctx: [*c]struct_nk_context, arg_fmt: enum_nk_layout_format, arg_row_height: f32, arg_cols: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var fmt = arg_fmt;
    _ = &fmt;
    var row_height = arg_row_height;
    _ = &row_height;
    var cols = arg_cols;
    _ = &cols;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22150))), "void nk_layout_row_begin(struct nk_context *, enum nk_layout_format, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22151))), "void nk_layout_row_begin(struct nk_context *, enum nk_layout_format, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22152))), "void nk_layout_row_begin(struct nk_context *, enum nk_layout_format, float, int)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    nk_panel_layout(ctx, win, row_height, cols);
    if (fmt == @as(c_uint, @bitCast(NK_DYNAMIC))) {
        layout.*.row.type = @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC_ROW));
    } else {
        layout.*.row.type = @as(c_uint, @bitCast(NK_LAYOUT_STATIC_ROW));
    }
    layout.*.row.ratio = null;
    layout.*.row.filled = 0;
    layout.*.row.item_width = 0;
    layout.*.row.item_offset = 0;
    layout.*.row.columns = cols;
}
pub fn nk_layout_row_push(arg_ctx: [*c]struct_nk_context, arg_ratio_or_width: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var ratio_or_width = arg_ratio_or_width;
    _ = &ratio_or_width;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22175))), "void nk_layout_row_push(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22176))), "void nk_layout_row_push(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22177))), "void nk_layout_row_push(struct nk_context *, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((layout.*.row.type == @as(c_uint, @bitCast(NK_LAYOUT_STATIC_ROW))) or (layout.*.row.type == @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC_ROW)))) {} else {
                __assert_fail("layout->row.type == NK_LAYOUT_STATIC_ROW || layout->row.type == NK_LAYOUT_DYNAMIC_ROW", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22183))), "void nk_layout_row_push(struct nk_context *, float)");
            };
        };
    };
    if ((layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_STATIC_ROW))) and (layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC_ROW)))) return;
    if (layout.*.row.type == @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC_ROW))) {
        var ratio: f32 = ratio_or_width;
        _ = &ratio;
        if ((ratio + layout.*.row.filled) > 1.0) return;
        if (ratio > 0.0) {
            layout.*.row.item_width = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < ratio) 1.0 else ratio)) if (1.0 < ratio) 1.0 else ratio else @as(f32, @floatFromInt(@as(c_int, 0)));
        } else {
            layout.*.row.item_width = 1.0 - layout.*.row.filled;
        }
    } else {
        layout.*.row.item_width = ratio_or_width;
    }
}
pub fn nk_layout_row_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22201))), "void nk_layout_row_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22202))), "void nk_layout_row_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22203))), "void nk_layout_row_end(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((layout.*.row.type == @as(c_uint, @bitCast(NK_LAYOUT_STATIC_ROW))) or (layout.*.row.type == @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC_ROW)))) {} else {
                __assert_fail("layout->row.type == NK_LAYOUT_STATIC_ROW || layout->row.type == NK_LAYOUT_DYNAMIC_ROW", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22209))), "void nk_layout_row_end(struct nk_context *)");
            };
        };
    };
    if ((layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_STATIC_ROW))) and (layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC_ROW)))) return;
    layout.*.row.item_width = 0;
    layout.*.row.item_offset = 0;
}
pub fn nk_layout_row(arg_ctx: [*c]struct_nk_context, arg_fmt: enum_nk_layout_format, arg_height: f32, arg_cols: c_int, arg_ratio: [*c]const f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var fmt = arg_fmt;
    _ = &fmt;
    var height = arg_height;
    _ = &height;
    var cols = arg_cols;
    _ = &cols;
    var ratio = arg_ratio;
    _ = &ratio;
    var i: c_int = undefined;
    _ = &i;
    var n_undef: c_int = 0;
    _ = &n_undef;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22224))), "void nk_layout_row(struct nk_context *, enum nk_layout_format, float, int, const float *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22225))), "void nk_layout_row(struct nk_context *, enum nk_layout_format, float, int, const float *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22226))), "void nk_layout_row(struct nk_context *, enum nk_layout_format, float, int, const float *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    nk_panel_layout(ctx, win, height, cols);
    if (fmt == @as(c_uint, @bitCast(NK_DYNAMIC))) {
        var r: f32 = 0;
        _ = &r;
        layout.*.row.ratio = ratio;
        {
            i = 0;
            while (i < cols) : (i += 1) {
                if ((blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk ratio + @as(usize, @intCast(tmp)) else break :blk ratio - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* < 0.0) {
                    n_undef += 1;
                } else {
                    r += (blk: {
                        const tmp = i;
                        if (tmp >= 0) break :blk ratio + @as(usize, @intCast(tmp)) else break :blk ratio - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*;
                }
            }
        }
        r = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < (1.0 - r)) 1.0 else 1.0 - r)) if (1.0 < (1.0 - r)) 1.0 else 1.0 - r else @as(f32, @floatFromInt(@as(c_int, 0)));
        layout.*.row.type = @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC));
        layout.*.row.item_width = if ((r > @as(f32, @floatFromInt(@as(c_int, 0)))) and (n_undef > @as(c_int, 0))) r / @as(f32, @floatFromInt(n_undef)) else @as(f32, @floatFromInt(@as(c_int, 0)));
    } else {
        layout.*.row.ratio = ratio;
        layout.*.row.type = @as(c_uint, @bitCast(NK_LAYOUT_STATIC));
        layout.*.row.item_width = 0;
        layout.*.row.item_offset = 0;
    }
    layout.*.row.item_offset = 0;
    layout.*.row.filled = 0;
}
pub fn nk_layout_row_template_begin(arg_ctx: [*c]struct_nk_context, arg_height: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var height = arg_height;
    _ = &height;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22260))), "void nk_layout_row_template_begin(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22261))), "void nk_layout_row_template_begin(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22262))), "void nk_layout_row_template_begin(struct nk_context *, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    nk_panel_layout(ctx, win, height, @as(c_int, 1));
    layout.*.row.type = @as(c_uint, @bitCast(NK_LAYOUT_TEMPLATE));
    layout.*.row.columns = 0;
    layout.*.row.ratio = null;
    layout.*.row.item_width = 0;
    layout.*.row.item_height = 0;
    layout.*.row.item_offset = 0;
    layout.*.row.filled = 0;
    layout.*.row.item.x = 0;
    layout.*.row.item.y = 0;
    layout.*.row.item.w = 0;
    layout.*.row.item.h = 0;
}
pub fn nk_layout_row_template_push_dynamic(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22287))), "void nk_layout_row_template_push_dynamic(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22288))), "void nk_layout_row_template_push_dynamic(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22289))), "void nk_layout_row_template_push_dynamic(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (layout.*.row.type == @as(c_uint, @bitCast(NK_LAYOUT_TEMPLATE))) {} else {
                __assert_fail("layout->row.type == NK_LAYOUT_TEMPLATE", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22295))), "void nk_layout_row_template_push_dynamic(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (layout.*.row.columns < @as(c_int, 16)) {} else {
                __assert_fail("layout->row.columns < 16", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22296))), "void nk_layout_row_template_push_dynamic(struct nk_context *)");
            };
        };
    };
    if (layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_TEMPLATE))) return;
    if (layout.*.row.columns >= @as(c_int, 16)) return;
    layout.*.row.templates[@as(c_uint, @intCast(blk: {
        const ref = &layout.*.row.columns;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))] = -1.0;
}
pub fn nk_layout_row_template_push_variable(arg_ctx: [*c]struct_nk_context, arg_min_width: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var min_width = arg_min_width;
    _ = &min_width;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22307))), "void nk_layout_row_template_push_variable(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22308))), "void nk_layout_row_template_push_variable(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22309))), "void nk_layout_row_template_push_variable(struct nk_context *, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (layout.*.row.type == @as(c_uint, @bitCast(NK_LAYOUT_TEMPLATE))) {} else {
                __assert_fail("layout->row.type == NK_LAYOUT_TEMPLATE", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22315))), "void nk_layout_row_template_push_variable(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (layout.*.row.columns < @as(c_int, 16)) {} else {
                __assert_fail("layout->row.columns < 16", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22316))), "void nk_layout_row_template_push_variable(struct nk_context *, float)");
            };
        };
    };
    if (layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_TEMPLATE))) return;
    if (layout.*.row.columns >= @as(c_int, 16)) return;
    layout.*.row.templates[@as(c_uint, @intCast(blk: {
        const ref = &layout.*.row.columns;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))] = -min_width;
}
pub fn nk_layout_row_template_push_static(arg_ctx: [*c]struct_nk_context, arg_width: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var width = arg_width;
    _ = &width;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22327))), "void nk_layout_row_template_push_static(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22328))), "void nk_layout_row_template_push_static(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22329))), "void nk_layout_row_template_push_static(struct nk_context *, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (layout.*.row.type == @as(c_uint, @bitCast(NK_LAYOUT_TEMPLATE))) {} else {
                __assert_fail("layout->row.type == NK_LAYOUT_TEMPLATE", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22335))), "void nk_layout_row_template_push_static(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (layout.*.row.columns < @as(c_int, 16)) {} else {
                __assert_fail("layout->row.columns < 16", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22336))), "void nk_layout_row_template_push_static(struct nk_context *, float)");
            };
        };
    };
    if (layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_TEMPLATE))) return;
    if (layout.*.row.columns >= @as(c_int, 16)) return;
    layout.*.row.templates[@as(c_uint, @intCast(blk: {
        const ref = &layout.*.row.columns;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))] = width;
}
pub fn nk_layout_row_template_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var i: c_int = 0;
    _ = &i;
    var variable_count: c_int = 0;
    _ = &variable_count;
    var min_variable_count: c_int = 0;
    _ = &min_variable_count;
    var min_fixed_width: f32 = 0.0;
    _ = &min_fixed_width;
    var total_fixed_width: f32 = 0.0;
    _ = &total_fixed_width;
    var max_variable_width: f32 = 0.0;
    _ = &max_variable_width;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22354))), "void nk_layout_row_template_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22355))), "void nk_layout_row_template_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22356))), "void nk_layout_row_template_end(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (layout.*.row.type == @as(c_uint, @bitCast(NK_LAYOUT_TEMPLATE))) {} else {
                __assert_fail("layout->row.type == NK_LAYOUT_TEMPLATE", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22362))), "void nk_layout_row_template_end(struct nk_context *)");
            };
        };
    };
    if (layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_TEMPLATE))) return;
    {
        i = 0;
        while (i < layout.*.row.columns) : (i += 1) {
            var width: f32 = layout.*.row.templates[@as(c_uint, @intCast(i))];
            _ = &width;
            if (width >= 0.0) {
                total_fixed_width += width;
                min_fixed_width += width;
            } else if (width < -1.0) {
                width = -width;
                total_fixed_width += width;
                max_variable_width = if (max_variable_width < width) width else max_variable_width;
                variable_count += 1;
            } else {
                min_variable_count += 1;
                variable_count += 1;
            }
        }
    }
    if (variable_count != 0) {
        var space: f32 = nk_layout_row_calculate_usable_space(&ctx.*.style, layout.*.type, layout.*.bounds.w, layout.*.row.columns);
        _ = &space;
        var var_width: f32 = (if ((space - min_fixed_width) < 0.0) 0.0 else space - min_fixed_width) / @as(f32, @floatFromInt(variable_count));
        _ = &var_width;
        var enough_space: c_int = @intFromBool(var_width >= max_variable_width);
        _ = &enough_space;
        if (!(enough_space != 0)) {
            var_width = (if ((space - total_fixed_width) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else space - total_fixed_width) / @as(f32, @floatFromInt(min_variable_count));
        }
        {
            i = 0;
            while (i < layout.*.row.columns) : (i += 1) {
                var width: [*c]f32 = &layout.*.row.templates[@as(c_uint, @intCast(i))];
                _ = &width;
                width.* = if (width.* >= 0.0) width.* else if ((width.* < -1.0) and !(enough_space != 0)) -width.* else var_width;
            }
        }
    }
}
pub fn nk_layout_space_begin(arg_ctx: [*c]struct_nk_context, arg_fmt: enum_nk_layout_format, arg_height: f32, arg_widget_count: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var fmt = arg_fmt;
    _ = &fmt;
    var height = arg_height;
    _ = &height;
    var widget_count = arg_widget_count;
    _ = &widget_count;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22399))), "void nk_layout_space_begin(struct nk_context *, enum nk_layout_format, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22400))), "void nk_layout_space_begin(struct nk_context *, enum nk_layout_format, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22401))), "void nk_layout_space_begin(struct nk_context *, enum nk_layout_format, float, int)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    nk_panel_layout(ctx, win, height, widget_count);
    if (fmt == @as(c_uint, @bitCast(NK_STATIC))) {
        layout.*.row.type = @as(c_uint, @bitCast(NK_LAYOUT_STATIC_FREE));
    } else {
        layout.*.row.type = @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC_FREE));
    }
    layout.*.row.ratio = null;
    layout.*.row.filled = 0;
    layout.*.row.item_width = 0;
    layout.*.row.item_offset = 0;
}
pub fn nk_layout_space_push(arg_ctx: [*c]struct_nk_context, arg_rect: struct_nk_rect) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var rect = arg_rect;
    _ = &rect;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22442))), "void nk_layout_space_push(struct nk_context *, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22443))), "void nk_layout_space_push(struct nk_context *, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22444))), "void nk_layout_space_push(struct nk_context *, struct nk_rect)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    layout.*.row.item = rect;
}
pub fn nk_layout_space_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22423))), "void nk_layout_space_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22424))), "void nk_layout_space_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22425))), "void nk_layout_space_end(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    layout.*.row.item_width = 0;
    layout.*.row.item_height = 0;
    layout.*.row.item_offset = 0;
    nk_zero(@as(?*anyopaque, @ptrCast(&layout.*.row.item)), @sizeOf(struct_nk_rect));
}
pub fn nk_layout_space_bounds(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_rect {
    var ctx = arg_ctx;
    _ = &ctx;
    var ret: struct_nk_rect = undefined;
    _ = &ret;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22459))), "struct nk_rect nk_layout_space_bounds(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22460))), "struct nk_rect nk_layout_space_bounds(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22461))), "struct nk_rect nk_layout_space_bounds(const struct nk_context *)");
            };
        };
    };
    win = ctx.*.current;
    layout = win.*.layout;
    ret.x = layout.*.clip.x;
    ret.y = layout.*.clip.y;
    ret.w = layout.*.clip.w;
    ret.h = layout.*.row.height;
    return ret;
}
pub fn nk_layout_space_to_screen(arg_ctx: [*c]const struct_nk_context, arg_ret: struct_nk_vec2) callconv(.c) struct_nk_vec2 {
    var ctx = arg_ctx;
    _ = &ctx;
    var ret = arg_ret;
    _ = &ret;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22496))), "struct nk_vec2 nk_layout_space_to_screen(const struct nk_context *, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22497))), "struct nk_vec2 nk_layout_space_to_screen(const struct nk_context *, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22498))), "struct nk_vec2 nk_layout_space_to_screen(const struct nk_context *, struct nk_vec2)");
            };
        };
    };
    win = ctx.*.current;
    layout = win.*.layout;
    ret.x += layout.*.at_x - @as(f32, @floatFromInt(layout.*.offset_x.*));
    ret.y += layout.*.at_y - @as(f32, @floatFromInt(layout.*.offset_y.*));
    return ret;
}
pub fn nk_layout_space_to_local(arg_ctx: [*c]const struct_nk_context, arg_ret: struct_nk_vec2) callconv(.c) struct_nk_vec2 {
    var ctx = arg_ctx;
    _ = &ctx;
    var ret = arg_ret;
    _ = &ret;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22512))), "struct nk_vec2 nk_layout_space_to_local(const struct nk_context *, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22513))), "struct nk_vec2 nk_layout_space_to_local(const struct nk_context *, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22514))), "struct nk_vec2 nk_layout_space_to_local(const struct nk_context *, struct nk_vec2)");
            };
        };
    };
    win = ctx.*.current;
    layout = win.*.layout;
    ret.x += -layout.*.at_x + @as(f32, @floatFromInt(layout.*.offset_x.*));
    ret.y += -layout.*.at_y + @as(f32, @floatFromInt(layout.*.offset_y.*));
    return ret;
}
pub fn nk_layout_space_rect_to_screen(arg_ctx: [*c]const struct_nk_context, arg_ret: struct_nk_rect) callconv(.c) struct_nk_rect {
    var ctx = arg_ctx;
    _ = &ctx;
    var ret = arg_ret;
    _ = &ret;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22528))), "struct nk_rect nk_layout_space_rect_to_screen(const struct nk_context *, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22529))), "struct nk_rect nk_layout_space_rect_to_screen(const struct nk_context *, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22530))), "struct nk_rect nk_layout_space_rect_to_screen(const struct nk_context *, struct nk_rect)");
            };
        };
    };
    win = ctx.*.current;
    layout = win.*.layout;
    ret.x += layout.*.at_x - @as(f32, @floatFromInt(layout.*.offset_x.*));
    ret.y += layout.*.at_y - @as(f32, @floatFromInt(layout.*.offset_y.*));
    return ret;
}
pub fn nk_layout_space_rect_to_local(arg_ctx: [*c]const struct_nk_context, arg_ret: struct_nk_rect) callconv(.c) struct_nk_rect {
    var ctx = arg_ctx;
    _ = &ctx;
    var ret = arg_ret;
    _ = &ret;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22544))), "struct nk_rect nk_layout_space_rect_to_local(const struct nk_context *, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22545))), "struct nk_rect nk_layout_space_rect_to_local(const struct nk_context *, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22546))), "struct nk_rect nk_layout_space_rect_to_local(const struct nk_context *, struct nk_rect)");
            };
        };
    };
    win = ctx.*.current;
    layout = win.*.layout;
    ret.x += -layout.*.at_x + @as(f32, @floatFromInt(layout.*.offset_x.*));
    ret.y += -layout.*.at_y + @as(f32, @floatFromInt(layout.*.offset_y.*));
    return ret;
}
pub fn nk_spacer(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var dummy_rect: struct_nk_rect = struct_nk_rect{
        .x = @as(f32, @floatFromInt(@as(c_int, 0))),
        .y = @as(f32, @floatFromInt(@as(c_int, 0))),
        .w = @as(f32, @floatFromInt(@as(c_int, 0))),
        .h = @as(f32, @floatFromInt(@as(c_int, 0))),
    };
    _ = &dummy_rect;
    nk_panel_alloc_space(&dummy_rect, ctx);
}
pub fn nk_group_begin(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_flags: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var flags = arg_flags;
    _ = &flags;
    return nk_group_begin_titled(ctx, title, title, flags);
}
pub fn nk_group_begin_titled(arg_ctx: [*c]struct_nk_context, arg_id: [*c]const u8, arg_title: [*c]const u8, arg_flags: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var id = arg_id;
    _ = &id;
    var title = arg_title;
    _ = &title;
    var flags = arg_flags;
    _ = &flags;
    var id_len: c_int = undefined;
    _ = &id_len;
    var id_hash: nk_hash = undefined;
    _ = &id_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var x_offset: [*c]nk_uint = undefined;
    _ = &x_offset;
    var y_offset: [*c]nk_uint = undefined;
    _ = &y_offset;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23244))), "nk_bool nk_group_begin_titled(struct nk_context *, const char *, const char *, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (id != null) {} else {
                __assert_fail("id", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23245))), "nk_bool nk_group_begin_titled(struct nk_context *, const char *, const char *, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23246))), "nk_bool nk_group_begin_titled(struct nk_context *, const char *, const char *, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23247))), "nk_bool nk_group_begin_titled(struct nk_context *, const char *, const char *, nk_flags)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(id != null)) return 0;
    win = ctx.*.current;
    id_len = nk_strlen(id);
    id_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(id)), id_len, @as(nk_hash, @bitCast(NK_PANEL_GROUP)));
    x_offset = nk_find_value(win, id_hash);
    if (!(x_offset != null)) {
        x_offset = nk_add_value(ctx, win, id_hash, @as(nk_uint, @bitCast(@as(c_int, 0))));
        y_offset = nk_add_value(ctx, win, id_hash +% @as(nk_hash, @bitCast(@as(c_int, 1))), @as(nk_uint, @bitCast(@as(c_int, 0))));
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (x_offset != null) {} else {
                    __assert_fail("x_offset", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23260))), "nk_bool nk_group_begin_titled(struct nk_context *, const char *, const char *, nk_flags)");
                };
            };
        };
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (y_offset != null) {} else {
                    __assert_fail("y_offset", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23261))), "nk_bool nk_group_begin_titled(struct nk_context *, const char *, const char *, nk_flags)");
                };
            };
        };
        if (!(x_offset != null) or !(y_offset != null)) return 0;
        x_offset.* = blk: {
            const tmp = @as(nk_uint, @bitCast(@as(c_int, 0)));
            y_offset.* = tmp;
            break :blk tmp;
        };
    } else {
        y_offset = nk_find_value(win, id_hash +% @as(nk_hash, @bitCast(@as(c_int, 1))));
    }
    return nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
}
pub fn nk_group_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    nk_group_scrolled_end(ctx);
}
pub fn nk_group_scrolled_offset_begin(arg_ctx: [*c]struct_nk_context, arg_x_offset: [*c]nk_uint, arg_y_offset: [*c]nk_uint, arg_title: [*c]const u8, arg_flags: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var x_offset = arg_x_offset;
    _ = &x_offset;
    var y_offset = arg_y_offset;
    _ = &y_offset;
    var title = arg_title;
    _ = &title;
    var flags = arg_flags;
    _ = &flags;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var panel: struct_nk_window = undefined;
    _ = &panel;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    win = ctx.*.current;
    nk_panel_alloc_space(&bounds, ctx);
    {
        var c: [*c]const struct_nk_rect = &win.*.layout.*.clip;
        _ = &c;
        if (!((((bounds.x < (c.*.x + c.*.w)) and (c.*.x < (bounds.x + bounds.w))) and (bounds.y < (c.*.y + c.*.h))) and (c.*.y < (bounds.y + bounds.h))) and !((flags & @as(nk_flags, @bitCast(NK_WINDOW_MOVABLE))) != 0)) {
            return 0;
        }
    }
    if ((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) {
        flags |= @as(nk_flags, @bitCast(NK_WINDOW_ROM));
    }
    nk_zero(@as(?*anyopaque, @ptrCast(&panel)), @sizeOf(struct_nk_window));
    panel.bounds = bounds;
    panel.flags = flags;
    panel.scrollbar.x = x_offset.*;
    panel.scrollbar.y = y_offset.*;
    panel.buffer = win.*.buffer;
    panel.layout = @as([*c]struct_nk_panel, @ptrCast(@alignCast(nk_create_panel(ctx))));
    ctx.*.current = &panel;
    _ = nk_panel_begin(ctx, if ((flags & @as(nk_flags, @bitCast(NK_WINDOW_TITLE))) != 0) title else null, @as(c_uint, @bitCast(NK_PANEL_GROUP)));
    win.*.buffer = panel.buffer;
    win.*.buffer.clip = panel.layout.*.clip;
    panel.layout.*.offset_x = x_offset;
    panel.layout.*.offset_y = y_offset;
    panel.layout.*.parent = win.*.layout;
    win.*.layout = panel.layout;
    ctx.*.current = win;
    if (((panel.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSED))) != 0) or ((panel.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) {
        var f: nk_flags = panel.layout.*.flags;
        _ = &f;
        nk_group_scrolled_end(ctx);
        if ((f & @as(nk_flags, @bitCast(NK_WINDOW_CLOSED))) != 0) return NK_WINDOW_CLOSED;
        if ((f & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0) return NK_WINDOW_MINIMIZED;
    }
    return 1;
}
pub fn nk_group_scrolled_begin(arg_ctx: [*c]struct_nk_context, arg_scroll: [*c]struct_nk_scroll, arg_title: [*c]const u8, arg_flags: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var scroll = arg_scroll;
    _ = &scroll;
    var title = arg_title;
    _ = &title;
    var flags = arg_flags;
    _ = &flags;
    return nk_group_scrolled_offset_begin(ctx, &scroll.*.x, &scroll.*.y, title, flags);
}
pub fn nk_group_scrolled_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var parent: [*c]struct_nk_panel = undefined;
    _ = &parent;
    var g: [*c]struct_nk_panel = undefined;
    _ = &g;
    var clip: struct_nk_rect = undefined;
    _ = &clip;
    var pan: struct_nk_window = undefined;
    _ = &pan;
    var panel_padding: struct_nk_vec2 = undefined;
    _ = &panel_padding;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23177))), "void nk_group_scrolled_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23178))), "void nk_group_scrolled_end(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23183))), "void nk_group_scrolled_end(struct nk_context *)");
            };
        };
    };
    win = ctx.*.current;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (win.*.layout != null) {} else {
                __assert_fail("win->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23185))), "void nk_group_scrolled_end(struct nk_context *)");
            };
        };
    };
    g = win.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (g.*.parent != null) {} else {
                __assert_fail("g->parent", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23187))), "void nk_group_scrolled_end(struct nk_context *)");
            };
        };
    };
    parent = g.*.parent;
    nk_zero(@as(?*anyopaque, @ptrCast(&pan)), @sizeOf(struct_nk_window));
    panel_padding = nk_panel_get_padding(&ctx.*.style, @as(c_uint, @bitCast(NK_PANEL_GROUP)));
    pan.bounds.y = g.*.bounds.y - (g.*.header_height + g.*.menu.h);
    pan.bounds.x = g.*.bounds.x - panel_padding.x;
    pan.bounds.w = g.*.bounds.w + (@as(f32, @floatFromInt(@as(c_int, 2))) * panel_padding.x);
    pan.bounds.h = (g.*.bounds.h + g.*.header_height) + g.*.menu.h;
    if ((g.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_BORDER))) != 0) {
        pan.bounds.x -= g.*.border;
        pan.bounds.y -= g.*.border;
        pan.bounds.w += @as(f32, @floatFromInt(@as(c_int, 2))) * g.*.border;
        pan.bounds.h += @as(f32, @floatFromInt(@as(c_int, 2))) * g.*.border;
    }
    if (!((g.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_NO_SCROLLBAR))) != 0)) {
        pan.bounds.w += ctx.*.style.window.scrollbar_size.x;
        pan.bounds.h += ctx.*.style.window.scrollbar_size.y;
    }
    pan.scrollbar.x = g.*.offset_x.*;
    pan.scrollbar.y = g.*.offset_y.*;
    pan.flags = g.*.flags;
    pan.buffer = win.*.buffer;
    pan.layout = g;
    pan.parent = win;
    ctx.*.current = &pan;
    nk_unify(&clip, &parent.*.clip, pan.bounds.x, pan.bounds.y, pan.bounds.x + pan.bounds.w, (pan.bounds.y + pan.bounds.h) + panel_padding.x);
    nk_push_scissor(&pan.buffer, clip);
    nk_end(ctx);
    win.*.buffer = pan.buffer;
    nk_push_scissor(&win.*.buffer, parent.*.clip);
    ctx.*.current = win;
    win.*.layout = parent;
    g.*.bounds = pan.bounds;
    return;
}
pub fn nk_group_get_scroll(arg_ctx: [*c]struct_nk_context, arg_id: [*c]const u8, arg_x_offset: [*c]nk_uint, arg_y_offset: [*c]nk_uint) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var id = arg_id;
    _ = &id;
    var x_offset = arg_x_offset;
    _ = &x_offset;
    var y_offset = arg_y_offset;
    _ = &y_offset;
    var id_len: c_int = undefined;
    _ = &id_len;
    var id_hash: nk_hash = undefined;
    _ = &id_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var x_offset_ptr: [*c]nk_uint = undefined;
    _ = &x_offset_ptr;
    var y_offset_ptr: [*c]nk_uint = undefined;
    _ = &y_offset_ptr;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23286))), "void nk_group_get_scroll(struct nk_context *, const char *, nk_uint *, nk_uint *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (id != null) {} else {
                __assert_fail("id", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23287))), "void nk_group_get_scroll(struct nk_context *, const char *, nk_uint *, nk_uint *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23288))), "void nk_group_get_scroll(struct nk_context *, const char *, nk_uint *, nk_uint *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23289))), "void nk_group_get_scroll(struct nk_context *, const char *, nk_uint *, nk_uint *)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(id != null)) return;
    win = ctx.*.current;
    id_len = nk_strlen(id);
    id_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(id)), id_len, @as(nk_hash, @bitCast(NK_PANEL_GROUP)));
    x_offset_ptr = nk_find_value(win, id_hash);
    if (!(x_offset_ptr != null)) {
        x_offset_ptr = nk_add_value(ctx, win, id_hash, @as(nk_uint, @bitCast(@as(c_int, 0))));
        y_offset_ptr = nk_add_value(ctx, win, id_hash +% @as(nk_hash, @bitCast(@as(c_int, 1))), @as(nk_uint, @bitCast(@as(c_int, 0))));
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (x_offset_ptr != null) {} else {
                    __assert_fail("x_offset_ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23302))), "void nk_group_get_scroll(struct nk_context *, const char *, nk_uint *, nk_uint *)");
                };
            };
        };
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (y_offset_ptr != null) {} else {
                    __assert_fail("y_offset_ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23303))), "void nk_group_get_scroll(struct nk_context *, const char *, nk_uint *, nk_uint *)");
                };
            };
        };
        if (!(x_offset_ptr != null) or !(y_offset_ptr != null)) return;
        x_offset_ptr.* = blk: {
            const tmp = @as(nk_uint, @bitCast(@as(c_int, 0)));
            y_offset_ptr.* = tmp;
            break :blk tmp;
        };
    } else {
        y_offset_ptr = nk_find_value(win, id_hash +% @as(nk_hash, @bitCast(@as(c_int, 1))));
    }
    if (x_offset != null) {
        x_offset.* = x_offset_ptr.*;
    }
    if (y_offset != null) {
        y_offset.* = y_offset_ptr.*;
    }
}
pub fn nk_group_set_scroll(arg_ctx: [*c]struct_nk_context, arg_id: [*c]const u8, arg_x_offset: nk_uint, arg_y_offset: nk_uint) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var id = arg_id;
    _ = &id;
    var x_offset = arg_x_offset;
    _ = &x_offset;
    var y_offset = arg_y_offset;
    _ = &y_offset;
    var id_len: c_int = undefined;
    _ = &id_len;
    var id_hash: nk_hash = undefined;
    _ = &id_hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var x_offset_ptr: [*c]nk_uint = undefined;
    _ = &x_offset_ptr;
    var y_offset_ptr: [*c]nk_uint = undefined;
    _ = &y_offset_ptr;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23321))), "void nk_group_set_scroll(struct nk_context *, const char *, nk_uint, nk_uint)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (id != null) {} else {
                __assert_fail("id", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23322))), "void nk_group_set_scroll(struct nk_context *, const char *, nk_uint, nk_uint)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23323))), "void nk_group_set_scroll(struct nk_context *, const char *, nk_uint, nk_uint)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23324))), "void nk_group_set_scroll(struct nk_context *, const char *, nk_uint, nk_uint)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(id != null)) return;
    win = ctx.*.current;
    id_len = nk_strlen(id);
    id_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(id)), id_len, @as(nk_hash, @bitCast(NK_PANEL_GROUP)));
    x_offset_ptr = nk_find_value(win, id_hash);
    if (!(x_offset_ptr != null)) {
        x_offset_ptr = nk_add_value(ctx, win, id_hash, @as(nk_uint, @bitCast(@as(c_int, 0))));
        y_offset_ptr = nk_add_value(ctx, win, id_hash +% @as(nk_hash, @bitCast(@as(c_int, 1))), @as(nk_uint, @bitCast(@as(c_int, 0))));
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (x_offset_ptr != null) {} else {
                    __assert_fail("x_offset_ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23337))), "void nk_group_set_scroll(struct nk_context *, const char *, nk_uint, nk_uint)");
                };
            };
        };
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (y_offset_ptr != null) {} else {
                    __assert_fail("y_offset_ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23338))), "void nk_group_set_scroll(struct nk_context *, const char *, nk_uint, nk_uint)");
                };
            };
        };
        if (!(x_offset_ptr != null) or !(y_offset_ptr != null)) return;
        x_offset_ptr.* = blk: {
            const tmp = @as(nk_uint, @bitCast(@as(c_int, 0)));
            y_offset_ptr.* = tmp;
            break :blk tmp;
        };
    } else {
        y_offset_ptr = nk_find_value(win, id_hash +% @as(nk_hash, @bitCast(@as(c_int, 1))));
    }
    x_offset_ptr.* = x_offset;
    y_offset_ptr.* = y_offset;
}
pub fn nk_tree_push_hashed(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_title: [*c]const u8, arg_initial_state: enum_nk_collapse_states, arg_hash: [*c]const u8, arg_len: c_int, arg_line: c_int) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var title = arg_title;
    _ = &title;
    var initial_state = arg_initial_state;
    _ = &initial_state;
    var hash = arg_hash;
    _ = &hash;
    var len = arg_len;
    _ = &len;
    var line = arg_line;
    _ = &line;
    return nk_tree_base(ctx, @"type", null, title, initial_state, hash, len, line);
}
pub fn nk_tree_image_push_hashed(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_img: struct_nk_image, arg_title: [*c]const u8, arg_initial_state: enum_nk_collapse_states, arg_hash: [*c]const u8, arg_len: c_int, arg_seed: c_int) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var img = arg_img;
    _ = &img;
    var title = arg_title;
    _ = &title;
    var initial_state = arg_initial_state;
    _ = &initial_state;
    var hash = arg_hash;
    _ = &hash;
    var len = arg_len;
    _ = &len;
    var seed = arg_seed;
    _ = &seed;
    return nk_tree_base(ctx, @"type", &img, title, initial_state, hash, len, seed);
}
pub fn nk_tree_pop(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    nk_tree_state_pop(ctx);
}
pub fn nk_tree_state_push(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_title: [*c]const u8, arg_state: [*c]enum_nk_collapse_states) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var title = arg_title;
    _ = &title;
    var state = arg_state;
    _ = &state;
    return nk_tree_state_base(ctx, @"type", null, title, state);
}
pub fn nk_tree_state_image_push(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_img: struct_nk_image, arg_title: [*c]const u8, arg_state: [*c]enum_nk_collapse_states) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var img = arg_img;
    _ = &img;
    var title = arg_title;
    _ = &title;
    var state = arg_state;
    _ = &state;
    return nk_tree_state_base(ctx, @"type", &img, title, state);
}
pub fn nk_tree_state_pop(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = null;
    _ = &win;
    var layout: [*c]struct_nk_panel = null;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22918))), "void nk_tree_state_pop(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22919))), "void nk_tree_state_pop(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22920))), "void nk_tree_state_pop(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    layout.*.at_x -= ctx.*.style.tab.indent + @as(f32, @floatFromInt(layout.*.offset_x.*));
    layout.*.bounds.w += ctx.*.style.tab.indent + ctx.*.style.window.padding.x;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (layout.*.row.tree_depth != 0) {} else {
                __assert_fail("layout->row.tree_depth", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22928))), "void nk_tree_state_pop(struct nk_context *)");
            };
        };
    };
    layout.*.row.tree_depth -= 1;
}
pub fn nk_tree_element_push_hashed(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_title: [*c]const u8, arg_initial_state: enum_nk_collapse_states, arg_selected: [*c]nk_bool, arg_hash: [*c]const u8, arg_len: c_int, arg_seed: c_int) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var title = arg_title;
    _ = &title;
    var initial_state = arg_initial_state;
    _ = &initial_state;
    var selected = arg_selected;
    _ = &selected;
    var hash = arg_hash;
    _ = &hash;
    var len = arg_len;
    _ = &len;
    var seed = arg_seed;
    _ = &seed;
    return nk_tree_element_base(ctx, @"type", null, title, initial_state, selected, hash, len, seed);
}
pub fn nk_tree_element_image_push_hashed(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_img: struct_nk_image, arg_title: [*c]const u8, arg_initial_state: enum_nk_collapse_states, arg_selected: [*c]nk_bool, arg_hash: [*c]const u8, arg_len: c_int, arg_seed: c_int) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var img = arg_img;
    _ = &img;
    var title = arg_title;
    _ = &title;
    var initial_state = arg_initial_state;
    _ = &initial_state;
    var selected = arg_selected;
    _ = &selected;
    var hash = arg_hash;
    _ = &hash;
    var len = arg_len;
    _ = &len;
    var seed = arg_seed;
    _ = &seed;
    return nk_tree_element_base(ctx, @"type", &img, title, initial_state, selected, hash, len, seed);
}
pub fn nk_tree_element_pop(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    nk_tree_state_pop(ctx);
}
pub const struct_nk_list_view = extern struct {
    begin: c_int = @import("std").mem.zeroes(c_int),
    end: c_int = @import("std").mem.zeroes(c_int),
    count: c_int = @import("std").mem.zeroes(c_int),
    total_height: c_int = @import("std").mem.zeroes(c_int),
    ctx: [*c]struct_nk_context = @import("std").mem.zeroes([*c]struct_nk_context),
    scroll_pointer: [*c]nk_uint = @import("std").mem.zeroes([*c]nk_uint),
    scroll_value: nk_uint = @import("std").mem.zeroes(nk_uint),
};
pub fn nk_list_view_begin(arg_ctx: [*c]struct_nk_context, arg_view: [*c]struct_nk_list_view, arg_title: [*c]const u8, arg_flags: nk_flags, arg_row_height: c_int, arg_row_count: c_int) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var view = arg_view;
    _ = &view;
    var title = arg_title;
    _ = &title;
    var flags = arg_flags;
    _ = &flags;
    var row_height = arg_row_height;
    _ = &row_height;
    var row_count = arg_row_count;
    _ = &row_count;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    var x_offset: [*c]nk_uint = undefined;
    _ = &x_offset;
    var y_offset: [*c]nk_uint = undefined;
    _ = &y_offset;
    var result: c_int = undefined;
    _ = &result;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var item_spacing: struct_nk_vec2 = undefined;
    _ = &item_spacing;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23369))), "nk_bool nk_list_view_begin(struct nk_context *, struct nk_list_view *, const char *, nk_flags, int, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (view != null) {} else {
                __assert_fail("view", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23370))), "nk_bool nk_list_view_begin(struct nk_context *, struct nk_list_view *, const char *, nk_flags, int, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (title != null) {} else {
                __assert_fail("title", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23371))), "nk_bool nk_list_view_begin(struct nk_context *, struct nk_list_view *, const char *, nk_flags, int, int)");
            };
        };
    };
    if ((!(ctx != null) or !(view != null)) or !(title != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    item_spacing = style.*.window.spacing;
    row_height += if (@as(c_int, 0) < @as(c_int, @intFromFloat(item_spacing.y))) @as(c_int, @intFromFloat(item_spacing.y)) else @as(c_int, 0);
    title_len = nk_strlen(title);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(title)), title_len, @as(nk_hash, @bitCast(NK_PANEL_GROUP)));
    x_offset = nk_find_value(win, title_hash);
    if (!(x_offset != null)) {
        x_offset = nk_add_value(ctx, win, title_hash, @as(nk_uint, @bitCast(@as(c_int, 0))));
        y_offset = nk_add_value(ctx, win, title_hash +% @as(nk_hash, @bitCast(@as(c_int, 1))), @as(nk_uint, @bitCast(@as(c_int, 0))));
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (x_offset != null) {} else {
                    __assert_fail("x_offset", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23387))), "nk_bool nk_list_view_begin(struct nk_context *, struct nk_list_view *, const char *, nk_flags, int, int)");
                };
            };
        };
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (y_offset != null) {} else {
                    __assert_fail("y_offset", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23388))), "nk_bool nk_list_view_begin(struct nk_context *, struct nk_list_view *, const char *, nk_flags, int, int)");
                };
            };
        };
        if (!(x_offset != null) or !(y_offset != null)) return 0;
        x_offset.* = blk: {
            const tmp = @as(nk_uint, @bitCast(@as(c_int, 0)));
            y_offset.* = tmp;
            break :blk tmp;
        };
    } else {
        y_offset = nk_find_value(win, title_hash +% @as(nk_hash, @bitCast(@as(c_int, 1))));
    }
    view.*.scroll_value = y_offset.*;
    view.*.scroll_pointer = y_offset;
    y_offset.* = 0;
    result = nk_group_scrolled_offset_begin(ctx, x_offset, y_offset, title, flags);
    win = ctx.*.current;
    layout = win.*.layout;
    view.*.total_height = row_height * (if (row_count < @as(c_int, 1)) @as(c_int, 1) else row_count);
    view.*.begin = @as(c_int, @intFromFloat(if ((@as(f32, @floatFromInt(view.*.scroll_value)) / @as(f32, @floatFromInt(row_height))) < 0.0) 0.0 else @as(f32, @floatFromInt(view.*.scroll_value)) / @as(f32, @floatFromInt(row_height))));
    view.*.count = if (nk_iceilf(layout.*.clip.h / @as(f32, @floatFromInt(row_height))) < @as(c_int, 0)) @as(c_int, 0) else nk_iceilf(layout.*.clip.h / @as(f32, @floatFromInt(row_height)));
    view.*.count = if (view.*.count < (row_count - view.*.begin)) view.*.count else row_count - view.*.begin;
    view.*.end = view.*.begin + view.*.count;
    view.*.ctx = ctx;
    return result;
}
pub fn nk_list_view_end(arg_view: [*c]struct_nk_list_view) callconv(.c) void {
    var view = arg_view;
    _ = &view;
    var ctx: [*c]struct_nk_context = undefined;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (view != null) {} else {
                __assert_fail("view", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23415))), "void nk_list_view_end(struct nk_list_view *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (view.*.ctx != null) {} else {
                __assert_fail("view->ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23416))), "void nk_list_view_end(struct nk_list_view *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (view.*.scroll_pointer != null) {} else {
                __assert_fail("view->scroll_pointer", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23417))), "void nk_list_view_end(struct nk_list_view *)");
            };
        };
    };
    if (!(view != null) or !(view.*.ctx != null)) return;
    ctx = view.*.ctx;
    win = ctx.*.current;
    layout = win.*.layout;
    layout.*.at_y = layout.*.bounds.y + @as(f32, @floatFromInt(view.*.total_height));
    view.*.scroll_pointer.* = view.*.scroll_pointer.* +% view.*.scroll_value;
    nk_group_end(view.*.ctx);
}
pub const NK_WIDGET_STATE_MODIFIED: c_int = 2;
pub const NK_WIDGET_STATE_INACTIVE: c_int = 4;
pub const NK_WIDGET_STATE_ENTERED: c_int = 8;
pub const NK_WIDGET_STATE_HOVER: c_int = 16;
pub const NK_WIDGET_STATE_ACTIVED: c_int = 32;
pub const NK_WIDGET_STATE_LEFT: c_int = 64;
pub const NK_WIDGET_STATE_HOVERED: c_int = 18;
pub const NK_WIDGET_STATE_ACTIVE: c_int = 34;
pub const enum_nk_widget_states = c_uint;
pub fn nk_widget(arg_bounds: [*c]struct_nk_rect, arg_ctx: [*c]const struct_nk_context) callconv(.c) enum_nk_widget_layout_states {
    var bounds = arg_bounds;
    _ = &bounds;
    var ctx = arg_ctx;
    _ = &ctx;
    var c: struct_nk_rect = undefined;
    _ = &c;
    var v: struct_nk_rect = undefined;
    _ = &v;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23570))), "enum nk_widget_layout_states nk_widget(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23571))), "enum nk_widget_layout_states nk_widget(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23572))), "enum nk_widget_layout_states nk_widget(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return @as(c_uint, @bitCast(NK_WIDGET_INVALID));
    nk_panel_alloc_space(bounds, ctx);
    win = ctx.*.current;
    layout = win.*.layout;
    in = &ctx.*.input;
    c = layout.*.clip;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) {} else {
                __assert_fail("!(layout->flags & NK_WINDOW_MINIMIZED)", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23588))), "enum nk_widget_layout_states nk_widget(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) {} else {
                __assert_fail("!(layout->flags & NK_WINDOW_HIDDEN)", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23589))), "enum nk_widget_layout_states nk_widget(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSED))) != 0)) {} else {
                __assert_fail("!(layout->flags & NK_WINDOW_CLOSED)", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23590))), "enum nk_widget_layout_states nk_widget(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    bounds.*.x = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(bounds.*.x))));
    bounds.*.y = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(bounds.*.y))));
    bounds.*.w = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(bounds.*.w))));
    bounds.*.h = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(bounds.*.h))));
    c.x = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.x))));
    c.y = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.y))));
    c.w = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.w))));
    c.h = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.h))));
    nk_unify(&v, &c, bounds.*.x, bounds.*.y, bounds.*.x + bounds.*.w, bounds.*.y + bounds.*.h);
    if (!((((bounds.*.x < (c.x + c.w)) and (c.x < (bounds.*.x + bounds.*.w))) and (bounds.*.y < (c.y + c.h))) and (c.y < (bounds.*.y + bounds.*.h)))) return @as(c_uint, @bitCast(NK_WIDGET_INVALID));
    if (win.*.widgets_disabled != 0) return @as(c_uint, @bitCast(NK_WIDGET_DISABLED));
    if (!(((v.x <= in.*.mouse.pos.x) and (in.*.mouse.pos.x < (v.x + v.w))) and ((v.y <= in.*.mouse.pos.y) and (in.*.mouse.pos.y < (v.y + v.h))))) return @as(c_uint, @bitCast(NK_WIDGET_ROM));
    return @as(c_uint, @bitCast(NK_WIDGET_VALID));
}
pub fn nk_widget_fitting(arg_bounds: [*c]struct_nk_rect, arg_ctx: [*c]const struct_nk_context, arg_item_padding: struct_nk_vec2) callconv(.c) enum_nk_widget_layout_states {
    var bounds = arg_bounds;
    _ = &bounds;
    var ctx = arg_ctx;
    _ = &ctx;
    var item_padding = arg_item_padding;
    _ = &item_padding;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = &item_padding;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23620))), "enum nk_widget_layout_states nk_widget_fitting(struct nk_rect *, const struct nk_context *, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23621))), "enum nk_widget_layout_states nk_widget_fitting(struct nk_rect *, const struct nk_context *, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23622))), "enum nk_widget_layout_states nk_widget_fitting(struct nk_rect *, const struct nk_context *, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return @as(c_uint, @bitCast(NK_WIDGET_INVALID));
    state = nk_widget(bounds, ctx);
    return state;
}
pub fn nk_widget_bounds(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_rect {
    var ctx = arg_ctx;
    _ = &ctx;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23441))), "struct nk_rect nk_widget_bounds(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23442))), "struct nk_rect nk_widget_bounds(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_rect(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    nk_layout_peek(&bounds, ctx);
    return bounds;
}
pub fn nk_widget_position(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_vec2 {
    var ctx = arg_ctx;
    _ = &ctx;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23452))), "struct nk_vec2 nk_widget_position(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23453))), "struct nk_vec2 nk_widget_position(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    nk_layout_peek(&bounds, ctx);
    return nk_vec2(bounds.x, bounds.y);
}
pub fn nk_widget_size(arg_ctx: [*c]const struct_nk_context) callconv(.c) struct_nk_vec2 {
    var ctx = arg_ctx;
    _ = &ctx;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23464))), "struct nk_vec2 nk_widget_size(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23465))), "struct nk_vec2 nk_widget_size(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    nk_layout_peek(&bounds, ctx);
    return nk_vec2(bounds.w, bounds.h);
}
pub fn nk_widget_width(arg_ctx: [*c]const struct_nk_context) callconv(.c) f32 {
    var ctx = arg_ctx;
    _ = &ctx;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23476))), "float nk_widget_width(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23477))), "float nk_widget_width(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return 0;
    nk_layout_peek(&bounds, ctx);
    return bounds.w;
}
pub fn nk_widget_height(arg_ctx: [*c]const struct_nk_context) callconv(.c) f32 {
    var ctx = arg_ctx;
    _ = &ctx;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23488))), "float nk_widget_height(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23489))), "float nk_widget_height(const struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return 0;
    nk_layout_peek(&bounds, ctx);
    return bounds.h;
}
pub fn nk_widget_is_hovered(arg_ctx: [*c]const struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var c: struct_nk_rect = undefined;
    _ = &c;
    var v: struct_nk_rect = undefined;
    _ = &v;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23501))), "nk_bool nk_widget_is_hovered(const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23502))), "nk_bool nk_widget_is_hovered(const struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or (ctx.*.active != ctx.*.current)) return 0;
    c = ctx.*.current.*.layout.*.clip;
    c.x = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.x))));
    c.y = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.y))));
    c.w = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.w))));
    c.h = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.h))));
    nk_layout_peek(&bounds, ctx);
    nk_unify(&v, &c, bounds.x, bounds.y, bounds.x + bounds.w, bounds.y + bounds.h);
    if (!((((bounds.x < (c.x + c.w)) and (c.x < (bounds.x + bounds.w))) and (bounds.y < (c.y + c.h))) and (c.y < (bounds.y + bounds.h)))) return 0;
    return nk_input_is_mouse_hovering_rect(&ctx.*.input, bounds);
}
pub fn nk_widget_is_mouse_clicked(arg_ctx: [*c]const struct_nk_context, arg_btn: enum_nk_buttons) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var btn = arg_btn;
    _ = &btn;
    var c: struct_nk_rect = undefined;
    _ = &c;
    var v: struct_nk_rect = undefined;
    _ = &v;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23523))), "nk_bool nk_widget_is_mouse_clicked(const struct nk_context *, enum nk_buttons)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23524))), "nk_bool nk_widget_is_mouse_clicked(const struct nk_context *, enum nk_buttons)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or (ctx.*.active != ctx.*.current)) return 0;
    c = ctx.*.current.*.layout.*.clip;
    c.x = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.x))));
    c.y = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.y))));
    c.w = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.w))));
    c.h = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.h))));
    nk_layout_peek(&bounds, ctx);
    nk_unify(&v, &c, bounds.x, bounds.y, bounds.x + bounds.w, bounds.y + bounds.h);
    if (!((((bounds.x < (c.x + c.w)) and (c.x < (bounds.x + bounds.w))) and (bounds.y < (c.y + c.h))) and (c.y < (bounds.y + bounds.h)))) return 0;
    return nk_input_mouse_clicked(&ctx.*.input, btn, bounds);
}
pub fn nk_widget_has_mouse_click_down(arg_ctx: [*c]const struct_nk_context, arg_btn: enum_nk_buttons, arg_down: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var btn = arg_btn;
    _ = &btn;
    var down = arg_down;
    _ = &down;
    var c: struct_nk_rect = undefined;
    _ = &c;
    var v: struct_nk_rect = undefined;
    _ = &v;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23545))), "nk_bool nk_widget_has_mouse_click_down(const struct nk_context *, enum nk_buttons, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23546))), "nk_bool nk_widget_has_mouse_click_down(const struct nk_context *, enum nk_buttons, nk_bool)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or (ctx.*.active != ctx.*.current)) return 0;
    c = ctx.*.current.*.layout.*.clip;
    c.x = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.x))));
    c.y = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.y))));
    c.w = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.w))));
    c.h = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(c.h))));
    nk_layout_peek(&bounds, ctx);
    nk_unify(&v, &c, bounds.x, bounds.y, bounds.x + bounds.w, bounds.y + bounds.h);
    if (!((((bounds.x < (c.x + c.w)) and (c.x < (bounds.x + bounds.w))) and (bounds.y < (c.y + c.h))) and (c.y < (bounds.y + bounds.h)))) return 0;
    return nk_input_has_mouse_click_down_in_rect(&ctx.*.input, btn, bounds, down);
}
pub fn nk_spacing(arg_ctx: [*c]struct_nk_context, arg_cols: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var cols = arg_cols;
    _ = &cols;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var none: struct_nk_rect = undefined;
    _ = &none;
    var i: c_int = undefined;
    _ = &i;
    var index: c_int = undefined;
    _ = &index;
    var rows: c_int = undefined;
    _ = &rows;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23637))), "void nk_spacing(struct nk_context *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23638))), "void nk_spacing(struct nk_context *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23639))), "void nk_spacing(struct nk_context *, int)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    index = @import("std").zig.c_translation.signedRemainder(layout.*.row.index + cols, layout.*.row.columns);
    rows = @divTrunc(layout.*.row.index + cols, layout.*.row.columns);
    if (rows != 0) {
        {
            i = 0;
            while (i < rows) : (i += 1) {
                nk_panel_alloc_row(ctx, win);
            }
        }
        cols = index;
    }
    if ((layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC_FIXED))) and (layout.*.row.type != @as(c_uint, @bitCast(NK_LAYOUT_STATIC_FIXED)))) {
        {
            i = 0;
            while (i < cols) : (i += 1) {
                nk_panel_alloc_space(&none, ctx);
            }
        }
    }
    layout.*.row.index = index;
}
pub fn nk_widget_disable_begin(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23666))), "void nk_widget_disable_begin(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23667))), "void nk_widget_disable_begin(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    win = ctx.*.current;
    style = &ctx.*.style;
    win.*.widgets_disabled = nk_true;
    style.*.button.color_factor_text = style.*.button.disabled_factor;
    style.*.button.color_factor_background = style.*.button.disabled_factor;
    style.*.chart.color_factor = style.*.chart.disabled_factor;
    style.*.checkbox.color_factor = style.*.checkbox.disabled_factor;
    style.*.combo.color_factor = style.*.combo.disabled_factor;
    style.*.combo.button.color_factor_text = style.*.combo.button.disabled_factor;
    style.*.combo.button.color_factor_background = style.*.combo.button.disabled_factor;
    style.*.contextual_button.color_factor_text = style.*.contextual_button.disabled_factor;
    style.*.contextual_button.color_factor_background = style.*.contextual_button.disabled_factor;
    style.*.edit.color_factor = style.*.edit.disabled_factor;
    style.*.edit.scrollbar.color_factor = style.*.edit.scrollbar.disabled_factor;
    style.*.menu_button.color_factor_text = style.*.menu_button.disabled_factor;
    style.*.menu_button.color_factor_background = style.*.menu_button.disabled_factor;
    style.*.option.color_factor = style.*.option.disabled_factor;
    style.*.progress.color_factor = style.*.progress.disabled_factor;
    style.*.property.color_factor = style.*.property.disabled_factor;
    style.*.property.inc_button.color_factor_text = style.*.property.inc_button.disabled_factor;
    style.*.property.inc_button.color_factor_background = style.*.property.inc_button.disabled_factor;
    style.*.property.dec_button.color_factor_text = style.*.property.dec_button.disabled_factor;
    style.*.property.dec_button.color_factor_background = style.*.property.dec_button.disabled_factor;
    style.*.property.edit.color_factor = style.*.property.edit.disabled_factor;
    style.*.scrollh.color_factor = style.*.scrollh.disabled_factor;
    style.*.scrollh.inc_button.color_factor_text = style.*.scrollh.inc_button.disabled_factor;
    style.*.scrollh.inc_button.color_factor_background = style.*.scrollh.inc_button.disabled_factor;
    style.*.scrollh.dec_button.color_factor_text = style.*.scrollh.dec_button.disabled_factor;
    style.*.scrollh.dec_button.color_factor_background = style.*.scrollh.dec_button.disabled_factor;
    style.*.scrollv.color_factor = style.*.scrollv.disabled_factor;
    style.*.scrollv.inc_button.color_factor_text = style.*.scrollv.inc_button.disabled_factor;
    style.*.scrollv.inc_button.color_factor_background = style.*.scrollv.inc_button.disabled_factor;
    style.*.scrollv.dec_button.color_factor_text = style.*.scrollv.dec_button.disabled_factor;
    style.*.scrollv.dec_button.color_factor_background = style.*.scrollv.dec_button.disabled_factor;
    style.*.selectable.color_factor = style.*.selectable.disabled_factor;
    style.*.slider.color_factor = style.*.slider.disabled_factor;
    style.*.slider.inc_button.color_factor_text = style.*.slider.inc_button.disabled_factor;
    style.*.slider.inc_button.color_factor_background = style.*.slider.inc_button.disabled_factor;
    style.*.slider.dec_button.color_factor_text = style.*.slider.dec_button.disabled_factor;
    style.*.slider.dec_button.color_factor_background = style.*.slider.dec_button.disabled_factor;
    style.*.tab.color_factor = style.*.tab.disabled_factor;
    style.*.tab.node_maximize_button.color_factor_text = style.*.tab.node_maximize_button.disabled_factor;
    style.*.tab.node_minimize_button.color_factor_text = style.*.tab.node_minimize_button.disabled_factor;
    style.*.tab.tab_maximize_button.color_factor_text = style.*.tab.tab_maximize_button.disabled_factor;
    style.*.tab.tab_maximize_button.color_factor_background = style.*.tab.tab_maximize_button.disabled_factor;
    style.*.tab.tab_minimize_button.color_factor_text = style.*.tab.tab_minimize_button.disabled_factor;
    style.*.tab.tab_minimize_button.color_factor_background = style.*.tab.tab_minimize_button.disabled_factor;
    style.*.text.color_factor = style.*.text.disabled_factor;
}
pub fn nk_widget_disable_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23729))), "void nk_widget_disable_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23730))), "void nk_widget_disable_end(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    win = ctx.*.current;
    style = &ctx.*.style;
    win.*.widgets_disabled = nk_false;
    style.*.button.color_factor_text = 1.0;
    style.*.button.color_factor_background = 1.0;
    style.*.chart.color_factor = 1.0;
    style.*.checkbox.color_factor = 1.0;
    style.*.combo.color_factor = 1.0;
    style.*.combo.button.color_factor_text = 1.0;
    style.*.combo.button.color_factor_background = 1.0;
    style.*.contextual_button.color_factor_text = 1.0;
    style.*.contextual_button.color_factor_background = 1.0;
    style.*.edit.color_factor = 1.0;
    style.*.edit.scrollbar.color_factor = 1.0;
    style.*.menu_button.color_factor_text = 1.0;
    style.*.menu_button.color_factor_background = 1.0;
    style.*.option.color_factor = 1.0;
    style.*.progress.color_factor = 1.0;
    style.*.property.color_factor = 1.0;
    style.*.property.inc_button.color_factor_text = 1.0;
    style.*.property.inc_button.color_factor_background = 1.0;
    style.*.property.dec_button.color_factor_text = 1.0;
    style.*.property.dec_button.color_factor_background = 1.0;
    style.*.property.edit.color_factor = 1.0;
    style.*.scrollh.color_factor = 1.0;
    style.*.scrollh.inc_button.color_factor_text = 1.0;
    style.*.scrollh.inc_button.color_factor_background = 1.0;
    style.*.scrollh.dec_button.color_factor_text = 1.0;
    style.*.scrollh.dec_button.color_factor_background = 1.0;
    style.*.scrollv.color_factor = 1.0;
    style.*.scrollv.inc_button.color_factor_text = 1.0;
    style.*.scrollv.inc_button.color_factor_background = 1.0;
    style.*.scrollv.dec_button.color_factor_text = 1.0;
    style.*.scrollv.dec_button.color_factor_background = 1.0;
    style.*.selectable.color_factor = 1.0;
    style.*.slider.color_factor = 1.0;
    style.*.slider.inc_button.color_factor_text = 1.0;
    style.*.slider.inc_button.color_factor_background = 1.0;
    style.*.slider.dec_button.color_factor_text = 1.0;
    style.*.slider.dec_button.color_factor_background = 1.0;
    style.*.tab.color_factor = 1.0;
    style.*.tab.node_maximize_button.color_factor_text = 1.0;
    style.*.tab.node_minimize_button.color_factor_text = 1.0;
    style.*.tab.tab_maximize_button.color_factor_text = 1.0;
    style.*.tab.tab_maximize_button.color_factor_background = 1.0;
    style.*.tab.tab_minimize_button.color_factor_text = 1.0;
    style.*.tab.tab_minimize_button.color_factor_background = 1.0;
    style.*.text.color_factor = 1.0;
}
pub const NK_TEXT_ALIGN_LEFT: c_int = 1;
pub const NK_TEXT_ALIGN_CENTERED: c_int = 2;
pub const NK_TEXT_ALIGN_RIGHT: c_int = 4;
pub const NK_TEXT_ALIGN_TOP: c_int = 8;
pub const NK_TEXT_ALIGN_MIDDLE: c_int = 16;
pub const NK_TEXT_ALIGN_BOTTOM: c_int = 32;
pub const enum_nk_text_align = c_uint;
pub const NK_TEXT_LEFT: c_int = 17;
pub const NK_TEXT_CENTERED: c_int = 18;
pub const NK_TEXT_RIGHT: c_int = 20;
pub const enum_nk_text_alignment = c_uint;
pub fn nk_text(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_len: c_int, arg_alignment: nk_flags) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var alignment = arg_alignment;
    _ = &alignment;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24046))), "void nk_text(struct nk_context *, const char *, int, nk_flags)");
            };
        };
    };
    if (!(ctx != null)) return;
    nk_text_colored(ctx, str, len, alignment, ctx.*.style.text.color);
}
pub const struct_nk_text = extern struct {
    padding: struct_nk_vec2 = @import("std").mem.zeroes(struct_nk_vec2),
    background: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    text: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub fn nk_text_colored(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_len: c_int, arg_alignment: nk_flags, arg_color: struct_nk_color) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var alignment = arg_alignment;
    _ = &alignment;
    var color = arg_color;
    _ = &color;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var item_padding: struct_nk_vec2 = undefined;
    _ = &item_padding;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var text: struct_nk_text = undefined;
    _ = &text;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23890))), "void nk_text_colored(struct nk_context *, const char *, int, nk_flags, struct nk_color)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23891))), "void nk_text_colored(struct nk_context *, const char *, int, nk_flags, struct nk_color)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23892))), "void nk_text_colored(struct nk_context *, const char *, int, nk_flags, struct nk_color)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    style = &ctx.*.style;
    nk_panel_alloc_space(&bounds, ctx);
    item_padding = style.*.text.padding;
    text.padding.x = item_padding.x;
    text.padding.y = item_padding.y;
    text.background = style.*.window.background;
    text.text = nk_rgb_factor(color, style.*.text.color_factor);
    nk_widget_text(&win.*.buffer, bounds, str, len, &text, alignment, style.*.font);
}
pub fn nk_text_wrap(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_len: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24053))), "void nk_text_wrap(struct nk_context *, const char *, int)");
            };
        };
    };
    if (!(ctx != null)) return;
    nk_text_wrap_colored(ctx, str, len, ctx.*.style.text.color);
}
pub fn nk_text_wrap_colored(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_len: c_int, arg_color: struct_nk_color) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var color = arg_color;
    _ = &color;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var item_padding: struct_nk_vec2 = undefined;
    _ = &item_padding;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var text: struct_nk_text = undefined;
    _ = &text;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23917))), "void nk_text_wrap_colored(struct nk_context *, const char *, int, struct nk_color)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23918))), "void nk_text_wrap_colored(struct nk_context *, const char *, int, struct nk_color)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23919))), "void nk_text_wrap_colored(struct nk_context *, const char *, int, struct nk_color)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    style = &ctx.*.style;
    nk_panel_alloc_space(&bounds, ctx);
    item_padding = style.*.text.padding;
    text.padding.x = item_padding.x;
    text.padding.y = item_padding.y;
    text.background = style.*.window.background;
    text.text = nk_rgb_factor(color, style.*.text.color_factor);
    nk_widget_text_wrap(&win.*.buffer, bounds, str, len, &text, style.*.font);
}
pub fn nk_label(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_alignment: nk_flags) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var alignment = arg_alignment;
    _ = &alignment;
    nk_text(ctx, str, nk_strlen(str), alignment);
}
pub fn nk_label_colored(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_align: nk_flags, arg_color: struct_nk_color) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var @"align" = arg_align;
    _ = &@"align";
    var color = arg_color;
    _ = &color;
    nk_text_colored(ctx, str, nk_strlen(str), @"align", color);
}
pub fn nk_label_wrap(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    nk_text_wrap(ctx, str, nk_strlen(str));
}
pub fn nk_label_colored_wrap(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_color: struct_nk_color) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var color = arg_color;
    _ = &color;
    nk_text_wrap_colored(ctx, str, nk_strlen(str), color);
}
pub fn nk_image(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24194))), "void nk_image(struct nk_context *, struct nk_image)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24195))), "void nk_image(struct nk_context *, struct nk_image)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24196))), "void nk_image(struct nk_context *, struct nk_image)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    if (!(nk_widget(&bounds, ctx) != 0)) return;
    nk_draw_image(&win.*.buffer, bounds, &img, nk_white);
}
pub fn nk_image_color(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_col: struct_nk_color) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var col = arg_col;
    _ = &col;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24209))), "void nk_image_color(struct nk_context *, struct nk_image, struct nk_color)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24210))), "void nk_image_color(struct nk_context *, struct nk_image, struct nk_color)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24211))), "void nk_image_color(struct nk_context *, struct nk_image, struct nk_color)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    if (!(nk_widget(&bounds, ctx) != 0)) return;
    nk_draw_image(&win.*.buffer, bounds, &img, col);
}
pub fn nk_button_text(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_len: c_int) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var len = arg_len;
    _ = &len;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24813))), "nk_bool nk_button_text(struct nk_context *, const char *, int)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    return nk_button_text_styled(ctx, &ctx.*.style.button, title, len);
}
pub fn nk_button_label(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    return nk_button_text(ctx, title, nk_strlen(title));
}
pub fn nk_button_color(arg_ctx: [*c]struct_nk_context, arg_color: struct_nk_color) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var color = arg_color;
    _ = &color;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var button: struct_nk_style_button = undefined;
    _ = &button;
    var ret: c_int = 0;
    _ = &ret;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var content: struct_nk_rect = undefined;
    _ = &content;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24839))), "nk_bool nk_button_color(struct nk_context *, struct nk_color)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24840))), "nk_bool nk_button_color(struct nk_context *, struct nk_color)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24841))), "nk_bool nk_button_color(struct nk_context *, struct nk_color)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    button = ctx.*.style.button;
    button.normal = nk_style_item_color(color);
    button.hover = nk_style_item_color(color);
    button.active = nk_style_item_color(color);
    ret = nk_do_button(&ctx.*.last_widget_state, &win.*.buffer, bounds, &button, in, ctx.*.button_behavior, &content);
    _ = nk_draw_button(&win.*.buffer, &bounds, ctx.*.last_widget_state, &button);
    return ret;
}
pub fn nk_button_symbol(arg_ctx: [*c]struct_nk_context, arg_symbol: enum_nk_symbol_type) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var symbol = arg_symbol;
    _ = &symbol;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24889))), "nk_bool nk_button_symbol(struct nk_context *, enum nk_symbol_type)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    return nk_button_symbol_styled(ctx, &ctx.*.style.button, symbol);
}
pub fn nk_button_image(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24922))), "nk_bool nk_button_image(struct nk_context *, struct nk_image)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    return nk_button_image_styled(ctx, &ctx.*.style.button, img);
}
pub fn nk_button_symbol_label(arg_ctx: [*c]struct_nk_context, arg_symbol: enum_nk_symbol_type, arg_label: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var symbol = arg_symbol;
    _ = &symbol;
    var label = arg_label;
    _ = &label;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_button_symbol_text(ctx, symbol, label, nk_strlen(label), @"align");
}
pub fn nk_button_symbol_text(arg_ctx: [*c]struct_nk_context, arg_symbol: enum_nk_symbol_type, arg_text: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var symbol = arg_symbol;
    _ = &symbol;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24958))), "nk_bool nk_button_symbol_text(struct nk_context *, enum nk_symbol_type, const char *, int, nk_flags)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    return nk_button_symbol_text_styled(ctx, &ctx.*.style.button, symbol, text, len, @"align");
}
pub fn nk_button_image_label(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_label: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var label = arg_label;
    _ = &label;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_button_image_text(ctx, img, label, nk_strlen(label), @"align");
}
pub fn nk_button_image_text(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_text: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_button_image_text_styled(ctx, &ctx.*.style.button, img, text, len, @"align");
}
pub fn nk_button_text_styled(arg_ctx: [*c]struct_nk_context, arg_style: [*c]const struct_nk_style_button, arg_title: [*c]const u8, arg_len: c_int) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var style = arg_style;
    _ = &style;
    var title = arg_title;
    _ = &title;
    var len = arg_len;
    _ = &len;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24794))), "nk_bool nk_button_text_styled(struct nk_context *, const struct nk_style_button *, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24795))), "nk_bool nk_button_text_styled(struct nk_context *, const struct nk_style_button *, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24796))), "nk_bool nk_button_text_styled(struct nk_context *, const struct nk_style_button *, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24797))), "nk_bool nk_button_text_styled(struct nk_context *, const struct nk_style_button *, const char *, int)");
            };
        };
    };
    if (((!(style != null) or !(ctx != null)) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    return nk_do_button_text(&ctx.*.last_widget_state, &win.*.buffer, bounds, title, len, style.*.text_alignment, ctx.*.button_behavior, style, in, ctx.*.style.font);
}
pub fn nk_button_label_styled(arg_ctx: [*c]struct_nk_context, arg_style: [*c]const struct_nk_style_button, arg_title: [*c]const u8) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var style = arg_style;
    _ = &style;
    var title = arg_title;
    _ = &title;
    return nk_button_text_styled(ctx, style, title, nk_strlen(title));
}
pub fn nk_button_symbol_styled(arg_ctx: [*c]struct_nk_context, arg_style: [*c]const struct_nk_style_button, arg_symbol: enum_nk_symbol_type) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var style = arg_style;
    _ = &style;
    var symbol = arg_symbol;
    _ = &symbol;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24872))), "nk_bool nk_button_symbol_styled(struct nk_context *, const struct nk_style_button *, enum nk_symbol_type)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24873))), "nk_bool nk_button_symbol_styled(struct nk_context *, const struct nk_style_button *, enum nk_symbol_type)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24874))), "nk_bool nk_button_symbol_styled(struct nk_context *, const struct nk_style_button *, enum nk_symbol_type)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    return nk_do_button_symbol(&ctx.*.last_widget_state, &win.*.buffer, bounds, symbol, ctx.*.button_behavior, style, in, ctx.*.style.font);
}
pub fn nk_button_image_styled(arg_ctx: [*c]struct_nk_context, arg_style: [*c]const struct_nk_style_button, arg_img: struct_nk_image) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var style = arg_style;
    _ = &style;
    var img = arg_img;
    _ = &img;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24904))), "nk_bool nk_button_image_styled(struct nk_context *, const struct nk_style_button *, struct nk_image)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24905))), "nk_bool nk_button_image_styled(struct nk_context *, const struct nk_style_button *, struct nk_image)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24906))), "nk_bool nk_button_image_styled(struct nk_context *, const struct nk_style_button *, struct nk_image)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    return nk_do_button_image(&ctx.*.last_widget_state, &win.*.buffer, bounds, img, ctx.*.button_behavior, style, in);
}
pub fn nk_button_symbol_text_styled(arg_ctx: [*c]struct_nk_context, arg_style: [*c]const struct_nk_style_button, arg_symbol: enum_nk_symbol_type, arg_text: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var style = arg_style;
    _ = &style;
    var symbol = arg_symbol;
    _ = &symbol;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24938))), "nk_bool nk_button_symbol_text_styled(struct nk_context *, const struct nk_style_button *, enum nk_symbol_type, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24939))), "nk_bool nk_button_symbol_text_styled(struct nk_context *, const struct nk_style_button *, enum nk_symbol_type, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24940))), "nk_bool nk_button_symbol_text_styled(struct nk_context *, const struct nk_style_button *, enum nk_symbol_type, const char *, int, nk_flags)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    return nk_do_button_text_symbol(&ctx.*.last_widget_state, &win.*.buffer, bounds, symbol, text, len, @"align", ctx.*.button_behavior, style, ctx.*.style.font, in);
}
pub fn nk_button_symbol_label_styled(arg_ctx: [*c]struct_nk_context, arg_style: [*c]const struct_nk_style_button, arg_symbol: enum_nk_symbol_type, arg_title: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var style = arg_style;
    _ = &style;
    var symbol = arg_symbol;
    _ = &symbol;
    var title = arg_title;
    _ = &title;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_button_symbol_text_styled(ctx, style, symbol, title, nk_strlen(title), @"align");
}
pub fn nk_button_image_label_styled(arg_ctx: [*c]struct_nk_context, arg_style: [*c]const struct_nk_style_button, arg_img: struct_nk_image, arg_label: [*c]const u8, arg_text_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var style = arg_style;
    _ = &style;
    var img = arg_img;
    _ = &img;
    var label = arg_label;
    _ = &label;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    return nk_button_image_text_styled(ctx, style, img, label, nk_strlen(label), text_alignment);
}
pub fn nk_button_image_text_styled(arg_ctx: [*c]struct_nk_context, arg_style: [*c]const struct_nk_style_button, arg_img: struct_nk_image, arg_text: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var style = arg_style;
    _ = &style;
    var img = arg_img;
    _ = &img;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24985))), "nk_bool nk_button_image_text_styled(struct nk_context *, const struct nk_style_button *, struct nk_image, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24986))), "nk_bool nk_button_image_text_styled(struct nk_context *, const struct nk_style_button *, struct nk_image, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24987))), "nk_bool nk_button_image_text_styled(struct nk_context *, const struct nk_style_button *, struct nk_image, const char *, int, nk_flags)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    return nk_do_button_text_image(&ctx.*.last_widget_state, &win.*.buffer, bounds, img, text, len, @"align", ctx.*.button_behavior, style, ctx.*.style.font, in);
}
pub fn nk_button_set_behavior(arg_ctx: [*c]struct_nk_context, arg_behavior: enum_nk_button_behavior) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var behavior = arg_behavior;
    _ = &behavior;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24741))), "void nk_button_set_behavior(struct nk_context *, enum nk_button_behavior)");
            };
        };
    };
    if (!(ctx != null)) return;
    ctx.*.button_behavior = behavior;
}
pub fn nk_button_push_behavior(arg_ctx: [*c]struct_nk_context, arg_behavior: enum_nk_button_behavior) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var behavior = arg_behavior;
    _ = &behavior;
    var button_stack: [*c]struct_nk_config_stack_button_behavior = undefined;
    _ = &button_stack;
    var element: [*c]struct_nk_config_stack_button_behavior_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24751))), "nk_bool nk_button_push_behavior(struct nk_context *, enum nk_button_behavior)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    button_stack = &ctx.*.stacks.button_behaviors;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (button_stack.*.head < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([8]struct_nk_config_stack_button_behavior_element) / @sizeOf(struct_nk_config_stack_button_behavior_element)))))) {} else {
                __assert_fail("button_stack->head < (int)(sizeof(button_stack->elements)/sizeof(button_stack->elements)[0])", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24755))), "nk_bool nk_button_push_behavior(struct nk_context *, enum nk_button_behavior)");
            };
        };
    };
    if (button_stack.*.head >= @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([8]struct_nk_config_stack_button_behavior_element) / @sizeOf(struct_nk_config_stack_button_behavior_element)))))) return 0;
    element = &button_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &button_stack.*.head;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))];
    element.*.address = &ctx.*.button_behavior;
    element.*.old_value = ctx.*.button_behavior;
    ctx.*.button_behavior = behavior;
    return 1;
}
pub fn nk_button_pop_behavior(arg_ctx: [*c]struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var button_stack: [*c]struct_nk_config_stack_button_behavior = undefined;
    _ = &button_stack;
    var element: [*c]struct_nk_config_stack_button_behavior_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24771))), "nk_bool nk_button_pop_behavior(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    button_stack = &ctx.*.stacks.button_behaviors;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (button_stack.*.head > @as(c_int, 0)) {} else {
                __assert_fail("button_stack->head > 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24775))), "nk_bool nk_button_pop_behavior(struct nk_context *)");
            };
        };
    };
    if (button_stack.*.head < @as(c_int, 1)) return 0;
    element = &button_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &button_stack.*.head;
        ref.* -= 1;
        break :blk ref.*;
    }))];
    element.*.address.* = element.*.old_value;
    return 1;
}
pub fn nk_check_label(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_active: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var active = arg_active;
    _ = &active;
    return nk_check_text(ctx, label, nk_strlen(label), active);
}
pub fn nk_check_text(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_active: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var active = arg_active;
    _ = &active;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25230))), "nk_bool nk_check_text(struct nk_context *, const char *, int, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25231))), "nk_bool nk_check_text(struct nk_context *, const char *, int, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25232))), "nk_bool nk_check_text(struct nk_context *, const char *, int, nk_bool)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return active;
    win = ctx.*.current;
    style = &ctx.*.style;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return active;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    _ = nk_do_toggle(&ctx.*.last_widget_state, &win.*.buffer, bounds, &active, text, len, @as(c_uint, @bitCast(NK_TOGGLE_CHECK)), &style.*.checkbox, in, style.*.font, @as(nk_flags, @bitCast(NK_WIDGET_LEFT)), @as(nk_flags, @bitCast(NK_TEXT_LEFT)));
    return active;
}
pub fn nk_check_text_align(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_active: nk_bool, arg_widget_alignment: nk_flags, arg_text_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var active = arg_active;
    _ = &active;
    var widget_alignment = arg_widget_alignment;
    _ = &widget_alignment;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25258))), "nk_bool nk_check_text_align(struct nk_context *, const char *, int, nk_bool, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25259))), "nk_bool nk_check_text_align(struct nk_context *, const char *, int, nk_bool, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25260))), "nk_bool nk_check_text_align(struct nk_context *, const char *, int, nk_bool, nk_flags, nk_flags)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return active;
    win = ctx.*.current;
    style = &ctx.*.style;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return active;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    _ = nk_do_toggle(&ctx.*.last_widget_state, &win.*.buffer, bounds, &active, text, len, @as(c_uint, @bitCast(NK_TOGGLE_CHECK)), &style.*.checkbox, in, style.*.font, widget_alignment, text_alignment);
    return active;
}
pub fn nk_check_flags_label(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_flags: c_uint, arg_value: c_uint) callconv(.c) c_uint {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var flags = arg_flags;
    _ = &flags;
    var value = arg_value;
    _ = &value;
    return nk_check_flags_text(ctx, label, nk_strlen(label), flags, value);
}
pub fn nk_check_flags_text(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_flags: c_uint, arg_value: c_uint) callconv(.c) c_uint {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var flags = arg_flags;
    _ = &flags;
    var value = arg_value;
    _ = &value;
    var old_active: c_int = undefined;
    _ = &old_active;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25280))), "unsigned int nk_check_flags_text(struct nk_context *, const char *, int, unsigned int, unsigned int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (text != null) {} else {
                __assert_fail("text", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25281))), "unsigned int nk_check_flags_text(struct nk_context *, const char *, int, unsigned int, unsigned int)");
            };
        };
    };
    if (!(ctx != null) or !(text != null)) return flags;
    old_active = @as(c_int, @bitCast((flags & value) & value));
    if (nk_check_text(ctx, text, len, old_active) != 0) {
        flags |= value;
    } else {
        flags &= ~value;
    }
    return flags;
}
pub fn nk_checkbox_label(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_active: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var active = arg_active;
    _ = &active;
    return nk_checkbox_text(ctx, label, nk_strlen(label), active);
}
pub fn nk_checkbox_label_align(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_active: [*c]nk_bool, arg_widget_alignment: nk_flags, arg_text_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var active = arg_active;
    _ = &active;
    var widget_alignment = arg_widget_alignment;
    _ = &widget_alignment;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    return nk_checkbox_text_align(ctx, label, nk_strlen(label), active, widget_alignment, text_alignment);
}
pub fn nk_checkbox_text(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_active: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var active = arg_active;
    _ = &active;
    var old_val: c_int = undefined;
    _ = &old_val;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25293))), "nk_bool nk_checkbox_text(struct nk_context *, const char *, int, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (text != null) {} else {
                __assert_fail("text", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25294))), "nk_bool nk_checkbox_text(struct nk_context *, const char *, int, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (active != null) {} else {
                __assert_fail("active", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25295))), "nk_bool nk_checkbox_text(struct nk_context *, const char *, int, nk_bool *)");
            };
        };
    };
    if ((!(ctx != null) or !(text != null)) or !(active != null)) return 0;
    old_val = active.*;
    active.* = nk_check_text(ctx, text, len, active.*);
    return @intFromBool(old_val != active.*);
}
pub fn nk_checkbox_text_align(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_active: [*c]nk_bool, arg_widget_alignment: nk_flags, arg_text_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var active = arg_active;
    _ = &active;
    var widget_alignment = arg_widget_alignment;
    _ = &widget_alignment;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    var old_val: c_int = undefined;
    _ = &old_val;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25305))), "nk_bool nk_checkbox_text_align(struct nk_context *, const char *, int, nk_bool *, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (text != null) {} else {
                __assert_fail("text", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25306))), "nk_bool nk_checkbox_text_align(struct nk_context *, const char *, int, nk_bool *, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (active != null) {} else {
                __assert_fail("active", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25307))), "nk_bool nk_checkbox_text_align(struct nk_context *, const char *, int, nk_bool *, nk_flags, nk_flags)");
            };
        };
    };
    if ((!(ctx != null) or !(text != null)) or !(active != null)) return 0;
    old_val = active.*;
    active.* = nk_check_text_align(ctx, text, len, active.*, widget_alignment, text_alignment);
    return @intFromBool(old_val != active.*);
}
pub fn nk_checkbox_flags_label(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_flags: [*c]c_uint, arg_value: c_uint) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var flags = arg_flags;
    _ = &flags;
    var value = arg_value;
    _ = &value;
    return nk_checkbox_flags_text(ctx, label, nk_strlen(label), flags, value);
}
pub fn nk_checkbox_flags_text(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_flags: [*c]c_uint, arg_value: c_uint) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var flags = arg_flags;
    _ = &flags;
    var value = arg_value;
    _ = &value;
    var active: nk_bool = undefined;
    _ = &active;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25318))), "nk_bool nk_checkbox_flags_text(struct nk_context *, const char *, int, unsigned int *, unsigned int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (text != null) {} else {
                __assert_fail("text", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25319))), "nk_bool nk_checkbox_flags_text(struct nk_context *, const char *, int, unsigned int *, unsigned int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (flags != null) {} else {
                __assert_fail("flags", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25320))), "nk_bool nk_checkbox_flags_text(struct nk_context *, const char *, int, unsigned int *, unsigned int)");
            };
        };
    };
    if ((!(ctx != null) or !(text != null)) or !(flags != null)) return 0;
    active = @as(c_int, @bitCast((flags.* & value) & value));
    if (nk_checkbox_text(ctx, text, len, &active) != 0) {
        if (active != 0) {
            flags.* |= value;
        } else {
            flags.* &= ~value;
        }
        return 1;
    }
    return 0;
}
pub fn nk_radio_label(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_active: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var active = arg_active;
    _ = &active;
    return nk_radio_text(ctx, label, nk_strlen(label), active);
}
pub fn nk_radio_label_align(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_active: [*c]nk_bool, arg_widget_alignment: nk_flags, arg_text_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var active = arg_active;
    _ = &active;
    var widget_alignment = arg_widget_alignment;
    _ = &widget_alignment;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    return nk_radio_text_align(ctx, label, nk_strlen(label), active, widget_alignment, text_alignment);
}
pub fn nk_radio_text(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_active: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var active = arg_active;
    _ = &active;
    var old_value: c_int = undefined;
    _ = &old_value;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25418))), "nk_bool nk_radio_text(struct nk_context *, const char *, int, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (text != null) {} else {
                __assert_fail("text", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25419))), "nk_bool nk_radio_text(struct nk_context *, const char *, int, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (active != null) {} else {
                __assert_fail("active", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25420))), "nk_bool nk_radio_text(struct nk_context *, const char *, int, nk_bool *)");
            };
        };
    };
    if ((!(ctx != null) or !(text != null)) or !(active != null)) return 0;
    old_value = active.*;
    active.* = nk_option_text(ctx, text, len, old_value);
    return @intFromBool(old_value != active.*);
}
pub fn nk_radio_text_align(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_active: [*c]nk_bool, arg_widget_alignment: nk_flags, arg_text_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var active = arg_active;
    _ = &active;
    var widget_alignment = arg_widget_alignment;
    _ = &widget_alignment;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    var old_value: c_int = undefined;
    _ = &old_value;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25430))), "nk_bool nk_radio_text_align(struct nk_context *, const char *, int, nk_bool *, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (text != null) {} else {
                __assert_fail("text", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25431))), "nk_bool nk_radio_text_align(struct nk_context *, const char *, int, nk_bool *, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (active != null) {} else {
                __assert_fail("active", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25432))), "nk_bool nk_radio_text_align(struct nk_context *, const char *, int, nk_bool *, nk_flags, nk_flags)");
            };
        };
    };
    if ((!(ctx != null) or !(text != null)) or !(active != null)) return 0;
    old_value = active.*;
    active.* = nk_option_text_align(ctx, text, len, old_value, widget_alignment, text_alignment);
    return @intFromBool(old_value != active.*);
}
pub fn nk_option_label(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_active: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var active = arg_active;
    _ = &active;
    return nk_option_text(ctx, label, nk_strlen(label), active);
}
pub fn nk_option_label_align(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_active: nk_bool, arg_widget_alignment: nk_flags, arg_text_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var active = arg_active;
    _ = &active;
    var widget_alignment = arg_widget_alignment;
    _ = &widget_alignment;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    return nk_option_text_align(ctx, label, nk_strlen(label), active, widget_alignment, text_alignment);
}
pub fn nk_option_text(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_is_active: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var is_active = arg_is_active;
    _ = &is_active;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25369))), "nk_bool nk_option_text(struct nk_context *, const char *, int, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25370))), "nk_bool nk_option_text(struct nk_context *, const char *, int, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25371))), "nk_bool nk_option_text(struct nk_context *, const char *, int, nk_bool)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return is_active;
    win = ctx.*.current;
    style = &ctx.*.style;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return @as(c_int, @bitCast(state));
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    _ = nk_do_toggle(&ctx.*.last_widget_state, &win.*.buffer, bounds, &is_active, text, len, @as(c_uint, @bitCast(NK_TOGGLE_OPTION)), &style.*.option, in, style.*.font, @as(nk_flags, @bitCast(NK_WIDGET_LEFT)), @as(nk_flags, @bitCast(NK_TEXT_LEFT)));
    return is_active;
}
pub fn nk_option_text_align(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_is_active: nk_bool, arg_widget_alignment: nk_flags, arg_text_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var is_active = arg_is_active;
    _ = &is_active;
    var widget_alignment = arg_widget_alignment;
    _ = &widget_alignment;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25397))), "nk_bool nk_option_text_align(struct nk_context *, const char *, int, nk_bool, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25398))), "nk_bool nk_option_text_align(struct nk_context *, const char *, int, nk_bool, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25399))), "nk_bool nk_option_text_align(struct nk_context *, const char *, int, nk_bool, nk_flags, nk_flags)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return is_active;
    win = ctx.*.current;
    style = &ctx.*.style;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return @as(c_int, @bitCast(state));
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    _ = nk_do_toggle(&ctx.*.last_widget_state, &win.*.buffer, bounds, &is_active, text, len, @as(c_uint, @bitCast(NK_TOGGLE_OPTION)), &style.*.option, in, style.*.font, widget_alignment, text_alignment);
    return is_active;
}
pub fn nk_selectable_label(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_align: nk_flags, arg_value: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    return nk_selectable_text(ctx, str, nk_strlen(str), @"align", value);
}
pub fn nk_selectable_text(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_value: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25670))), "nk_bool nk_selectable_text(struct nk_context *, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (value != null) {} else {
                __assert_fail("value", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25671))), "nk_bool nk_selectable_text(struct nk_context *, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25672))), "nk_bool nk_selectable_text(struct nk_context *, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25673))), "nk_bool nk_selectable_text(struct nk_context *, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(value != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    style = &ctx.*.style;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    return nk_do_selectable(&ctx.*.last_widget_state, &win.*.buffer, bounds, str, len, @"align", value, &style.*.selectable, in, style.*.font);
}
pub fn nk_selectable_image_label(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_str: [*c]const u8, arg_align: nk_flags, arg_value: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var str = arg_str;
    _ = &str;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    return nk_selectable_image_text(ctx, img, str, nk_strlen(str), @"align", value);
}
pub fn nk_selectable_image_text(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_value: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25699))), "nk_bool nk_selectable_image_text(struct nk_context *, struct nk_image, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (value != null) {} else {
                __assert_fail("value", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25700))), "nk_bool nk_selectable_image_text(struct nk_context *, struct nk_image, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25701))), "nk_bool nk_selectable_image_text(struct nk_context *, struct nk_image, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25702))), "nk_bool nk_selectable_image_text(struct nk_context *, struct nk_image, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(value != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    style = &ctx.*.style;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    return nk_do_selectable_image(&ctx.*.last_widget_state, &win.*.buffer, bounds, str, len, @"align", value, &img, &style.*.selectable, in, style.*.font);
}
pub fn nk_selectable_symbol_label(arg_ctx: [*c]struct_nk_context, arg_sym: enum_nk_symbol_type, arg_title: [*c]const u8, arg_align: nk_flags, arg_value: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var sym = arg_sym;
    _ = &sym;
    var title = arg_title;
    _ = &title;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    return nk_selectable_symbol_text(ctx, sym, title, nk_strlen(title), @"align", value);
}
pub fn nk_selectable_symbol_text(arg_ctx: [*c]struct_nk_context, arg_sym: enum_nk_symbol_type, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_value: [*c]nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var sym = arg_sym;
    _ = &sym;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25728))), "nk_bool nk_selectable_symbol_text(struct nk_context *, enum nk_symbol_type, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (value != null) {} else {
                __assert_fail("value", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25729))), "nk_bool nk_selectable_symbol_text(struct nk_context *, enum nk_symbol_type, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25730))), "nk_bool nk_selectable_symbol_text(struct nk_context *, enum nk_symbol_type, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25731))), "nk_bool nk_selectable_symbol_text(struct nk_context *, enum nk_symbol_type, const char *, int, nk_flags, nk_bool *)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(value != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    style = &ctx.*.style;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    return nk_do_selectable_symbol(&ctx.*.last_widget_state, &win.*.buffer, bounds, str, len, @"align", value, sym, &style.*.selectable, in, style.*.font);
}
pub fn nk_select_label(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_align: nk_flags, arg_value: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    _ = nk_selectable_text(ctx, str, nk_strlen(str), @"align", &value);
    return value;
}
pub fn nk_select_text(arg_ctx: [*c]struct_nk_context, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_value: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    _ = nk_selectable_text(ctx, str, len, @"align", &value);
    return value;
}
pub fn nk_select_image_label(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_str: [*c]const u8, arg_align: nk_flags, arg_value: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var str = arg_str;
    _ = &str;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    _ = nk_selectable_image_text(ctx, img, str, nk_strlen(str), @"align", &value);
    return value;
}
pub fn nk_select_image_text(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_value: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    _ = nk_selectable_image_text(ctx, img, str, len, @"align", &value);
    return value;
}
pub fn nk_select_symbol_label(arg_ctx: [*c]struct_nk_context, arg_sym: enum_nk_symbol_type, arg_title: [*c]const u8, arg_align: nk_flags, arg_value: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var sym = arg_sym;
    _ = &sym;
    var title = arg_title;
    _ = &title;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    return nk_select_symbol_text(ctx, sym, title, nk_strlen(title), @"align", value);
}
pub fn nk_select_symbol_text(arg_ctx: [*c]struct_nk_context, arg_sym: enum_nk_symbol_type, arg_title: [*c]const u8, arg_title_len: c_int, arg_align: nk_flags, arg_value: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var sym = arg_sym;
    _ = &sym;
    var title = arg_title;
    _ = &title;
    var title_len = arg_title_len;
    _ = &title_len;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    _ = nk_selectable_symbol_text(ctx, sym, title, title_len, @"align", &value);
    return value;
}
pub fn nk_slide_float(arg_ctx: [*c]struct_nk_context, arg_min: f32, arg_val: f32, arg_max: f32, arg_step: f32) callconv(.c) f32 {
    var ctx = arg_ctx;
    _ = &ctx;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    _ = nk_slider_float(ctx, min, &val, max, step);
    return val;
}
pub fn nk_slide_int(arg_ctx: [*c]struct_nk_context, arg_min: c_int, arg_val: c_int, arg_max: c_int, arg_step: c_int) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var value: f32 = @as(f32, @floatFromInt(val));
    _ = &value;
    _ = nk_slider_float(ctx, @as(f32, @floatFromInt(min)), &value, @as(f32, @floatFromInt(max)), @as(f32, @floatFromInt(step)));
    return @as(c_int, @intFromFloat(value));
}
pub fn nk_slider_float(arg_ctx: [*c]struct_nk_context, arg_min_value: f32, arg_value: [*c]f32, arg_max_value: f32, arg_value_step: f32) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var min_value = arg_min_value;
    _ = &min_value;
    var value = arg_value;
    _ = &value;
    var max_value = arg_max_value;
    _ = &max_value;
    var value_step = arg_value_step;
    _ = &value_step;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var ret: c_int = 0;
    _ = &ret;
    var old_value: f32 = undefined;
    _ = &old_value;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26013))), "nk_bool nk_slider_float(struct nk_context *, float, float *, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26014))), "nk_bool nk_slider_float(struct nk_context *, float, float *, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26015))), "nk_bool nk_slider_float(struct nk_context *, float, float *, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (value != null) {} else {
                __assert_fail("value", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26016))), "nk_bool nk_slider_float(struct nk_context *, float, float *, float, float)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(value != null)) return ret;
    win = ctx.*.current;
    style = &ctx.*.style;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return ret;
    in = if ((state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    old_value = value.*;
    value.* = nk_do_slider(&ctx.*.last_widget_state, &win.*.buffer, bounds, min_value, old_value, max_value, value_step, &style.*.slider, in, style.*.font);
    return @intFromBool((old_value > value.*) or (old_value < value.*));
}
pub fn nk_slider_int(arg_ctx: [*c]struct_nk_context, arg_min: c_int, arg_val: [*c]c_int, arg_max: c_int, arg_step: c_int) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var ret: c_int = undefined;
    _ = &ret;
    var value: f32 = @as(f32, @floatFromInt(val.*));
    _ = &value;
    ret = nk_slider_float(ctx, @as(f32, @floatFromInt(min)), &value, @as(f32, @floatFromInt(max)), @as(f32, @floatFromInt(step)));
    val.* = @as(c_int, @intFromFloat(value));
    return ret;
}
pub fn nk_knob_float(arg_ctx: [*c]struct_nk_context, arg_min_value: f32, arg_value: [*c]f32, arg_max_value: f32, arg_value_step: f32, arg_zero_direction: enum_nk_heading, arg_dead_zone_degrees: f32) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var min_value = arg_min_value;
    _ = &min_value;
    var value = arg_value;
    _ = &value;
    var max_value = arg_max_value;
    _ = &max_value;
    var value_step = arg_value_step;
    _ = &value_step;
    var zero_direction = arg_zero_direction;
    _ = &zero_direction;
    var dead_zone_degrees = arg_dead_zone_degrees;
    _ = &dead_zone_degrees;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var ret: c_int = 0;
    _ = &ret;
    var old_value: f32 = undefined;
    _ = &old_value;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26276))), "nk_bool nk_knob_float(struct nk_context *, float, float *, float, float, enum nk_heading, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26277))), "nk_bool nk_knob_float(struct nk_context *, float, float *, float, float, enum nk_heading, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26278))), "nk_bool nk_knob_float(struct nk_context *, float, float *, float, float, enum nk_heading, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (value != null) {} else {
                __assert_fail("value", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26279))), "nk_bool nk_knob_float(struct nk_context *, float, float *, float, float, enum nk_heading, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((0.0 <= dead_zone_degrees) and (dead_zone_degrees < 360.0)) {} else {
                __assert_fail("((0.0f) <= (dead_zone_degrees) && (dead_zone_degrees) < (360.0f))", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26280))), "nk_bool nk_knob_float(struct nk_context *, float, float *, float, float, enum nk_heading, float)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(value != null)) return ret;
    win = ctx.*.current;
    style = &ctx.*.style;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return ret;
    in = if ((state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    old_value = value.*;
    value.* = nk_do_knob(&ctx.*.last_widget_state, &win.*.buffer, bounds, min_value, old_value, max_value, value_step, zero_direction, dead_zone_degrees / 360.0, &style.*.knob, in);
    return @intFromBool((old_value > value.*) or (old_value < value.*));
}
pub fn nk_knob_int(arg_ctx: [*c]struct_nk_context, arg_min: c_int, arg_val: [*c]c_int, arg_max: c_int, arg_step: c_int, arg_zero_direction: enum_nk_heading, arg_dead_zone_degrees: f32) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var zero_direction = arg_zero_direction;
    _ = &zero_direction;
    var dead_zone_degrees = arg_dead_zone_degrees;
    _ = &dead_zone_degrees;
    var ret: c_int = undefined;
    _ = &ret;
    var value: f32 = @as(f32, @floatFromInt(val.*));
    _ = &value;
    ret = nk_knob_float(ctx, @as(f32, @floatFromInt(min)), &value, @as(f32, @floatFromInt(max)), @as(f32, @floatFromInt(step)), zero_direction, dead_zone_degrees);
    val.* = @as(c_int, @intFromFloat(value));
    return ret;
}
pub fn nk_progress(arg_ctx: [*c]struct_nk_context, arg_cur: [*c]nk_size, arg_max: nk_size, arg_is_modifyable: nk_bool) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var cur = arg_cur;
    _ = &cur;
    var max = arg_max;
    _ = &max;
    var is_modifyable = arg_is_modifyable;
    _ = &is_modifyable;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    var old_value: nk_size = undefined;
    _ = &old_value;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26441))), "nk_bool nk_progress(struct nk_context *, nk_size *, nk_size, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (cur != null) {} else {
                __assert_fail("cur", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26442))), "nk_bool nk_progress(struct nk_context *, nk_size *, nk_size, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26443))), "nk_bool nk_progress(struct nk_context *, nk_size *, nk_size, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26444))), "nk_bool nk_progress(struct nk_context *, nk_size *, nk_size, nk_bool)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(cur != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    old_value = cur.*;
    cur.* = nk_do_progress(&ctx.*.last_widget_state, &win.*.buffer, bounds, cur.*, max, is_modifyable, &style.*.progress, in);
    return @intFromBool(cur.* != old_value);
}
pub fn nk_prog(arg_ctx: [*c]struct_nk_context, arg_cur: nk_size, arg_max: nk_size, arg_modifyable: nk_bool) callconv(.c) nk_size {
    var ctx = arg_ctx;
    _ = &ctx;
    var cur = arg_cur;
    _ = &cur;
    var max = arg_max;
    _ = &max;
    var modifyable = arg_modifyable;
    _ = &modifyable;
    _ = nk_progress(ctx, &cur, max, modifyable);
    return cur;
}
pub fn nk_color_picker(arg_ctx: [*c]struct_nk_context, arg_color: struct_nk_colorf, arg_fmt: enum_nk_color_format) callconv(.c) struct_nk_colorf {
    var ctx = arg_ctx;
    _ = &ctx;
    var color = arg_color;
    _ = &color;
    var fmt = arg_fmt;
    _ = &fmt;
    _ = nk_color_pick(ctx, &color, fmt);
    return color;
}
pub fn nk_color_pick(arg_ctx: [*c]struct_nk_context, arg_color: [*c]struct_nk_colorf, arg_fmt: enum_nk_color_format) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var color = arg_color;
    _ = &color;
    var fmt = arg_fmt;
    _ = &fmt;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var config: [*c]const struct_nk_style = undefined;
    _ = &config;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29679))), "nk_bool nk_color_pick(struct nk_context *, struct nk_colorf *, enum nk_color_format)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (color != null) {} else {
                __assert_fail("color", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29680))), "nk_bool nk_color_pick(struct nk_context *, struct nk_colorf *, enum nk_color_format)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29681))), "nk_bool nk_color_pick(struct nk_context *, struct nk_colorf *, enum nk_color_format)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29682))), "nk_bool nk_color_pick(struct nk_context *, struct nk_colorf *, enum nk_color_format)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(color != null)) return 0;
    win = ctx.*.current;
    config = &ctx.*.style;
    layout = win.*.layout;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return 0;
    in = if (((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    return nk_do_color_picker(&ctx.*.last_widget_state, &win.*.buffer, color, fmt, bounds, nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0)))), in, config.*.font);
}
pub const NK_PROPERTY_INT: c_int = 0;
pub const NK_PROPERTY_FLOAT: c_int = 1;
pub const NK_PROPERTY_DOUBLE: c_int = 2;
pub const enum_nk_property_kind = c_uint;
pub const union_nk_property = extern union {
    i: c_int,
    f: f32,
    d: f64,
};
pub const struct_nk_property_variant = extern struct {
    kind: enum_nk_property_kind = @import("std").mem.zeroes(enum_nk_property_kind),
    value: union_nk_property = @import("std").mem.zeroes(union_nk_property),
    min_value: union_nk_property = @import("std").mem.zeroes(union_nk_property),
    max_value: union_nk_property = @import("std").mem.zeroes(union_nk_property),
    step: union_nk_property = @import("std").mem.zeroes(union_nk_property),
};
pub fn nk_property_int(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_min: c_int, arg_val: [*c]c_int, arg_max: c_int, arg_step: c_int, arg_inc_per_pixel: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    var variant: struct_nk_property_variant = undefined;
    _ = &variant;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29085))), "void nk_property_int(struct nk_context *, const char *, int, int *, int, int, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (name != null) {} else {
                __assert_fail("name", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29086))), "void nk_property_int(struct nk_context *, const char *, int, int *, int, int, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (val != null) {} else {
                __assert_fail("val", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29087))), "void nk_property_int(struct nk_context *, const char *, int, int *, int, int, float)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(name != null)) or !(val != null)) return;
    variant = nk_property_variant_int(val.*, min, max, step);
    nk_property(ctx, name, &variant, inc_per_pixel, @as(c_uint, @bitCast(NK_FILTER_INT)));
    val.* = variant.value.i;
}
pub fn nk_property_float(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_min: f32, arg_val: [*c]f32, arg_max: f32, arg_step: f32, arg_inc_per_pixel: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    var variant: struct_nk_property_variant = undefined;
    _ = &variant;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29099))), "void nk_property_float(struct nk_context *, const char *, float, float *, float, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (name != null) {} else {
                __assert_fail("name", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29100))), "void nk_property_float(struct nk_context *, const char *, float, float *, float, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (val != null) {} else {
                __assert_fail("val", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29101))), "void nk_property_float(struct nk_context *, const char *, float, float *, float, float, float)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(name != null)) or !(val != null)) return;
    variant = nk_property_variant_float(val.*, min, max, step);
    nk_property(ctx, name, &variant, inc_per_pixel, @as(c_uint, @bitCast(NK_FILTER_FLOAT)));
    val.* = variant.value.f;
}
pub fn nk_property_double(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_min: f64, arg_val: [*c]f64, arg_max: f64, arg_step: f64, arg_inc_per_pixel: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    var variant: struct_nk_property_variant = undefined;
    _ = &variant;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29113))), "void nk_property_double(struct nk_context *, const char *, double, double *, double, double, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (name != null) {} else {
                __assert_fail("name", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29114))), "void nk_property_double(struct nk_context *, const char *, double, double *, double, double, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (val != null) {} else {
                __assert_fail("val", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29115))), "void nk_property_double(struct nk_context *, const char *, double, double *, double, double, float)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(name != null)) or !(val != null)) return;
    variant = nk_property_variant_double(val.*, min, max, step);
    nk_property(ctx, name, &variant, inc_per_pixel, @as(c_uint, @bitCast(NK_FILTER_FLOAT)));
    val.* = variant.value.d;
}
pub fn nk_propertyi(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_min: c_int, arg_val: c_int, arg_max: c_int, arg_step: c_int, arg_inc_per_pixel: f32) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    var variant: struct_nk_property_variant = undefined;
    _ = &variant;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29127))), "int nk_propertyi(struct nk_context *, const char *, int, int, int, int, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (name != null) {} else {
                __assert_fail("name", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29128))), "int nk_propertyi(struct nk_context *, const char *, int, int, int, int, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(name != null)) return val;
    variant = nk_property_variant_int(val, min, max, step);
    nk_property(ctx, name, &variant, inc_per_pixel, @as(c_uint, @bitCast(NK_FILTER_INT)));
    val = variant.value.i;
    return val;
}
pub fn nk_propertyf(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_min: f32, arg_val: f32, arg_max: f32, arg_step: f32, arg_inc_per_pixel: f32) callconv(.c) f32 {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    var variant: struct_nk_property_variant = undefined;
    _ = &variant;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29141))), "float nk_propertyf(struct nk_context *, const char *, float, float, float, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (name != null) {} else {
                __assert_fail("name", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29142))), "float nk_propertyf(struct nk_context *, const char *, float, float, float, float, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(name != null)) return val;
    variant = nk_property_variant_float(val, min, max, step);
    nk_property(ctx, name, &variant, inc_per_pixel, @as(c_uint, @bitCast(NK_FILTER_FLOAT)));
    val = variant.value.f;
    return val;
}
pub fn nk_propertyd(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_min: f64, arg_val: f64, arg_max: f64, arg_step: f64, arg_inc_per_pixel: f32) callconv(.c) f64 {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    var variant: struct_nk_property_variant = undefined;
    _ = &variant;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29155))), "double nk_propertyd(struct nk_context *, const char *, double, double, double, double, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (name != null) {} else {
                __assert_fail("name", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29156))), "double nk_propertyd(struct nk_context *, const char *, double, double, double, double, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(name != null)) return val;
    variant = nk_property_variant_double(val, min, max, step);
    nk_property(ctx, name, &variant, inc_per_pixel, @as(c_uint, @bitCast(NK_FILTER_FLOAT)));
    val = variant.value.d;
    return val;
}
pub const NK_EDIT_DEFAULT: c_int = 0;
pub const NK_EDIT_READ_ONLY: c_int = 1;
pub const NK_EDIT_AUTO_SELECT: c_int = 2;
pub const NK_EDIT_SIG_ENTER: c_int = 4;
pub const NK_EDIT_ALLOW_TAB: c_int = 8;
pub const NK_EDIT_NO_CURSOR: c_int = 16;
pub const NK_EDIT_SELECTABLE: c_int = 32;
pub const NK_EDIT_CLIPBOARD: c_int = 64;
pub const NK_EDIT_CTRL_ENTER_NEWLINE: c_int = 128;
pub const NK_EDIT_NO_HORIZONTAL_SCROLL: c_int = 256;
pub const NK_EDIT_ALWAYS_INSERT_MODE: c_int = 512;
pub const NK_EDIT_MULTILINE: c_int = 1024;
pub const NK_EDIT_GOTO_END_ON_ACTIVATE: c_int = 2048;
pub const enum_nk_edit_flags = c_uint;
pub const NK_EDIT_SIMPLE: c_int = 512;
pub const NK_EDIT_FIELD: c_int = 608;
pub const NK_EDIT_BOX: c_int = 1640;
pub const NK_EDIT_EDITOR: c_int = 1128;
pub const enum_nk_edit_types = c_uint;
pub const NK_EDIT_ACTIVE: c_int = 1;
pub const NK_EDIT_INACTIVE: c_int = 2;
pub const NK_EDIT_ACTIVATED: c_int = 4;
pub const NK_EDIT_DEACTIVATED: c_int = 8;
pub const NK_EDIT_COMMITED: c_int = 16;
pub const enum_nk_edit_events = c_uint;
pub fn nk_edit_string(arg_ctx: [*c]struct_nk_context, arg_flags: nk_flags, arg_memory: [*c]u8, arg_len: [*c]c_int, arg_max: c_int, arg_filter: nk_plugin_filter) callconv(.c) nk_flags {
    var ctx = arg_ctx;
    _ = &ctx;
    var flags = arg_flags;
    _ = &flags;
    var memory = arg_memory;
    _ = &memory;
    var len = arg_len;
    _ = &len;
    var max = arg_max;
    _ = &max;
    var filter = arg_filter;
    _ = &filter;
    var hash: nk_hash = undefined;
    _ = &hash;
    var state: nk_flags = undefined;
    _ = &state;
    var edit: [*c]struct_nk_text_edit = undefined;
    _ = &edit;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28534))), "nk_flags nk_edit_string(struct nk_context *, nk_flags, char *, int *, int, nk_plugin_filter)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (memory != null) {} else {
                __assert_fail("memory", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28535))), "nk_flags nk_edit_string(struct nk_context *, nk_flags, char *, int *, int, nk_plugin_filter)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len != null) {} else {
                __assert_fail("len", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28536))), "nk_flags nk_edit_string(struct nk_context *, nk_flags, char *, int *, int, nk_plugin_filter)");
            };
        };
    };
    if ((!(ctx != null) or !(memory != null)) or !(len != null)) return 0;
    filter = if (!(filter != null)) &nk_filter_default else filter;
    win = ctx.*.current;
    hash = win.*.edit.seq;
    edit = &ctx.*.text_edit;
    nk_textedit_clear_state(&ctx.*.text_edit, @as(c_uint, @bitCast(if ((flags & @as(nk_flags, @bitCast(NK_EDIT_MULTILINE))) != 0) NK_TEXT_EDIT_MULTI_LINE else NK_TEXT_EDIT_SINGLE_LINE)), filter);
    if ((win.*.edit.active != 0) and (hash == win.*.edit.name)) {
        if ((flags & @as(nk_flags, @bitCast(NK_EDIT_NO_CURSOR))) != 0) {
            edit.*.cursor = nk_utf_len(memory, len.*);
        } else {
            edit.*.cursor = win.*.edit.cursor;
        }
        if (!((flags & @as(nk_flags, @bitCast(NK_EDIT_SELECTABLE))) != 0)) {
            edit.*.select_start = win.*.edit.cursor;
            edit.*.select_end = win.*.edit.cursor;
        } else {
            edit.*.select_start = win.*.edit.sel_start;
            edit.*.select_end = win.*.edit.sel_end;
        }
        edit.*.mode = win.*.edit.mode;
        edit.*.scrollbar.x = @as(f32, @floatFromInt(win.*.edit.scrollbar.x));
        edit.*.scrollbar.y = @as(f32, @floatFromInt(win.*.edit.scrollbar.y));
        edit.*.active = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
    } else {
        edit.*.active = @as(u8, @bitCast(@as(i8, @truncate(nk_false))));
    }
    max = if (@as(c_int, 1) < max) max else @as(c_int, 1);
    len.* = if (len.* < (max - @as(c_int, 1))) len.* else max - @as(c_int, 1);
    nk_str_init_fixed(&edit.*.string, @as(?*anyopaque, @ptrCast(memory)), @as(nk_size, @bitCast(@as(c_long, max))));
    edit.*.string.buffer.allocated = @as(nk_size, @bitCast(@as(c_long, len.*)));
    edit.*.string.len = nk_utf_len(memory, len.*);
    state = nk_edit_buffer(ctx, flags, edit, filter);
    len.* = @as(c_int, @bitCast(@as(c_uint, @truncate(edit.*.string.buffer.allocated))));
    if (edit.*.active != 0) {
        win.*.edit.cursor = edit.*.cursor;
        win.*.edit.sel_start = edit.*.select_start;
        win.*.edit.sel_end = edit.*.select_end;
        win.*.edit.mode = edit.*.mode;
        win.*.edit.scrollbar.x = @as(nk_uint, @intFromFloat(edit.*.scrollbar.x));
        win.*.edit.scrollbar.y = @as(nk_uint, @intFromFloat(edit.*.scrollbar.y));
    }
    return state;
}
pub fn nk_edit_string_zero_terminated(arg_ctx: [*c]struct_nk_context, arg_flags: nk_flags, arg_buffer: [*c]u8, arg_max: c_int, arg_filter: nk_plugin_filter) callconv(.c) nk_flags {
    var ctx = arg_ctx;
    _ = &ctx;
    var flags = arg_flags;
    _ = &flags;
    var buffer = arg_buffer;
    _ = &buffer;
    var max = arg_max;
    _ = &max;
    var filter = arg_filter;
    _ = &filter;
    var result: nk_flags = undefined;
    _ = &result;
    var len: c_int = nk_strlen(buffer);
    _ = &len;
    result = nk_edit_string(ctx, flags, buffer, &len, max, filter);
    (blk: {
        const tmp = if ((if ((max - @as(c_int, 1)) < @as(c_int, 0)) @as(c_int, 0) else max - @as(c_int, 1)) < len) if ((max - @as(c_int, 1)) < @as(c_int, 0)) @as(c_int, 0) else max - @as(c_int, 1) else len;
        if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = '\x00';
    return result;
}
pub fn nk_edit_buffer(arg_ctx: [*c]struct_nk_context, arg_flags: nk_flags, arg_edit: [*c]struct_nk_text_edit, arg_filter: nk_plugin_filter) callconv(.c) nk_flags {
    var ctx = arg_ctx;
    _ = &ctx;
    var flags = arg_flags;
    _ = &flags;
    var edit = arg_edit;
    _ = &edit;
    var filter = arg_filter;
    _ = &filter;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var ret_flags: nk_flags = 0;
    _ = &ret_flags;
    var prev_state: u8 = undefined;
    _ = &prev_state;
    var hash: nk_hash = undefined;
    _ = &hash;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28597))), "nk_flags nk_edit_buffer(struct nk_context *, nk_flags, struct nk_text_edit *, nk_plugin_filter)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (edit != null) {} else {
                __assert_fail("edit", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28598))), "nk_flags nk_edit_buffer(struct nk_context *, nk_flags, struct nk_text_edit *, nk_plugin_filter)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28599))), "nk_flags nk_edit_buffer(struct nk_context *, nk_flags, struct nk_text_edit *, nk_plugin_filter)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28600))), "nk_flags nk_edit_buffer(struct nk_context *, nk_flags, struct nk_text_edit *, nk_plugin_filter)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    state = nk_widget(&bounds, ctx);
    if (!(state != 0)) return @as(nk_flags, @bitCast(state)) else if (state == @as(c_uint, @bitCast(NK_WIDGET_DISABLED))) {
        flags |= @as(nk_flags, @bitCast(NK_EDIT_READ_ONLY));
    }
    in = if ((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) null else &ctx.*.input;
    hash = blk: {
        const ref = &win.*.edit.seq;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    };
    if ((win.*.edit.active != 0) and (hash == win.*.edit.name)) {
        if ((flags & @as(nk_flags, @bitCast(NK_EDIT_NO_CURSOR))) != 0) {
            edit.*.cursor = edit.*.string.len;
        }
        if (!((flags & @as(nk_flags, @bitCast(NK_EDIT_SELECTABLE))) != 0)) {
            edit.*.select_start = edit.*.cursor;
            edit.*.select_end = edit.*.cursor;
        }
        if ((flags & @as(nk_flags, @bitCast(NK_EDIT_CLIPBOARD))) != 0) {
            edit.*.clip = ctx.*.clip;
        }
        edit.*.active = @as(u8, @bitCast(@as(i8, @truncate(win.*.edit.active))));
    } else {
        edit.*.active = @as(u8, @bitCast(@as(i8, @truncate(nk_false))));
    }
    edit.*.mode = win.*.edit.mode;
    filter = if (!(filter != null)) &nk_filter_default else filter;
    prev_state = edit.*.active;
    in = if ((flags & @as(nk_flags, @bitCast(NK_EDIT_READ_ONLY))) != 0) null else in;
    ret_flags = nk_do_edit(&ctx.*.last_widget_state, &win.*.buffer, bounds, flags, filter, edit, &style.*.edit, in, style.*.font);
    if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        ctx.*.style.cursor_active = ctx.*.style.cursors[@as(c_uint, @intCast(NK_CURSOR_TEXT))];
    }
    if ((@as(c_int, @bitCast(@as(c_uint, edit.*.active))) != 0) and (@as(c_int, @bitCast(@as(c_uint, prev_state))) != @as(c_int, @bitCast(@as(c_uint, edit.*.active))))) {
        win.*.edit.active = nk_true;
        win.*.edit.name = hash;
    } else if ((@as(c_int, @bitCast(@as(c_uint, prev_state))) != 0) and !(edit.*.active != 0)) {
        win.*.edit.active = nk_false;
    }
    return ret_flags;
}
pub fn nk_edit_focus(arg_ctx: [*c]struct_nk_context, arg_flags: nk_flags) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var flags = arg_flags;
    _ = &flags;
    var hash: nk_hash = undefined;
    _ = &hash;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28502))), "void nk_edit_focus(struct nk_context *, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28503))), "void nk_edit_focus(struct nk_context *, nk_flags)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    win = ctx.*.current;
    hash = win.*.edit.seq;
    win.*.edit.active = nk_true;
    win.*.edit.name = hash;
    if ((flags & @as(nk_flags, @bitCast(NK_EDIT_ALWAYS_INSERT_MODE))) != 0) {
        win.*.edit.mode = @as(u8, @bitCast(@as(i8, @truncate(NK_TEXT_EDIT_MODE_INSERT))));
    }
}
pub fn nk_edit_unfocus(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28517))), "void nk_edit_unfocus(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28518))), "void nk_edit_unfocus(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    win = ctx.*.current;
    win.*.edit.active = nk_false;
    win.*.edit.name = 0;
}
pub fn nk_chart_begin(arg_ctx: [*c]struct_nk_context, @"type": enum_nk_chart_type, arg_count: c_int, arg_min_value: f32, arg_max_value: f32) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = &@"type";
    var count = arg_count;
    _ = &count;
    var min_value = arg_min_value;
    _ = &min_value;
    var max_value = arg_max_value;
    _ = &max_value;
    return nk_chart_begin_colored(ctx, @"type", ctx.*.style.chart.color, ctx.*.style.chart.selected_color, count, min_value, max_value);
}
pub fn nk_chart_begin_colored(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_chart_type, arg_color: struct_nk_color, arg_highlight: struct_nk_color, arg_count: c_int, arg_min_value: f32, arg_max_value: f32) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var color = arg_color;
    _ = &color;
    var highlight = arg_highlight;
    _ = &highlight;
    var count = arg_count;
    _ = &count;
    var min_value = arg_min_value;
    _ = &min_value;
    var max_value = arg_max_value;
    _ = &max_value;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var chart: [*c]struct_nk_chart = undefined;
    _ = &chart;
    var config: [*c]const struct_nk_style = undefined;
    _ = &config;
    var style: [*c]const struct_nk_style_chart = undefined;
    _ = &style;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var bounds: struct_nk_rect = struct_nk_rect{
        .x = @as(f32, @floatFromInt(@as(c_int, 0))),
        .y = @as(f32, @floatFromInt(@as(c_int, 0))),
        .w = @as(f32, @floatFromInt(@as(c_int, 0))),
        .h = @as(f32, @floatFromInt(@as(c_int, 0))),
    };
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29187))), "nk_bool nk_chart_begin_colored(struct nk_context *, enum nk_chart_type, struct nk_color, struct nk_color, int, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29188))), "nk_bool nk_chart_begin_colored(struct nk_context *, enum nk_chart_type, struct nk_color, struct nk_color, int, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29189))), "nk_bool nk_chart_begin_colored(struct nk_context *, enum nk_chart_type, struct nk_color, struct nk_color, int, float, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    if (!(nk_widget(&bounds, ctx) != 0)) {
        chart = &ctx.*.current.*.layout.*.chart;
        nk_zero(@as(?*anyopaque, @ptrCast(chart)), @sizeOf(struct_nk_chart));
        return 0;
    }
    win = ctx.*.current;
    config = &ctx.*.style;
    chart = &win.*.layout.*.chart;
    style = &config.*.chart;
    nk_zero(@as(?*anyopaque, @ptrCast(chart)), @sizeOf(struct_nk_chart));
    chart.*.x = bounds.x + style.*.padding.x;
    chart.*.y = bounds.y + style.*.padding.y;
    chart.*.w = bounds.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x);
    chart.*.h = bounds.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y);
    chart.*.w = if (chart.*.w < (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x)) @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x else chart.*.w;
    chart.*.h = if (chart.*.h < (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y)) @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y else chart.*.h;
    {
        var slot: [*c]struct_nk_chart_slot = &chart.*.slots[@as(c_uint, @intCast(blk: {
            const ref = &chart.*.slot;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }))];
        _ = &slot;
        slot.*.type = @"type";
        slot.*.count = count;
        slot.*.color = nk_rgb_factor(color, style.*.color_factor);
        slot.*.highlight = highlight;
        slot.*.min = if (min_value < max_value) min_value else max_value;
        slot.*.max = if (min_value < max_value) max_value else min_value;
        slot.*.range = slot.*.max - slot.*.min;
        slot.*.show_markers = style.*.show_markers;
    }
    background = &style.*.background;
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(&win.*.buffer, bounds, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(&win.*.buffer, bounds, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(&win.*.buffer, bounds, style.*.rounding, nk_rgb_factor(style.*.border_color, style.*.color_factor));
                nk_fill_rect(&win.*.buffer, nk_shrink_rect(bounds, style.*.border), style.*.rounding, nk_rgb_factor(style.*.background.data.color, style.*.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    return 1;
}
pub fn nk_chart_add_slot(arg_ctx: [*c]struct_nk_context, @"type": enum_nk_chart_type, arg_count: c_int, arg_min_value: f32, arg_max_value: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = &@"type";
    var count = arg_count;
    _ = &count;
    var min_value = arg_min_value;
    _ = &min_value;
    var max_value = arg_max_value;
    _ = &max_value;
    nk_chart_add_slot_colored(ctx, @"type", ctx.*.style.chart.color, ctx.*.style.chart.selected_color, count, min_value, max_value);
}
pub fn nk_chart_add_slot_colored(arg_ctx: [*c]struct_nk_context, @"type": enum_nk_chart_type, arg_color: struct_nk_color, arg_highlight: struct_nk_color, arg_count: c_int, arg_min_value: f32, arg_max_value: f32) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = &@"type";
    var color = arg_color;
    _ = &color;
    var highlight = arg_highlight;
    _ = &highlight;
    var count = arg_count;
    _ = &count;
    var min_value = arg_min_value;
    _ = &min_value;
    var max_value = arg_max_value;
    _ = &max_value;
    var style: [*c]const struct_nk_style_chart = undefined;
    _ = &style;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29255))), "void nk_chart_add_slot_colored(struct nk_context *, const enum nk_chart_type, struct nk_color, struct nk_color, int, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29256))), "void nk_chart_add_slot_colored(struct nk_context *, const enum nk_chart_type, struct nk_color, struct nk_color, int, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29257))), "void nk_chart_add_slot_colored(struct nk_context *, const enum nk_chart_type, struct nk_color, struct nk_color, int, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout.*.chart.slot < @as(c_int, 4)) {} else {
                __assert_fail("ctx->current->layout->chart.slot < 4", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29258))), "void nk_chart_add_slot_colored(struct nk_context *, const enum nk_chart_type, struct nk_color, struct nk_color, int, float, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    if (ctx.*.current.*.layout.*.chart.slot >= @as(c_int, 4)) return;
    style = &ctx.*.style.chart;
    {
        var chart: [*c]struct_nk_chart = &ctx.*.current.*.layout.*.chart;
        _ = &chart;
        var slot: [*c]struct_nk_chart_slot = &chart.*.slots[@as(c_uint, @intCast(blk: {
            const ref = &chart.*.slot;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }))];
        _ = &slot;
        slot.*.type = @"type";
        slot.*.count = count;
        slot.*.color = nk_rgb_factor(color, style.*.color_factor);
        slot.*.highlight = highlight;
        slot.*.min = if (min_value < max_value) min_value else max_value;
        slot.*.max = if (min_value < max_value) max_value else min_value;
        slot.*.range = slot.*.max - slot.*.min;
        slot.*.show_markers = style.*.show_markers;
    }
}
pub fn nk_chart_push(arg_ctx: [*c]struct_nk_context, arg_value: f32) callconv(.c) nk_flags {
    var ctx = arg_ctx;
    _ = &ctx;
    var value = arg_value;
    _ = &value;
    return nk_chart_push_slot(ctx, value, @as(c_int, 0));
}
pub fn nk_chart_push_slot(arg_ctx: [*c]struct_nk_context, arg_value: f32, arg_slot: c_int) callconv(.c) nk_flags {
    var ctx = arg_ctx;
    _ = &ctx;
    var value = arg_value;
    _ = &value;
    var slot = arg_slot;
    _ = &slot;
    var flags: nk_flags = undefined;
    _ = &flags;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29409))), "nk_flags nk_chart_push_slot(struct nk_context *, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29410))), "nk_flags nk_chart_push_slot(struct nk_context *, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((slot >= @as(c_int, 0)) and (slot < @as(c_int, 4))) {} else {
                __assert_fail("slot >= 0 && slot < 4", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29411))), "nk_flags nk_chart_push_slot(struct nk_context *, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (slot < ctx.*.current.*.layout.*.chart.slot) {} else {
                __assert_fail("slot < ctx->current->layout->chart.slot", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29412))), "nk_flags nk_chart_push_slot(struct nk_context *, float, int)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or (slot >= @as(c_int, 4))) return @as(nk_flags, @bitCast(nk_false));
    if (slot >= ctx.*.current.*.layout.*.chart.slot) return @as(nk_flags, @bitCast(nk_false));
    win = ctx.*.current;
    if (win.*.layout.*.chart.slot < slot) return @as(nk_flags, @bitCast(nk_false));
    while (true) {
        switch (win.*.layout.*.chart.slots[@as(c_uint, @intCast(slot))].type) {
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                flags = nk_chart_push_line(ctx, win, &win.*.layout.*.chart, value, slot);
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                flags = nk_chart_push_column(ctx, win, &win.*.layout.*.chart, value, slot);
                break;
            },
            else => {
                flags = 0;
            },
        }
        break;
    }
    return flags;
}
pub fn nk_chart_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var chart: [*c]struct_nk_chart = undefined;
    _ = &chart;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29440))), "void nk_chart_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29441))), "void nk_chart_end(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    win = ctx.*.current;
    chart = &win.*.layout.*.chart;
    nk_memset(@as(?*anyopaque, @ptrCast(chart)), @as(c_int, 0), @sizeOf(struct_nk_chart));
    return;
}
pub fn nk_plot(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_chart_type, arg_values: [*c]const f32, arg_count: c_int, arg_offset: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var values = arg_values;
    _ = &values;
    var count = arg_count;
    _ = &count;
    var offset = arg_offset;
    _ = &offset;
    var i: c_int = 0;
    _ = &i;
    var min_value: f32 = undefined;
    _ = &min_value;
    var max_value: f32 = undefined;
    _ = &max_value;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29458))), "void nk_plot(struct nk_context *, enum nk_chart_type, const float *, int, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (values != null) {} else {
                __assert_fail("values", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29459))), "void nk_plot(struct nk_context *, enum nk_chart_type, const float *, int, int)");
            };
        };
    };
    if ((!(ctx != null) or !(values != null)) or !(count != 0)) return;
    min_value = (blk: {
        const tmp = offset;
        if (tmp >= 0) break :blk values + @as(usize, @intCast(tmp)) else break :blk values - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    max_value = (blk: {
        const tmp = offset;
        if (tmp >= 0) break :blk values + @as(usize, @intCast(tmp)) else break :blk values - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    {
        i = 0;
        while (i < count) : (i += 1) {
            min_value = if ((blk: {
                const tmp = i + offset;
                if (tmp >= 0) break :blk values + @as(usize, @intCast(tmp)) else break :blk values - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* < min_value) (blk: {
                const tmp = i + offset;
                if (tmp >= 0) break :blk values + @as(usize, @intCast(tmp)) else break :blk values - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* else min_value;
            max_value = if ((blk: {
                const tmp = i + offset;
                if (tmp >= 0) break :blk values + @as(usize, @intCast(tmp)) else break :blk values - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* < max_value) max_value else (blk: {
                const tmp = i + offset;
                if (tmp >= 0) break :blk values + @as(usize, @intCast(tmp)) else break :blk values - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    if (nk_chart_begin(ctx, @"type", count, min_value, max_value) != 0) {
        {
            i = 0;
            while (i < count) : (i += 1) {
                _ = nk_chart_push(ctx, (blk: {
                    const tmp = i + offset;
                    if (tmp >= 0) break :blk values + @as(usize, @intCast(tmp)) else break :blk values - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*);
            }
        }
        nk_chart_end(ctx);
    }
}
pub fn nk_plot_function(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_chart_type, arg_userdata: ?*anyopaque, arg_value_getter: ?*const fn (?*anyopaque, c_int) callconv(.c) f32, arg_count: c_int, arg_offset: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var userdata = arg_userdata;
    _ = &userdata;
    var value_getter = arg_value_getter;
    _ = &value_getter;
    var count = arg_count;
    _ = &count;
    var offset = arg_offset;
    _ = &offset;
    var i: c_int = 0;
    _ = &i;
    var min_value: f32 = undefined;
    _ = &min_value;
    var max_value: f32 = undefined;
    _ = &max_value;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29483))), "void nk_plot_function(struct nk_context *, enum nk_chart_type, void *, float (*)(void *, int), int, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (value_getter != null) {} else {
                __assert_fail("value_getter", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29484))), "void nk_plot_function(struct nk_context *, enum nk_chart_type, void *, float (*)(void *, int), int, int)");
            };
        };
    };
    if ((!(ctx != null) or !(value_getter != null)) or !(count != 0)) return;
    max_value = blk: {
        const tmp = value_getter.?(userdata, offset);
        min_value = tmp;
        break :blk tmp;
    };
    {
        i = 0;
        while (i < count) : (i += 1) {
            var value: f32 = value_getter.?(userdata, i + offset);
            _ = &value;
            min_value = if (value < min_value) value else min_value;
            max_value = if (value < max_value) max_value else value;
        }
    }
    if (nk_chart_begin(ctx, @"type", count, min_value, max_value) != 0) {
        {
            i = 0;
            while (i < count) : (i += 1) {
                _ = nk_chart_push(ctx, value_getter.?(userdata, i + offset));
            }
        }
        nk_chart_end(ctx);
    }
}
pub fn nk_popup_begin(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_popup_type, arg_title: [*c]const u8, arg_flags: nk_flags, arg_rect: struct_nk_rect) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var title = arg_title;
    _ = &title;
    var flags = arg_flags;
    _ = &flags;
    var rect = arg_rect;
    _ = &rect;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var panel: [*c]struct_nk_panel = undefined;
    _ = &panel;
    var title_len: c_int = undefined;
    _ = &title_len;
    var title_hash: nk_hash = undefined;
    _ = &title_hash;
    var allocated: nk_size = undefined;
    _ = &allocated;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21219))), "nk_bool nk_popup_begin(struct nk_context *, enum nk_popup_type, const char *, nk_flags, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (title != null) {} else {
                __assert_fail("title", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21220))), "nk_bool nk_popup_begin(struct nk_context *, enum nk_popup_type, const char *, nk_flags, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21221))), "nk_bool nk_popup_begin(struct nk_context *, enum nk_popup_type, const char *, nk_flags, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21222))), "nk_bool nk_popup_begin(struct nk_context *, enum nk_popup_type, const char *, nk_flags, struct nk_rect)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    panel = win.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!((@as(c_int, @bitCast(panel.*.type)) & NK_PANEL_SET_POPUP) != 0) and (@intFromPtr("popups are not allowed to have popups") != 0)) {} else {
                __assert_fail("!((int)panel->type & (int)NK_PANEL_SET_POPUP) && \"popups are not allowed to have popups\"", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21228))), "nk_bool nk_popup_begin(struct nk_context *, enum nk_popup_type, const char *, nk_flags, struct nk_rect)");
            };
        };
    };
    _ = &panel;
    title_len = nk_strlen(title);
    title_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(title)), title_len, @as(nk_hash, @bitCast(NK_PANEL_POPUP)));
    popup = win.*.popup.win;
    if (!(popup != null)) {
        popup = @as([*c]struct_nk_window, @ptrCast(@alignCast(nk_create_window(ctx))));
        popup.*.parent = win;
        win.*.popup.win = popup;
        win.*.popup.active = 0;
        win.*.popup.type = @as(c_uint, @bitCast(NK_PANEL_POPUP));
    }
    if (win.*.popup.name != title_hash) {
        if (!(win.*.popup.active != 0)) {
            nk_zero(@as(?*anyopaque, @ptrCast(popup)), @sizeOf(struct_nk_window));
            win.*.popup.name = title_hash;
            win.*.popup.active = 1;
            win.*.popup.type = @as(c_uint, @bitCast(NK_PANEL_POPUP));
        } else return 0;
    }
    ctx.*.current = popup;
    rect.x += win.*.layout.*.clip.x;
    rect.y += win.*.layout.*.clip.y;
    popup.*.parent = win;
    popup.*.bounds = rect;
    popup.*.seq = ctx.*.seq;
    popup.*.layout = @as([*c]struct_nk_panel, @ptrCast(@alignCast(nk_create_panel(ctx))));
    popup.*.flags = flags;
    popup.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_BORDER));
    if (@"type" == @as(c_uint, @bitCast(NK_POPUP_DYNAMIC))) {
        popup.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_DYNAMIC));
    }
    popup.*.buffer = win.*.buffer;
    nk_start_popup(ctx, win);
    allocated = ctx.*.memory.allocated;
    nk_push_scissor(&popup.*.buffer, nk_null_rect);
    if (nk_panel_begin(ctx, title, @as(c_uint, @bitCast(NK_PANEL_POPUP))) != 0) {
        var root: [*c]struct_nk_panel = undefined;
        _ = &root;
        root = win.*.layout;
        while (root != null) {
            root.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_ROM));
            root.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_REMOVE_ROM));
            root = root.*.parent;
        }
        win.*.popup.active = 1;
        popup.*.layout.*.offset_x = &popup.*.scrollbar.x;
        popup.*.layout.*.offset_y = &popup.*.scrollbar.y;
        popup.*.layout.*.parent = win.*.layout;
        return 1;
    } else {
        var root: [*c]struct_nk_panel = undefined;
        _ = &root;
        root = win.*.layout;
        while (root != null) {
            root.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_REMOVE_ROM));
            root = root.*.parent;
        }
        win.*.popup.buf.active = 0;
        win.*.popup.active = 0;
        ctx.*.memory.allocated = allocated;
        ctx.*.current = win;
        nk_free_panel(ctx, popup.*.layout);
        popup.*.layout = null;
        return 0;
    }
    return @import("std").mem.zeroes(nk_bool);
}
pub fn nk_popup_close(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21390))), "void nk_popup_close(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    popup = ctx.*.current;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (popup.*.parent != null) {} else {
                __assert_fail("popup->parent", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21394))), "void nk_popup_close(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((@as(c_int, @bitCast(popup.*.layout.*.type)) & NK_PANEL_SET_POPUP) != 0) {} else {
                __assert_fail("(int)popup->layout->type & (int)NK_PANEL_SET_POPUP", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21395))), "void nk_popup_close(struct nk_context *)");
            };
        };
    };
    popup.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN));
}
pub fn nk_popup_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21404))), "void nk_popup_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21405))), "void nk_popup_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21406))), "void nk_popup_end(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    popup = ctx.*.current;
    if (!(popup.*.parent != null)) return;
    win = popup.*.parent;
    if ((popup.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) {
        var root: [*c]struct_nk_panel = undefined;
        _ = &root;
        root = win.*.layout;
        while (root != null) {
            root.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_REMOVE_ROM));
            root = root.*.parent;
        }
        win.*.popup.active = 0;
    }
    nk_push_scissor(&popup.*.buffer, nk_null_rect);
    nk_end(ctx);
    win.*.buffer = popup.*.buffer;
    nk_finish_popup(ctx, win);
    ctx.*.current = win;
    nk_push_scissor(&win.*.buffer, win.*.layout.*.clip);
}
pub fn nk_popup_get_scroll(arg_ctx: [*c]const struct_nk_context, arg_offset_x: [*c]nk_uint, arg_offset_y: [*c]nk_uint) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var offset_x = arg_offset_x;
    _ = &offset_x;
    var offset_y = arg_offset_y;
    _ = &offset_y;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21435))), "void nk_popup_get_scroll(const struct nk_context *, nk_uint *, nk_uint *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21436))), "void nk_popup_get_scroll(const struct nk_context *, nk_uint *, nk_uint *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21437))), "void nk_popup_get_scroll(const struct nk_context *, nk_uint *, nk_uint *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    popup = ctx.*.current;
    if (offset_x != null) {
        offset_x.* = popup.*.scrollbar.x;
    }
    if (offset_y != null) {
        offset_y.* = popup.*.scrollbar.y;
    }
}
pub fn nk_popup_set_scroll(arg_ctx: [*c]struct_nk_context, arg_offset_x: nk_uint, arg_offset_y: nk_uint) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var offset_x = arg_offset_x;
    _ = &offset_x;
    var offset_y = arg_offset_y;
    _ = &offset_y;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21452))), "void nk_popup_set_scroll(struct nk_context *, nk_uint, nk_uint)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21453))), "void nk_popup_set_scroll(struct nk_context *, nk_uint, nk_uint)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21454))), "void nk_popup_set_scroll(struct nk_context *, nk_uint, nk_uint)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    popup = ctx.*.current;
    popup.*.scrollbar.x = offset_x;
    popup.*.scrollbar.y = offset_y;
}
pub fn nk_combo(arg_ctx: [*c]struct_nk_context, arg_items: [*c]const [*c]const u8, arg_count: c_int, arg_selected: c_int, arg_item_height: c_int, arg_size: struct_nk_vec2) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var items = arg_items;
    _ = &items;
    var count = arg_count;
    _ = &count;
    var selected = arg_selected;
    _ = &selected;
    var item_height = arg_item_height;
    _ = &item_height;
    var size = arg_size;
    _ = &size;
    var i: c_int = 0;
    _ = &i;
    var max_height: c_int = undefined;
    _ = &max_height;
    var item_spacing: struct_nk_vec2 = undefined;
    _ = &item_spacing;
    var window_padding: struct_nk_vec2 = undefined;
    _ = &window_padding;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30416))), "int nk_combo(struct nk_context *, const char *const *, int, int, int, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (items != null) {} else {
                __assert_fail("items", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30417))), "int nk_combo(struct nk_context *, const char *const *, int, int, int, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30418))), "int nk_combo(struct nk_context *, const char *const *, int, int, int, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(items != null)) or !(count != 0)) return selected;
    item_spacing = ctx.*.style.window.spacing;
    window_padding = nk_panel_get_padding(&ctx.*.style, ctx.*.current.*.layout.*.type);
    max_height = (count * item_height) + (count * @as(c_int, @intFromFloat(item_spacing.y)));
    max_height += (@as(c_int, @intFromFloat(item_spacing.y)) * @as(c_int, 2)) + (@as(c_int, @intFromFloat(window_padding.y)) * @as(c_int, 2));
    size.y = if (size.y < @as(f32, @floatFromInt(max_height))) size.y else @as(f32, @floatFromInt(max_height));
    if (nk_combo_begin_label(ctx, (blk: {
        const tmp = selected;
        if (tmp >= 0) break :blk items + @as(usize, @intCast(tmp)) else break :blk items - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*, size) != 0) {
        nk_layout_row_dynamic(ctx, @as(f32, @floatFromInt(item_height)), @as(c_int, 1));
        {
            i = 0;
            while (i < count) : (i += 1) {
                if (nk_combo_item_label(ctx, (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk items + @as(usize, @intCast(tmp)) else break :blk items - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*, @as(nk_flags, @bitCast(NK_TEXT_LEFT))) != 0) {
                    selected = i;
                }
            }
        }
        nk_combo_end(ctx);
    }
    return selected;
}
pub fn nk_combo_separator(arg_ctx: [*c]struct_nk_context, arg_items_separated_by_separator: [*c]const u8, arg_separator: c_int, arg_selected: c_int, arg_count: c_int, arg_item_height: c_int, arg_size: struct_nk_vec2) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var items_separated_by_separator = arg_items_separated_by_separator;
    _ = &items_separated_by_separator;
    var separator = arg_separator;
    _ = &separator;
    var selected = arg_selected;
    _ = &selected;
    var count = arg_count;
    _ = &count;
    var item_height = arg_item_height;
    _ = &item_height;
    var size = arg_size;
    _ = &size;
    var i: c_int = undefined;
    _ = &i;
    var max_height: c_int = undefined;
    _ = &max_height;
    var item_spacing: struct_nk_vec2 = undefined;
    _ = &item_spacing;
    var window_padding: struct_nk_vec2 = undefined;
    _ = &window_padding;
    var current_item: [*c]const u8 = undefined;
    _ = &current_item;
    var iter: [*c]const u8 = undefined;
    _ = &iter;
    var length: c_int = 0;
    _ = &length;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30449))), "int nk_combo_separator(struct nk_context *, const char *, int, int, int, int, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (items_separated_by_separator != null) {} else {
                __assert_fail("items_separated_by_separator", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30450))), "int nk_combo_separator(struct nk_context *, const char *, int, int, int, int, struct nk_vec2)");
            };
        };
    };
    if (!(ctx != null) or !(items_separated_by_separator != null)) return selected;
    item_spacing = ctx.*.style.window.spacing;
    window_padding = nk_panel_get_padding(&ctx.*.style, ctx.*.current.*.layout.*.type);
    max_height = (count * item_height) + (count * @as(c_int, @intFromFloat(item_spacing.y)));
    max_height += (@as(c_int, @intFromFloat(item_spacing.y)) * @as(c_int, 2)) + (@as(c_int, @intFromFloat(window_padding.y)) * @as(c_int, 2));
    size.y = if (size.y < @as(f32, @floatFromInt(max_height))) size.y else @as(f32, @floatFromInt(max_height));
    current_item = items_separated_by_separator;
    {
        i = 0;
        while (i < count) : (i += 1) {
            iter = current_item;
            while ((@as(c_int, @bitCast(@as(c_uint, iter.*))) != 0) and (@as(c_int, @bitCast(@as(c_uint, iter.*))) != separator)) {
                iter += 1;
            }
            length = @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(iter) -% @intFromPtr(current_item))), @sizeOf(u8))))));
            if (i == selected) break;
            current_item = iter + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))));
        }
    }
    if (nk_combo_begin_text(ctx, current_item, length, size) != 0) {
        current_item = items_separated_by_separator;
        nk_layout_row_dynamic(ctx, @as(f32, @floatFromInt(item_height)), @as(c_int, 1));
        {
            i = 0;
            while (i < count) : (i += 1) {
                iter = current_item;
                while ((@as(c_int, @bitCast(@as(c_uint, iter.*))) != 0) and (@as(c_int, @bitCast(@as(c_uint, iter.*))) != separator)) {
                    iter += 1;
                }
                length = @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(iter) -% @intFromPtr(current_item))), @sizeOf(u8))))));
                if (nk_combo_item_text(ctx, current_item, length, @as(nk_flags, @bitCast(NK_TEXT_LEFT))) != 0) {
                    selected = i;
                }
                current_item = (current_item + @as(usize, @bitCast(@as(isize, @intCast(length))))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))));
            }
        }
        nk_combo_end(ctx);
    }
    return selected;
}
pub fn nk_combo_string(arg_ctx: [*c]struct_nk_context, arg_items_separated_by_zeros: [*c]const u8, arg_selected: c_int, arg_count: c_int, arg_item_height: c_int, arg_size: struct_nk_vec2) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var items_separated_by_zeros = arg_items_separated_by_zeros;
    _ = &items_separated_by_zeros;
    var selected = arg_selected;
    _ = &selected;
    var count = arg_count;
    _ = &count;
    var item_height = arg_item_height;
    _ = &item_height;
    var size = arg_size;
    _ = &size;
    return nk_combo_separator(ctx, items_separated_by_zeros, @as(c_int, '\x00'), selected, count, item_height, size);
}
pub fn nk_combo_callback(arg_ctx: [*c]struct_nk_context, arg_item_getter: ?*const fn (?*anyopaque, c_int, [*c][*c]const u8) callconv(.c) void, arg_userdata: ?*anyopaque, arg_selected: c_int, arg_count: c_int, arg_item_height: c_int, arg_size: struct_nk_vec2) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var item_getter = arg_item_getter;
    _ = &item_getter;
    var userdata = arg_userdata;
    _ = &userdata;
    var selected = arg_selected;
    _ = &selected;
    var count = arg_count;
    _ = &count;
    var item_height = arg_item_height;
    _ = &item_height;
    var size = arg_size;
    _ = &size;
    var i: c_int = undefined;
    _ = &i;
    var max_height: c_int = undefined;
    _ = &max_height;
    var item_spacing: struct_nk_vec2 = undefined;
    _ = &item_spacing;
    var window_padding: struct_nk_vec2 = undefined;
    _ = &window_padding;
    var item: [*c]const u8 = undefined;
    _ = &item;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30502))), "int nk_combo_callback(struct nk_context *, void (*)(void *, int, const char **), void *, int, int, int, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (item_getter != null) {} else {
                __assert_fail("item_getter", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30503))), "int nk_combo_callback(struct nk_context *, void (*)(void *, int, const char **), void *, int, int, int, struct nk_vec2)");
            };
        };
    };
    if (!(ctx != null) or !(item_getter != null)) return selected;
    item_spacing = ctx.*.style.window.spacing;
    window_padding = nk_panel_get_padding(&ctx.*.style, ctx.*.current.*.layout.*.type);
    max_height = (count * item_height) + (count * @as(c_int, @intFromFloat(item_spacing.y)));
    max_height += (@as(c_int, @intFromFloat(item_spacing.y)) * @as(c_int, 2)) + (@as(c_int, @intFromFloat(window_padding.y)) * @as(c_int, 2));
    size.y = if (size.y < @as(f32, @floatFromInt(max_height))) size.y else @as(f32, @floatFromInt(max_height));
    item_getter.?(userdata, selected, &item);
    if (nk_combo_begin_label(ctx, item, size) != 0) {
        nk_layout_row_dynamic(ctx, @as(f32, @floatFromInt(item_height)), @as(c_int, 1));
        {
            i = 0;
            while (i < count) : (i += 1) {
                item_getter.?(userdata, i, &item);
                if (nk_combo_item_label(ctx, item, @as(nk_flags, @bitCast(NK_TEXT_LEFT))) != 0) {
                    selected = i;
                }
            }
        }
        nk_combo_end(ctx);
    }
    return selected;
}
pub fn nk_combobox(arg_ctx: [*c]struct_nk_context, arg_items: [*c]const [*c]const u8, arg_count: c_int, arg_selected: [*c]c_int, arg_item_height: c_int, arg_size: struct_nk_vec2) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var items = arg_items;
    _ = &items;
    var count = arg_count;
    _ = &count;
    var selected = arg_selected;
    _ = &selected;
    var item_height = arg_item_height;
    _ = &item_height;
    var size = arg_size;
    _ = &size;
    selected.* = nk_combo(ctx, items, count, selected.*, item_height, size);
}
pub fn nk_combobox_string(arg_ctx: [*c]struct_nk_context, arg_items_separated_by_zeros: [*c]const u8, arg_selected: [*c]c_int, arg_count: c_int, arg_item_height: c_int, arg_size: struct_nk_vec2) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var items_separated_by_zeros = arg_items_separated_by_zeros;
    _ = &items_separated_by_zeros;
    var selected = arg_selected;
    _ = &selected;
    var count = arg_count;
    _ = &count;
    var item_height = arg_item_height;
    _ = &item_height;
    var size = arg_size;
    _ = &size;
    selected.* = nk_combo_string(ctx, items_separated_by_zeros, selected.*, count, item_height, size);
}
pub fn nk_combobox_separator(arg_ctx: [*c]struct_nk_context, arg_items_separated_by_separator: [*c]const u8, arg_separator: c_int, arg_selected: [*c]c_int, arg_count: c_int, arg_item_height: c_int, arg_size: struct_nk_vec2) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var items_separated_by_separator = arg_items_separated_by_separator;
    _ = &items_separated_by_separator;
    var separator = arg_separator;
    _ = &separator;
    var selected = arg_selected;
    _ = &selected;
    var count = arg_count;
    _ = &count;
    var item_height = arg_item_height;
    _ = &item_height;
    var size = arg_size;
    _ = &size;
    selected.* = nk_combo_separator(ctx, items_separated_by_separator, separator, selected.*, count, item_height, size);
}
pub fn nk_combobox_callback(arg_ctx: [*c]struct_nk_context, arg_item_getter: ?*const fn (?*anyopaque, c_int, [*c][*c]const u8) callconv(.c) void, arg_userdata: ?*anyopaque, arg_selected: [*c]c_int, arg_count: c_int, arg_item_height: c_int, arg_size: struct_nk_vec2) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var item_getter = arg_item_getter;
    _ = &item_getter;
    var userdata = arg_userdata;
    _ = &userdata;
    var selected = arg_selected;
    _ = &selected;
    var count = arg_count;
    _ = &count;
    var item_height = arg_item_height;
    _ = &item_height;
    var size = arg_size;
    _ = &size;
    selected.* = nk_combo_callback(ctx, item_getter, userdata, selected.*, count, item_height, size);
}
pub fn nk_combo_begin_text(arg_ctx: [*c]struct_nk_context, arg_selected: [*c]const u8, arg_len: c_int, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var selected = arg_selected;
    _ = &selected;
    var len = arg_len;
    _ = &len;
    var size = arg_size;
    _ = &size;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    var s: enum_nk_widget_layout_states = undefined;
    _ = &s;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var text: struct_nk_text = undefined;
    _ = &text;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29760))), "nk_bool nk_combo_begin_text(struct nk_context *, const char *, int, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (selected != null) {} else {
                __assert_fail("selected", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29761))), "nk_bool nk_combo_begin_text(struct nk_context *, const char *, int, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29762))), "nk_bool nk_combo_begin_text(struct nk_context *, const char *, int, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29763))), "nk_bool nk_combo_begin_text(struct nk_context *, const char *, int, struct nk_vec2)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(selected != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    s = nk_widget(&header, ctx);
    if (s == @as(c_uint, @bitCast(NK_WIDGET_INVALID))) return 0;
    in = if ((((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) or (s == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or (s == @as(c_uint, @bitCast(NK_WIDGET_ROM)))) null else &ctx.*.input;
    if (nk_button_behavior(&ctx.*.last_widget_state, header, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        is_clicked = nk_true;
    }
    if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.combo.active;
        text.text = style.*.combo.label_active;
    } else if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.combo.hover;
        text.text = style.*.combo.label_hover;
    } else {
        background = &style.*.combo.normal;
        text.text = style.*.combo.label_normal;
    }
    text.text = nk_rgb_factor(text.text, style.*.combo.color_factor);
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_image(&win.*.buffer, header, &background.*.data.image, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_nine_slice(&win.*.buffer, header, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                text.background = background.*.data.color;
                nk_fill_rect(&win.*.buffer, header, style.*.combo.rounding, nk_rgb_factor(background.*.data.color, style.*.combo.color_factor));
                nk_stroke_rect(&win.*.buffer, header, style.*.combo.rounding, style.*.combo.border, nk_rgb_factor(style.*.combo.border_color, style.*.combo.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    {
        var label: struct_nk_rect = undefined;
        _ = &label;
        var button: struct_nk_rect = undefined;
        _ = &button;
        var content: struct_nk_rect = undefined;
        _ = &content;
        var draw_button_symbol: c_int = undefined;
        _ = &draw_button_symbol;
        var sym: enum_nk_symbol_type = undefined;
        _ = &sym;
        if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
            sym = style.*.combo.sym_hover;
        } else if (is_clicked != 0) {
            sym = style.*.combo.sym_active;
        } else {
            sym = style.*.combo.sym_normal;
        }
        draw_button_symbol = @intFromBool(sym != @as(c_uint, @bitCast(NK_SYMBOL_NONE)));
        button.w = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button_padding.y);
        button.x = ((header.x + header.w) - header.h) - style.*.combo.button_padding.x;
        button.y = header.y + style.*.combo.button_padding.y;
        button.h = button.w;
        content.x = button.x + style.*.combo.button.padding.x;
        content.y = button.y + style.*.combo.button.padding.y;
        content.w = button.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.x);
        content.h = button.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.y);
        text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
        label.x = header.x + style.*.combo.content_padding.x;
        label.y = header.y + style.*.combo.content_padding.y;
        label.h = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.y);
        if (draw_button_symbol != 0) {
            label.w = (button.x - (style.*.combo.content_padding.x + style.*.combo.spacing.x)) - label.x;
        } else {
            label.w = header.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.x);
        }
        nk_widget_text(&win.*.buffer, label, selected, len, &text, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), ctx.*.style.font);
        if (draw_button_symbol != 0) {
            nk_draw_button_symbol(&win.*.buffer, &button, &content, ctx.*.last_widget_state, &ctx.*.style.combo.button, sym, style.*.font);
        }
    }
    return nk_combo_begin(ctx, win, size, is_clicked, header);
}
pub fn nk_combo_begin_label(arg_ctx: [*c]struct_nk_context, arg_selected: [*c]const u8, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var selected = arg_selected;
    _ = &selected;
    var size = arg_size;
    _ = &size;
    return nk_combo_begin_text(ctx, selected, nk_strlen(selected), size);
}
pub fn nk_combo_begin_color(arg_ctx: [*c]struct_nk_context, arg_color: struct_nk_color, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var color = arg_color;
    _ = &color;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var s: enum_nk_widget_layout_states = undefined;
    _ = &s;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29871))), "nk_bool nk_combo_begin_color(struct nk_context *, struct nk_color, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29872))), "nk_bool nk_combo_begin_color(struct nk_context *, struct nk_color, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29873))), "nk_bool nk_combo_begin_color(struct nk_context *, struct nk_color, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    s = nk_widget(&header, ctx);
    if (s == @as(c_uint, @bitCast(NK_WIDGET_INVALID))) return 0;
    in = if ((((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) or (s == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or (s == @as(c_uint, @bitCast(NK_WIDGET_ROM)))) null else &ctx.*.input;
    if (nk_button_behavior(&ctx.*.last_widget_state, header, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        is_clicked = nk_true;
    }
    if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.combo.active;
    } else if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.combo.hover;
    } else {
        background = &style.*.combo.normal;
    }
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(&win.*.buffer, header, &background.*.data.image, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(&win.*.buffer, header, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(&win.*.buffer, header, style.*.combo.rounding, nk_rgb_factor(background.*.data.color, style.*.combo.color_factor));
                nk_stroke_rect(&win.*.buffer, header, style.*.combo.rounding, style.*.combo.border, nk_rgb_factor(style.*.combo.border_color, style.*.combo.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    {
        var content: struct_nk_rect = undefined;
        _ = &content;
        var button: struct_nk_rect = undefined;
        _ = &button;
        var bounds: struct_nk_rect = undefined;
        _ = &bounds;
        var draw_button_symbol: c_int = undefined;
        _ = &draw_button_symbol;
        var sym: enum_nk_symbol_type = undefined;
        _ = &sym;
        if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
            sym = style.*.combo.sym_hover;
        } else if (is_clicked != 0) {
            sym = style.*.combo.sym_active;
        } else {
            sym = style.*.combo.sym_normal;
        }
        draw_button_symbol = @intFromBool(sym != @as(c_uint, @bitCast(NK_SYMBOL_NONE)));
        button.w = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button_padding.y);
        button.x = ((header.x + header.w) - header.h) - style.*.combo.button_padding.x;
        button.y = header.y + style.*.combo.button_padding.y;
        button.h = button.w;
        content.x = button.x + style.*.combo.button.padding.x;
        content.y = button.y + style.*.combo.button.padding.y;
        content.w = button.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.x);
        content.h = button.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.y);
        bounds.h = header.h - (@as(f32, @floatFromInt(@as(c_int, 4))) * style.*.combo.content_padding.y);
        bounds.y = header.y + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.y);
        bounds.x = header.x + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.x);
        if (draw_button_symbol != 0) {
            bounds.w = (button.x - (style.*.combo.content_padding.x + style.*.combo.spacing.x)) - bounds.x;
        } else {
            bounds.w = header.w - (@as(f32, @floatFromInt(@as(c_int, 4))) * style.*.combo.content_padding.x);
        }
        nk_fill_rect(&win.*.buffer, bounds, @as(f32, @floatFromInt(@as(c_int, 0))), nk_rgb_factor(color, style.*.combo.color_factor));
        if (draw_button_symbol != 0) {
            nk_draw_button_symbol(&win.*.buffer, &button, &content, ctx.*.last_widget_state, &ctx.*.style.combo.button, sym, style.*.font);
        }
    }
    return nk_combo_begin(ctx, win, size, is_clicked, header);
}
pub fn nk_combo_begin_symbol(arg_ctx: [*c]struct_nk_context, arg_symbol: enum_nk_symbol_type, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var symbol = arg_symbol;
    _ = &symbol;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var s: enum_nk_widget_layout_states = undefined;
    _ = &s;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var sym_background: struct_nk_color = undefined;
    _ = &sym_background;
    var symbol_color: struct_nk_color = undefined;
    _ = &symbol_color;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29964))), "nk_bool nk_combo_begin_symbol(struct nk_context *, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29965))), "nk_bool nk_combo_begin_symbol(struct nk_context *, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29966))), "nk_bool nk_combo_begin_symbol(struct nk_context *, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    s = nk_widget(&header, ctx);
    if (s == @as(c_uint, @bitCast(NK_WIDGET_INVALID))) return 0;
    in = if ((((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) or (s == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or (s == @as(c_uint, @bitCast(NK_WIDGET_ROM)))) null else &ctx.*.input;
    if (nk_button_behavior(&ctx.*.last_widget_state, header, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        is_clicked = nk_true;
    }
    if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.combo.active;
        symbol_color = style.*.combo.symbol_active;
    } else if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.combo.hover;
        symbol_color = style.*.combo.symbol_hover;
    } else {
        background = &style.*.combo.normal;
        symbol_color = style.*.combo.symbol_hover;
    }
    symbol_color = nk_rgb_factor(symbol_color, style.*.combo.color_factor);
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                sym_background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_image(&win.*.buffer, header, &background.*.data.image, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                sym_background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_nine_slice(&win.*.buffer, header, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                sym_background = background.*.data.color;
                nk_fill_rect(&win.*.buffer, header, style.*.combo.rounding, nk_rgb_factor(background.*.data.color, style.*.combo.color_factor));
                nk_stroke_rect(&win.*.buffer, header, style.*.combo.rounding, style.*.combo.border, nk_rgb_factor(style.*.combo.border_color, style.*.combo.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    {
        var bounds: struct_nk_rect = struct_nk_rect{
            .x = @as(f32, @floatFromInt(@as(c_int, 0))),
            .y = @as(f32, @floatFromInt(@as(c_int, 0))),
            .w = @as(f32, @floatFromInt(@as(c_int, 0))),
            .h = @as(f32, @floatFromInt(@as(c_int, 0))),
        };
        _ = &bounds;
        var content: struct_nk_rect = undefined;
        _ = &content;
        var button: struct_nk_rect = undefined;
        _ = &button;
        var sym: enum_nk_symbol_type = undefined;
        _ = &sym;
        if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
            sym = style.*.combo.sym_hover;
        } else if (is_clicked != 0) {
            sym = style.*.combo.sym_active;
        } else {
            sym = style.*.combo.sym_normal;
        }
        button.w = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button_padding.y);
        button.x = ((header.x + header.w) - header.h) - style.*.combo.button_padding.y;
        button.y = header.y + style.*.combo.button_padding.y;
        button.h = button.w;
        content.x = button.x + style.*.combo.button.padding.x;
        content.y = button.y + style.*.combo.button.padding.y;
        content.w = button.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.x);
        content.h = button.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.y);
        bounds.h = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.y);
        bounds.y = header.y + style.*.combo.content_padding.y;
        bounds.x = header.x + style.*.combo.content_padding.x;
        bounds.w = (button.x - style.*.combo.content_padding.y) - bounds.x;
        nk_draw_symbol(&win.*.buffer, symbol, bounds, sym_background, symbol_color, 1.0, style.*.font);
        nk_draw_button_symbol(&win.*.buffer, &bounds, &content, ctx.*.last_widget_state, &ctx.*.style.combo.button, sym, style.*.font);
    }
    return nk_combo_begin(ctx, win, size, is_clicked, header);
}
pub fn nk_combo_begin_symbol_label(arg_ctx: [*c]struct_nk_context, arg_selected: [*c]const u8, arg_type: enum_nk_symbol_type, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var selected = arg_selected;
    _ = &selected;
    var @"type" = arg_type;
    _ = &@"type";
    var size = arg_size;
    _ = &size;
    return nk_combo_begin_symbol_text(ctx, selected, nk_strlen(selected), @"type", size);
}
pub fn nk_combo_begin_symbol_text(arg_ctx: [*c]struct_nk_context, arg_selected: [*c]const u8, arg_len: c_int, arg_symbol: enum_nk_symbol_type, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var selected = arg_selected;
    _ = &selected;
    var len = arg_len;
    _ = &len;
    var symbol = arg_symbol;
    _ = &symbol;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var s: enum_nk_widget_layout_states = undefined;
    _ = &s;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var symbol_color: struct_nk_color = undefined;
    _ = &symbol_color;
    var text: struct_nk_text = undefined;
    _ = &text;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30061))), "nk_bool nk_combo_begin_symbol_text(struct nk_context *, const char *, int, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30062))), "nk_bool nk_combo_begin_symbol_text(struct nk_context *, const char *, int, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30063))), "nk_bool nk_combo_begin_symbol_text(struct nk_context *, const char *, int, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    s = nk_widget(&header, ctx);
    if (!(s != 0)) return 0;
    in = if ((((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) or (s == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or (s == @as(c_uint, @bitCast(NK_WIDGET_ROM)))) null else &ctx.*.input;
    if (nk_button_behavior(&ctx.*.last_widget_state, header, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        is_clicked = nk_true;
    }
    if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.combo.active;
        symbol_color = style.*.combo.symbol_active;
        text.text = style.*.combo.label_active;
    } else if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.combo.hover;
        symbol_color = style.*.combo.symbol_hover;
        text.text = style.*.combo.label_hover;
    } else {
        background = &style.*.combo.normal;
        symbol_color = style.*.combo.symbol_normal;
        text.text = style.*.combo.label_normal;
    }
    text.text = nk_rgb_factor(text.text, style.*.combo.color_factor);
    symbol_color = nk_rgb_factor(symbol_color, style.*.combo.color_factor);
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_image(&win.*.buffer, header, &background.*.data.image, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_nine_slice(&win.*.buffer, header, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                text.background = background.*.data.color;
                nk_fill_rect(&win.*.buffer, header, style.*.combo.rounding, nk_rgb_factor(background.*.data.color, style.*.combo.color_factor));
                nk_stroke_rect(&win.*.buffer, header, style.*.combo.rounding, style.*.combo.border, nk_rgb_factor(style.*.combo.border_color, style.*.combo.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    {
        var content: struct_nk_rect = undefined;
        _ = &content;
        var button: struct_nk_rect = undefined;
        _ = &button;
        var label: struct_nk_rect = undefined;
        _ = &label;
        var image: struct_nk_rect = undefined;
        _ = &image;
        var sym: enum_nk_symbol_type = undefined;
        _ = &sym;
        if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
            sym = style.*.combo.sym_hover;
        } else if (is_clicked != 0) {
            sym = style.*.combo.sym_active;
        } else {
            sym = style.*.combo.sym_normal;
        }
        button.w = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button_padding.y);
        button.x = ((header.x + header.w) - header.h) - style.*.combo.button_padding.x;
        button.y = header.y + style.*.combo.button_padding.y;
        button.h = button.w;
        content.x = button.x + style.*.combo.button.padding.x;
        content.y = button.y + style.*.combo.button.padding.y;
        content.w = button.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.x);
        content.h = button.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.y);
        nk_draw_button_symbol(&win.*.buffer, &button, &content, ctx.*.last_widget_state, &ctx.*.style.combo.button, sym, style.*.font);
        image.x = header.x + style.*.combo.content_padding.x;
        image.y = header.y + style.*.combo.content_padding.y;
        image.h = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.y);
        image.w = image.h;
        nk_draw_symbol(&win.*.buffer, symbol, image, text.background, symbol_color, 1.0, style.*.font);
        text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
        label.x = ((image.x + image.w) + style.*.combo.spacing.x) + style.*.combo.content_padding.x;
        label.y = header.y + style.*.combo.content_padding.y;
        label.w = (button.x - style.*.combo.content_padding.x) - label.x;
        label.h = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.y);
        nk_widget_text(&win.*.buffer, label, selected, len, &text, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), style.*.font);
    }
    return nk_combo_begin(ctx, win, size, is_clicked, header);
}
pub fn nk_combo_begin_image(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var s: enum_nk_widget_layout_states = undefined;
    _ = &s;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30165))), "nk_bool nk_combo_begin_image(struct nk_context *, struct nk_image, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30166))), "nk_bool nk_combo_begin_image(struct nk_context *, struct nk_image, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30167))), "nk_bool nk_combo_begin_image(struct nk_context *, struct nk_image, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    s = nk_widget(&header, ctx);
    if (s == @as(c_uint, @bitCast(NK_WIDGET_INVALID))) return 0;
    in = if ((((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) or (s == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or (s == @as(c_uint, @bitCast(NK_WIDGET_ROM)))) null else &ctx.*.input;
    if (nk_button_behavior(&ctx.*.last_widget_state, header, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        is_clicked = nk_true;
    }
    if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.combo.active;
    } else if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.combo.hover;
    } else {
        background = &style.*.combo.normal;
    }
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(&win.*.buffer, header, &background.*.data.image, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(&win.*.buffer, header, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(&win.*.buffer, header, style.*.combo.rounding, nk_rgb_factor(background.*.data.color, style.*.combo.color_factor));
                nk_stroke_rect(&win.*.buffer, header, style.*.combo.rounding, style.*.combo.border, nk_rgb_factor(style.*.combo.border_color, style.*.combo.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    {
        var bounds: struct_nk_rect = struct_nk_rect{
            .x = @as(f32, @floatFromInt(@as(c_int, 0))),
            .y = @as(f32, @floatFromInt(@as(c_int, 0))),
            .w = @as(f32, @floatFromInt(@as(c_int, 0))),
            .h = @as(f32, @floatFromInt(@as(c_int, 0))),
        };
        _ = &bounds;
        var content: struct_nk_rect = undefined;
        _ = &content;
        var button: struct_nk_rect = undefined;
        _ = &button;
        var draw_button_symbol: c_int = undefined;
        _ = &draw_button_symbol;
        var sym: enum_nk_symbol_type = undefined;
        _ = &sym;
        if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
            sym = style.*.combo.sym_hover;
        } else if (is_clicked != 0) {
            sym = style.*.combo.sym_active;
        } else {
            sym = style.*.combo.sym_normal;
        }
        draw_button_symbol = @intFromBool(sym != @as(c_uint, @bitCast(NK_SYMBOL_NONE)));
        button.w = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button_padding.y);
        button.x = ((header.x + header.w) - header.h) - style.*.combo.button_padding.y;
        button.y = header.y + style.*.combo.button_padding.y;
        button.h = button.w;
        content.x = button.x + style.*.combo.button.padding.x;
        content.y = button.y + style.*.combo.button.padding.y;
        content.w = button.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.x);
        content.h = button.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.y);
        bounds.h = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.y);
        bounds.y = header.y + style.*.combo.content_padding.y;
        bounds.x = header.x + style.*.combo.content_padding.x;
        if (draw_button_symbol != 0) {
            bounds.w = (button.x - style.*.combo.content_padding.y) - bounds.x;
        } else {
            bounds.w = header.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.x);
        }
        nk_draw_image(&win.*.buffer, bounds, &img, nk_rgb_factor(nk_white, style.*.combo.color_factor));
        if (draw_button_symbol != 0) {
            nk_draw_button_symbol(&win.*.buffer, &bounds, &content, ctx.*.last_widget_state, &ctx.*.style.combo.button, sym, style.*.font);
        }
    }
    return nk_combo_begin(ctx, win, size, is_clicked, header);
}
pub fn nk_combo_begin_image_label(arg_ctx: [*c]struct_nk_context, arg_selected: [*c]const u8, arg_img: struct_nk_image, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var selected = arg_selected;
    _ = &selected;
    var img = arg_img;
    _ = &img;
    var size = arg_size;
    _ = &size;
    return nk_combo_begin_image_text(ctx, selected, nk_strlen(selected), img, size);
}
pub fn nk_combo_begin_image_text(arg_ctx: [*c]struct_nk_context, arg_selected: [*c]const u8, arg_len: c_int, arg_img: struct_nk_image, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var selected = arg_selected;
    _ = &selected;
    var len = arg_len;
    _ = &len;
    var img = arg_img;
    _ = &img;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var s: enum_nk_widget_layout_states = undefined;
    _ = &s;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var text: struct_nk_text = undefined;
    _ = &text;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30258))), "nk_bool nk_combo_begin_image_text(struct nk_context *, const char *, int, struct nk_image, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30259))), "nk_bool nk_combo_begin_image_text(struct nk_context *, const char *, int, struct nk_image, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30260))), "nk_bool nk_combo_begin_image_text(struct nk_context *, const char *, int, struct nk_image, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    s = nk_widget(&header, ctx);
    if (!(s != 0)) return 0;
    in = if ((((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) or (s == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) or (s == @as(c_uint, @bitCast(NK_WIDGET_ROM)))) null else &ctx.*.input;
    if (nk_button_behavior(&ctx.*.last_widget_state, header, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        is_clicked = nk_true;
    }
    if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.combo.active;
        text.text = style.*.combo.label_active;
    } else if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.combo.hover;
        text.text = style.*.combo.label_hover;
    } else {
        background = &style.*.combo.normal;
        text.text = style.*.combo.label_normal;
    }
    text.text = nk_rgb_factor(text.text, style.*.combo.color_factor);
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_image(&win.*.buffer, header, &background.*.data.image, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_nine_slice(&win.*.buffer, header, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.combo.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                text.background = background.*.data.color;
                nk_fill_rect(&win.*.buffer, header, style.*.combo.rounding, nk_rgb_factor(background.*.data.color, style.*.combo.color_factor));
                nk_stroke_rect(&win.*.buffer, header, style.*.combo.rounding, style.*.combo.border, nk_rgb_factor(style.*.combo.border_color, style.*.combo.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    {
        var content: struct_nk_rect = undefined;
        _ = &content;
        var button: struct_nk_rect = undefined;
        _ = &button;
        var label: struct_nk_rect = undefined;
        _ = &label;
        var image: struct_nk_rect = undefined;
        _ = &image;
        var draw_button_symbol: c_int = undefined;
        _ = &draw_button_symbol;
        var sym: enum_nk_symbol_type = undefined;
        _ = &sym;
        if ((ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
            sym = style.*.combo.sym_hover;
        } else if (is_clicked != 0) {
            sym = style.*.combo.sym_active;
        } else {
            sym = style.*.combo.sym_normal;
        }
        draw_button_symbol = @intFromBool(sym != @as(c_uint, @bitCast(NK_SYMBOL_NONE)));
        button.w = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button_padding.y);
        button.x = ((header.x + header.w) - header.h) - style.*.combo.button_padding.x;
        button.y = header.y + style.*.combo.button_padding.y;
        button.h = button.w;
        content.x = button.x + style.*.combo.button.padding.x;
        content.y = button.y + style.*.combo.button.padding.y;
        content.w = button.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.x);
        content.h = button.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.button.padding.y);
        if (draw_button_symbol != 0) {
            nk_draw_button_symbol(&win.*.buffer, &button, &content, ctx.*.last_widget_state, &ctx.*.style.combo.button, sym, style.*.font);
        }
        image.x = header.x + style.*.combo.content_padding.x;
        image.y = header.y + style.*.combo.content_padding.y;
        image.h = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.y);
        image.w = image.h;
        nk_draw_image(&win.*.buffer, image, &img, nk_rgb_factor(nk_white, style.*.combo.color_factor));
        text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
        label.x = ((image.x + image.w) + style.*.combo.spacing.x) + style.*.combo.content_padding.x;
        label.y = header.y + style.*.combo.content_padding.y;
        label.h = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.combo.content_padding.y);
        if (draw_button_symbol != 0) {
            label.w = (button.x - style.*.combo.content_padding.x) - label.x;
        } else {
            label.w = ((header.x + header.w) - style.*.combo.content_padding.x) - label.x;
        }
        nk_widget_text(&win.*.buffer, label, selected, len, &text, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), style.*.font);
    }
    return nk_combo_begin(ctx, win, size, is_clicked, header);
}
pub fn nk_combo_item_label(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_label(ctx, label, @"align");
}
pub fn nk_combo_item_text(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_text(ctx, text, len, @"align");
}
pub fn nk_combo_item_image_label(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_text: [*c]const u8, arg_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var text = arg_text;
    _ = &text;
    var alignment = arg_alignment;
    _ = &alignment;
    return nk_contextual_item_image_label(ctx, img, text, alignment);
}
pub fn nk_combo_item_image_text(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_text: [*c]const u8, arg_len: c_int, arg_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var alignment = arg_alignment;
    _ = &alignment;
    return nk_contextual_item_image_text(ctx, img, text, len, alignment);
}
pub fn nk_combo_item_symbol_label(arg_ctx: [*c]struct_nk_context, arg_sym: enum_nk_symbol_type, arg_label: [*c]const u8, arg_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var sym = arg_sym;
    _ = &sym;
    var label = arg_label;
    _ = &label;
    var alignment = arg_alignment;
    _ = &alignment;
    return nk_contextual_item_symbol_label(ctx, sym, label, alignment);
}
pub fn nk_combo_item_symbol_text(arg_ctx: [*c]struct_nk_context, arg_sym: enum_nk_symbol_type, arg_text: [*c]const u8, arg_len: c_int, arg_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var sym = arg_sym;
    _ = &sym;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var alignment = arg_alignment;
    _ = &alignment;
    return nk_contextual_item_symbol_text(ctx, sym, text, len, alignment);
}
pub fn nk_combo_close(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    nk_contextual_close(ctx);
}
pub fn nk_combo_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    nk_contextual_end(ctx);
}
pub fn nk_contextual_begin(arg_ctx: [*c]struct_nk_context, arg_flags: nk_flags, arg_size: struct_nk_vec2, arg_trigger_bounds: struct_nk_rect) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var flags = arg_flags;
    _ = &flags;
    var size = arg_size;
    _ = &size;
    var trigger_bounds = arg_trigger_bounds;
    _ = &trigger_bounds;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    var body: struct_nk_rect = undefined;
    _ = &body;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    const null_rect = struct {
        const static: struct_nk_rect = struct_nk_rect{
            .x = @as(f32, @floatFromInt(-@as(c_int, 1))),
            .y = @as(f32, @floatFromInt(-@as(c_int, 1))),
            .w = @as(f32, @floatFromInt(@as(c_int, 0))),
            .h = @as(f32, @floatFromInt(@as(c_int, 0))),
        };
    };
    _ = &null_rect;
    var is_clicked: c_int = 0;
    _ = &is_clicked;
    var is_open: c_int = 0;
    _ = &is_open;
    var ret: c_int = 0;
    _ = &ret;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21485))), "nk_bool nk_contextual_begin(struct nk_context *, nk_flags, struct nk_vec2, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21486))), "nk_bool nk_contextual_begin(struct nk_context *, nk_flags, struct nk_vec2, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21487))), "nk_bool nk_contextual_begin(struct nk_context *, nk_flags, struct nk_vec2, struct nk_rect)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    win.*.popup.con_count +%= 1;
    if (ctx.*.current != ctx.*.active) return 0;
    popup = win.*.popup.win;
    is_open = @intFromBool((popup != null) and (win.*.popup.type == @as(c_uint, @bitCast(NK_PANEL_CONTEXTUAL))));
    in = if (win.*.widgets_disabled != 0) null else &ctx.*.input;
    if (in != null) {
        is_clicked = nk_input_mouse_clicked(in, @as(c_uint, @bitCast(NK_BUTTON_RIGHT)), trigger_bounds);
        if ((win.*.popup.active_con != 0) and (win.*.popup.con_count != win.*.popup.active_con)) return 0;
        if (!(is_open != 0) and (win.*.popup.active_con != 0)) {
            win.*.popup.active_con = 0;
        }
        if (!(is_open != 0) and !(is_clicked != 0)) return 0;
        win.*.popup.active_con = win.*.popup.con_count;
        if (is_clicked != 0) {
            body.x = in.*.mouse.pos.x;
            body.y = in.*.mouse.pos.y;
        } else {
            body.x = popup.*.bounds.x;
            body.y = popup.*.bounds.y;
        }
        body.w = size.x;
        body.h = size.y;
        ret = nk_nonblock_begin(ctx, flags | @as(nk_flags, @bitCast(NK_WINDOW_NO_SCROLLBAR)), body, null_rect.static, @as(c_uint, @bitCast(NK_PANEL_CONTEXTUAL)));
        if (ret != 0) {
            win.*.popup.type = @as(c_uint, @bitCast(NK_PANEL_CONTEXTUAL));
        } else {
            win.*.popup.active_con = 0;
            win.*.popup.type = @as(c_uint, @bitCast(NK_PANEL_NONE));
            if (win.*.popup.win != null) {
                win.*.popup.win.*.flags = 0;
            }
        }
    }
    return ret;
}
pub fn nk_contextual_item_text(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_len: c_int, arg_alignment: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var alignment = arg_alignment;
    _ = &alignment;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21546))), "nk_bool nk_contextual_item_text(struct nk_context *, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21547))), "nk_bool nk_contextual_item_text(struct nk_context *, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21548))), "nk_bool nk_contextual_item_text(struct nk_context *, const char *, int, nk_flags)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    state = nk_widget_fitting(&bounds, ctx, style.*.contextual_button.padding);
    if (!(state != 0)) return nk_false;
    in = if ((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or ((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    if (nk_do_button_text(&ctx.*.last_widget_state, &win.*.buffer, bounds, text, len, alignment, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &style.*.contextual_button, in, style.*.font) != 0) {
        nk_contextual_close(ctx);
        return nk_true;
    }
    return nk_false;
}
pub fn nk_contextual_item_label(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_text(ctx, label, nk_strlen(label), @"align");
}
pub fn nk_contextual_item_image_label(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_label: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var label = arg_label;
    _ = &label;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_image_text(ctx, img, label, nk_strlen(label), @"align");
}
pub fn nk_contextual_item_image_text(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_text: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21581))), "nk_bool nk_contextual_item_image_text(struct nk_context *, struct nk_image, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21582))), "nk_bool nk_contextual_item_image_text(struct nk_context *, struct nk_image, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21583))), "nk_bool nk_contextual_item_image_text(struct nk_context *, struct nk_image, const char *, int, nk_flags)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    state = nk_widget_fitting(&bounds, ctx, style.*.contextual_button.padding);
    if (!(state != 0)) return nk_false;
    in = if ((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or ((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    if (nk_do_button_text_image(&ctx.*.last_widget_state, &win.*.buffer, bounds, img, text, len, @"align", @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &style.*.contextual_button, style.*.font, in) != 0) {
        nk_contextual_close(ctx);
        return nk_true;
    }
    return nk_false;
}
pub fn nk_contextual_item_symbol_label(arg_ctx: [*c]struct_nk_context, arg_symbol: enum_nk_symbol_type, arg_text: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var symbol = arg_symbol;
    _ = &symbol;
    var text = arg_text;
    _ = &text;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_symbol_text(ctx, symbol, text, nk_strlen(text), @"align");
}
pub fn nk_contextual_item_symbol_text(arg_ctx: [*c]struct_nk_context, arg_symbol: enum_nk_symbol_type, arg_text: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var symbol = arg_symbol;
    _ = &symbol;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var state: enum_nk_widget_layout_states = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21617))), "nk_bool nk_contextual_item_symbol_text(struct nk_context *, enum nk_symbol_type, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21618))), "nk_bool nk_contextual_item_symbol_text(struct nk_context *, enum nk_symbol_type, const char *, int, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21619))), "nk_bool nk_contextual_item_symbol_text(struct nk_context *, enum nk_symbol_type, const char *, int, nk_flags)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    style = &ctx.*.style;
    state = nk_widget_fitting(&bounds, ctx, style.*.contextual_button.padding);
    if (!(state != 0)) return nk_false;
    in = if ((state == @as(c_uint, @bitCast(NK_WIDGET_ROM))) or ((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    if (nk_do_button_text_symbol(&ctx.*.last_widget_state, &win.*.buffer, bounds, symbol, text, len, @"align", @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &style.*.contextual_button, style.*.font, in) != 0) {
        nk_contextual_close(ctx);
        return nk_true;
    }
    return nk_false;
}
pub fn nk_contextual_close(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21645))), "void nk_contextual_close(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21646))), "void nk_contextual_close(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21647))), "void nk_contextual_close(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    nk_popup_close(ctx);
}
pub fn nk_contextual_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    var panel: [*c]struct_nk_panel = undefined;
    _ = &panel;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21656))), "void nk_contextual_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21657))), "void nk_contextual_end(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    popup = ctx.*.current;
    panel = popup.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (popup.*.parent != null) {} else {
                __assert_fail("popup->parent", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21662))), "void nk_contextual_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((@as(c_int, @bitCast(panel.*.type)) & NK_PANEL_SET_POPUP) != 0) {} else {
                __assert_fail("(int)panel->type & (int)NK_PANEL_SET_POPUP", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21663))), "void nk_contextual_end(struct nk_context *)");
            };
        };
    };
    if ((panel.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_DYNAMIC))) != 0) {
        var body: struct_nk_rect = struct_nk_rect{
            .x = @as(f32, @floatFromInt(@as(c_int, 0))),
            .y = @as(f32, @floatFromInt(@as(c_int, 0))),
            .w = @as(f32, @floatFromInt(@as(c_int, 0))),
            .h = @as(f32, @floatFromInt(@as(c_int, 0))),
        };
        _ = &body;
        if (panel.*.at_y < (panel.*.bounds.y + panel.*.bounds.h)) {
            var padding: struct_nk_vec2 = nk_panel_get_padding(&ctx.*.style, panel.*.type);
            _ = &padding;
            body = panel.*.bounds;
            body.y = (((panel.*.at_y + panel.*.footer_height) + panel.*.border) + padding.y) + panel.*.row.height;
            body.h = (panel.*.bounds.y + panel.*.bounds.h) - body.y;
        }
        {
            var pressed: c_int = nk_input_is_mouse_pressed(&ctx.*.input, @as(c_uint, @bitCast(NK_BUTTON_LEFT)));
            _ = &pressed;
            var in_body: c_int = nk_input_is_mouse_hovering_rect(&ctx.*.input, body);
            _ = &in_body;
            if ((pressed != 0) and (in_body != 0)) {
                popup.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN));
            }
        }
    }
    if ((popup.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) {
        popup.*.seq = 0;
    }
    nk_popup_end(ctx);
    return;
}
pub fn nk_tooltip(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var padding: struct_nk_vec2 = undefined;
    _ = &padding;
    var text_len: c_int = undefined;
    _ = &text_len;
    var text_width: f32 = undefined;
    _ = &text_width;
    var text_height: f32 = undefined;
    _ = &text_height;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30619))), "void nk_tooltip(struct nk_context *, const char *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30620))), "void nk_tooltip(struct nk_context *, const char *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30621))), "void nk_tooltip(struct nk_context *, const char *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (text != null) {} else {
                __assert_fail("text", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30622))), "void nk_tooltip(struct nk_context *, const char *)");
            };
        };
    };
    if (((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) or !(text != null)) return;
    style = &ctx.*.style;
    padding = style.*.window.padding;
    text_len = nk_strlen(text);
    text_width = style.*.font.*.width.?(style.*.font.*.userdata, style.*.font.*.height, text, text_len);
    text_width += @as(f32, @floatFromInt(@as(c_int, 4))) * padding.x;
    text_height = style.*.font.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * padding.y);
    if (nk_tooltip_begin(ctx, text_width) != 0) {
        nk_layout_row_dynamic(ctx, text_height, @as(c_int, 1));
        nk_text(ctx, text, text_len, @as(nk_flags, @bitCast(NK_TEXT_LEFT)));
        nk_tooltip_end(ctx);
    }
}
pub fn nk_tooltip_begin(arg_ctx: [*c]struct_nk_context, arg_width: f32) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var width = arg_width;
    _ = &width;
    var x: c_int = undefined;
    _ = &x;
    var y: c_int = undefined;
    _ = &y;
    var w: c_int = undefined;
    _ = &w;
    var h: c_int = undefined;
    _ = &h;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var ret: c_int = undefined;
    _ = &ret;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30569))), "nk_bool nk_tooltip_begin(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30570))), "nk_bool nk_tooltip_begin(struct nk_context *, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30571))), "nk_bool nk_tooltip_begin(struct nk_context *, float)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    in = &ctx.*.input;
    if ((win.*.popup.win != null) and ((@as(c_int, @bitCast(win.*.popup.type)) & NK_PANEL_SET_NONBLOCK) != 0)) return 0;
    w = nk_iceilf(width);
    h = nk_iceilf(nk_null_rect.h);
    x = nk_ifloorf(in.*.mouse.pos.x + @as(f32, @floatFromInt(@as(c_int, 1)))) - @as(c_int, @intFromFloat(win.*.layout.*.clip.x));
    y = nk_ifloorf(in.*.mouse.pos.y + @as(f32, @floatFromInt(@as(c_int, 1)))) - @as(c_int, @intFromFloat(win.*.layout.*.clip.y));
    bounds.x = @as(f32, @floatFromInt(x));
    bounds.y = @as(f32, @floatFromInt(y));
    bounds.w = @as(f32, @floatFromInt(w));
    bounds.h = @as(f32, @floatFromInt(h));
    ret = nk_popup_begin(ctx, @as(c_uint, @bitCast(NK_POPUP_DYNAMIC)), "__##Tooltip##__", @as(nk_flags, @bitCast(NK_WINDOW_NO_SCROLLBAR | NK_WINDOW_BORDER)), bounds);
    if (ret != 0) {
        win.*.layout.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_ROM));
    }
    win.*.popup.type = @as(c_uint, @bitCast(NK_PANEL_TOOLTIP));
    ctx.*.current.*.layout.*.type = @as(c_uint, @bitCast(NK_PANEL_TOOLTIP));
    return ret;
}
pub fn nk_tooltip_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30602))), "void nk_tooltip_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 30603))), "void nk_tooltip_end(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null) or !(ctx.*.current != null)) return;
    ctx.*.current.*.seq -%= 1;
    nk_popup_close(ctx);
    nk_popup_end(ctx);
}
pub fn nk_menubar_begin(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21702))), "void nk_menubar_begin(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21703))), "void nk_menubar_begin(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21704))), "void nk_menubar_begin(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    layout = ctx.*.current.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (layout.*.at_y == layout.*.bounds.y) {} else {
                __assert_fail("layout->at_y == layout->bounds.y", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21709))), "void nk_menubar_begin(struct nk_context *)");
            };
        };
    };
    if (((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) return;
    layout.*.menu.x = layout.*.at_x;
    layout.*.menu.y = layout.*.at_y + layout.*.row.height;
    layout.*.menu.w = layout.*.bounds.w;
    layout.*.menu.offset.x = layout.*.offset_x.*;
    layout.*.menu.offset.y = layout.*.offset_y.*;
    layout.*.offset_y.* = 0;
}
pub fn nk_menubar_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var out: [*c]struct_nk_command_buffer = undefined;
    _ = &out;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21742))), "void nk_menubar_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21743))), "void nk_menubar_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21744))), "void nk_menubar_end(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    out = &win.*.buffer;
    layout = win.*.layout;
    if (((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) return;
    layout.*.menu.h = layout.*.at_y - layout.*.menu.y;
    layout.*.menu.h += layout.*.row.height + ctx.*.style.window.spacing.y;
    layout.*.bounds.y += layout.*.menu.h;
    layout.*.bounds.h -= layout.*.menu.h;
    layout.*.offset_x.* = layout.*.menu.offset.x;
    layout.*.offset_y.* = layout.*.menu.offset.y;
    layout.*.at_y = layout.*.bounds.y - layout.*.row.height;
    layout.*.clip.y = layout.*.bounds.y;
    layout.*.clip.h = layout.*.bounds.h;
    nk_push_scissor(out, layout.*.clip);
}
pub fn nk_menu_begin_text(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var state: nk_flags = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21811))), "nk_bool nk_menu_begin_text(struct nk_context *, const char *, int, nk_flags, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21812))), "nk_bool nk_menu_begin_text(struct nk_context *, const char *, int, nk_flags, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21813))), "nk_bool nk_menu_begin_text(struct nk_context *, const char *, int, nk_flags, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    state = @as(nk_flags, @bitCast(nk_widget(&header, ctx)));
    if (!(state != 0)) return 0;
    in = if (((state == @as(nk_flags, @bitCast(NK_WIDGET_ROM))) or (state == @as(nk_flags, @bitCast(NK_WIDGET_DISABLED)))) or ((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    if (nk_do_button_text(&ctx.*.last_widget_state, &win.*.buffer, header, title, len, @"align", @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &ctx.*.style.menu_button, in, ctx.*.style.font) != 0) {
        is_clicked = nk_true;
    }
    return nk_menu_begin(ctx, win, title, is_clicked, header, size);
}
pub fn nk_menu_begin_label(arg_ctx: [*c]struct_nk_context, arg_text: [*c]const u8, arg_align: nk_flags, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var text = arg_text;
    _ = &text;
    var @"align" = arg_align;
    _ = &@"align";
    var size = arg_size;
    _ = &size;
    return nk_menu_begin_text(ctx, text, nk_strlen(text), @"align", size);
}
pub fn nk_menu_begin_image(arg_ctx: [*c]struct_nk_context, arg_id: [*c]const u8, arg_img: struct_nk_image, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var id = arg_id;
    _ = &id;
    var img = arg_img;
    _ = &img;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var state: nk_flags = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21841))), "nk_bool nk_menu_begin_image(struct nk_context *, const char *, struct nk_image, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21842))), "nk_bool nk_menu_begin_image(struct nk_context *, const char *, struct nk_image, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21843))), "nk_bool nk_menu_begin_image(struct nk_context *, const char *, struct nk_image, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    state = @as(nk_flags, @bitCast(nk_widget(&header, ctx)));
    if (!(state != 0)) return 0;
    in = if (((state == @as(nk_flags, @bitCast(NK_WIDGET_ROM))) or (state == @as(nk_flags, @bitCast(NK_WIDGET_DISABLED)))) or ((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    if (nk_do_button_image(&ctx.*.last_widget_state, &win.*.buffer, header, img, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &ctx.*.style.menu_button, in) != 0) {
        is_clicked = nk_true;
    }
    return nk_menu_begin(ctx, win, id, is_clicked, header, size);
}
pub fn nk_menu_begin_image_text(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_img: struct_nk_image, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var img = arg_img;
    _ = &img;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var state: nk_flags = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21891))), "nk_bool nk_menu_begin_image_text(struct nk_context *, const char *, int, nk_flags, struct nk_image, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21892))), "nk_bool nk_menu_begin_image_text(struct nk_context *, const char *, int, nk_flags, struct nk_image, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21893))), "nk_bool nk_menu_begin_image_text(struct nk_context *, const char *, int, nk_flags, struct nk_image, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    state = @as(nk_flags, @bitCast(nk_widget(&header, ctx)));
    if (!(state != 0)) return 0;
    in = if (((state == @as(nk_flags, @bitCast(NK_WIDGET_ROM))) or (state == @as(nk_flags, @bitCast(NK_WIDGET_DISABLED)))) or ((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    if (nk_do_button_text_image(&ctx.*.last_widget_state, &win.*.buffer, header, img, title, len, @"align", @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &ctx.*.style.menu_button, ctx.*.style.font, in) != 0) {
        is_clicked = nk_true;
    }
    return nk_menu_begin(ctx, win, title, is_clicked, header, size);
}
pub fn nk_menu_begin_image_label(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_align: nk_flags, arg_img: struct_nk_image, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var @"align" = arg_align;
    _ = &@"align";
    var img = arg_img;
    _ = &img;
    var size = arg_size;
    _ = &size;
    return nk_menu_begin_image_text(ctx, title, nk_strlen(title), @"align", img, size);
}
pub fn nk_menu_begin_symbol(arg_ctx: [*c]struct_nk_context, arg_id: [*c]const u8, arg_sym: enum_nk_symbol_type, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var id = arg_id;
    _ = &id;
    var sym = arg_sym;
    _ = &sym;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var state: nk_flags = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21866))), "nk_bool nk_menu_begin_symbol(struct nk_context *, const char *, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21867))), "nk_bool nk_menu_begin_symbol(struct nk_context *, const char *, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21868))), "nk_bool nk_menu_begin_symbol(struct nk_context *, const char *, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    state = @as(nk_flags, @bitCast(nk_widget(&header, ctx)));
    if (!(state != 0)) return 0;
    in = if (((state == @as(nk_flags, @bitCast(NK_WIDGET_ROM))) or (state == @as(nk_flags, @bitCast(NK_WIDGET_DISABLED)))) or ((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    if (nk_do_button_symbol(&ctx.*.last_widget_state, &win.*.buffer, header, sym, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &ctx.*.style.menu_button, in, ctx.*.style.font) != 0) {
        is_clicked = nk_true;
    }
    return nk_menu_begin(ctx, win, id, is_clicked, header, size);
}
pub fn nk_menu_begin_symbol_text(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_sym: enum_nk_symbol_type, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var sym = arg_sym;
    _ = &sym;
    var size = arg_size;
    _ = &size;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var header: struct_nk_rect = undefined;
    _ = &header;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var is_clicked: c_int = nk_false;
    _ = &is_clicked;
    var state: nk_flags = undefined;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21923))), "nk_bool nk_menu_begin_symbol_text(struct nk_context *, const char *, int, nk_flags, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21924))), "nk_bool nk_menu_begin_symbol_text(struct nk_context *, const char *, int, nk_flags, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21925))), "nk_bool nk_menu_begin_symbol_text(struct nk_context *, const char *, int, nk_flags, enum nk_symbol_type, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    state = @as(nk_flags, @bitCast(nk_widget(&header, ctx)));
    if (!(state != 0)) return 0;
    in = if (((state == @as(nk_flags, @bitCast(NK_WIDGET_ROM))) or (state == @as(nk_flags, @bitCast(NK_WIDGET_DISABLED)))) or ((win.*.layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) null else &ctx.*.input;
    if (nk_do_button_text_symbol(&ctx.*.last_widget_state, &win.*.buffer, header, sym, title, len, @"align", @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &ctx.*.style.menu_button, ctx.*.style.font, in) != 0) {
        is_clicked = nk_true;
    }
    return nk_menu_begin(ctx, win, title, is_clicked, header, size);
}
pub fn nk_menu_begin_symbol_label(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_align: nk_flags, arg_sym: enum_nk_symbol_type, arg_size: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var @"align" = arg_align;
    _ = &@"align";
    var sym = arg_sym;
    _ = &sym;
    var size = arg_size;
    _ = &size;
    return nk_menu_begin_symbol_text(ctx, title, nk_strlen(title), @"align", sym, size);
}
pub fn nk_menu_item_text(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_text(ctx, title, len, @"align");
}
pub fn nk_menu_item_label(arg_ctx: [*c]struct_nk_context, arg_label: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var label = arg_label;
    _ = &label;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_label(ctx, label, @"align");
}
pub fn nk_menu_item_image_label(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_label: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var label = arg_label;
    _ = &label;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_image_label(ctx, img, label, @"align");
}
pub fn nk_menu_item_image_text(arg_ctx: [*c]struct_nk_context, arg_img: struct_nk_image, arg_text: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var img = arg_img;
    _ = &img;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_image_text(ctx, img, text, len, @"align");
}
pub fn nk_menu_item_symbol_text(arg_ctx: [*c]struct_nk_context, arg_sym: enum_nk_symbol_type, arg_text: [*c]const u8, arg_len: c_int, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var sym = arg_sym;
    _ = &sym;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_symbol_text(ctx, sym, text, len, @"align");
}
pub fn nk_menu_item_symbol_label(arg_ctx: [*c]struct_nk_context, arg_sym: enum_nk_symbol_type, arg_label: [*c]const u8, arg_align: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var sym = arg_sym;
    _ = &sym;
    var label = arg_label;
    _ = &label;
    var @"align" = arg_align;
    _ = &@"align";
    return nk_contextual_item_symbol_label(ctx, sym, label, @"align");
}
pub fn nk_menu_close(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    nk_contextual_close(ctx);
}
pub fn nk_menu_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    nk_contextual_end(ctx);
}
pub const NK_COLOR_TEXT: c_int = 0;
pub const NK_COLOR_WINDOW: c_int = 1;
pub const NK_COLOR_HEADER: c_int = 2;
pub const NK_COLOR_BORDER: c_int = 3;
pub const NK_COLOR_BUTTON: c_int = 4;
pub const NK_COLOR_BUTTON_HOVER: c_int = 5;
pub const NK_COLOR_BUTTON_ACTIVE: c_int = 6;
pub const NK_COLOR_TOGGLE: c_int = 7;
pub const NK_COLOR_TOGGLE_HOVER: c_int = 8;
pub const NK_COLOR_TOGGLE_CURSOR: c_int = 9;
pub const NK_COLOR_SELECT: c_int = 10;
pub const NK_COLOR_SELECT_ACTIVE: c_int = 11;
pub const NK_COLOR_SLIDER: c_int = 12;
pub const NK_COLOR_SLIDER_CURSOR: c_int = 13;
pub const NK_COLOR_SLIDER_CURSOR_HOVER: c_int = 14;
pub const NK_COLOR_SLIDER_CURSOR_ACTIVE: c_int = 15;
pub const NK_COLOR_PROPERTY: c_int = 16;
pub const NK_COLOR_EDIT: c_int = 17;
pub const NK_COLOR_EDIT_CURSOR: c_int = 18;
pub const NK_COLOR_COMBO: c_int = 19;
pub const NK_COLOR_CHART: c_int = 20;
pub const NK_COLOR_CHART_COLOR: c_int = 21;
pub const NK_COLOR_CHART_COLOR_HIGHLIGHT: c_int = 22;
pub const NK_COLOR_SCROLLBAR: c_int = 23;
pub const NK_COLOR_SCROLLBAR_CURSOR: c_int = 24;
pub const NK_COLOR_SCROLLBAR_CURSOR_HOVER: c_int = 25;
pub const NK_COLOR_SCROLLBAR_CURSOR_ACTIVE: c_int = 26;
pub const NK_COLOR_TAB_HEADER: c_int = 27;
pub const NK_COLOR_KNOB: c_int = 28;
pub const NK_COLOR_KNOB_CURSOR: c_int = 29;
pub const NK_COLOR_KNOB_CURSOR_HOVER: c_int = 30;
pub const NK_COLOR_KNOB_CURSOR_ACTIVE: c_int = 31;
pub const NK_COLOR_COUNT: c_int = 32;
pub const enum_nk_style_colors = c_uint;
pub const NK_CURSOR_ARROW: c_int = 0;
pub const NK_CURSOR_TEXT: c_int = 1;
pub const NK_CURSOR_MOVE: c_int = 2;
pub const NK_CURSOR_RESIZE_VERTICAL: c_int = 3;
pub const NK_CURSOR_RESIZE_HORIZONTAL: c_int = 4;
pub const NK_CURSOR_RESIZE_TOP_LEFT_DOWN_RIGHT: c_int = 5;
pub const NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT: c_int = 6;
pub const NK_CURSOR_COUNT: c_int = 7;
pub const enum_nk_style_cursor = c_uint;
pub fn nk_style_default(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    nk_style_from_table(ctx, null);
}
pub fn nk_style_from_table(arg_ctx: [*c]struct_nk_context, arg_table: [*c]const struct_nk_color) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var table = arg_table;
    _ = &table;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    var text: [*c]struct_nk_style_text = undefined;
    _ = &text;
    var button: [*c]struct_nk_style_button = undefined;
    _ = &button;
    var toggle: [*c]struct_nk_style_toggle = undefined;
    _ = &toggle;
    var select: [*c]struct_nk_style_selectable = undefined;
    _ = &select;
    var slider: [*c]struct_nk_style_slider = undefined;
    _ = &slider;
    var knob: [*c]struct_nk_style_knob = undefined;
    _ = &knob;
    var prog: [*c]struct_nk_style_progress = undefined;
    _ = &prog;
    var scroll: [*c]struct_nk_style_scrollbar = undefined;
    _ = &scroll;
    var edit: [*c]struct_nk_style_edit = undefined;
    _ = &edit;
    var property: [*c]struct_nk_style_property = undefined;
    _ = &property;
    var combo: [*c]struct_nk_style_combo = undefined;
    _ = &combo;
    var chart: [*c]struct_nk_style_chart = undefined;
    _ = &chart;
    var tab: [*c]struct_nk_style_tab = undefined;
    _ = &tab;
    var win: [*c]struct_nk_style_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 18578))), "void nk_style_from_table(struct nk_context *, const struct nk_color *)");
            };
        };
    };
    if (!(ctx != null)) return;
    style = &ctx.*.style;
    table = if (!(table != null)) @as([*c]const struct_nk_color, @ptrCast(@alignCast(&nk_default_color_style))) else table;
    text = &style.*.text;
    text.*.color = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    text.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    text.*.color_factor = 1.0;
    text.*.disabled_factor = 0.5;
    button = &style.*.button;
    nk_zero(@as(?*anyopaque, @ptrCast(&button.*)), @sizeOf(struct_nk_style_button));
    button.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_BUTTON;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_BUTTON_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_BUTTON_ACTIVE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_background = (blk: {
        const tmp = NK_COLOR_BUTTON;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.padding = nk_vec2(2.0, 2.0);
    button.*.image_padding = nk_vec2(0.0, 0.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 1.0;
    button.*.rounding = 4.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    button = &style.*.contextual_button;
    nk_zero(@as(?*anyopaque, @ptrCast(&button.*)), @sizeOf(struct_nk_style_button));
    button.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_BUTTON_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_BUTTON_ACTIVE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.border_color = (blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_background = (blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.padding = nk_vec2(2.0, 2.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 0.0;
    button.*.rounding = 0.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    button = &style.*.menu_button;
    nk_zero(@as(?*anyopaque, @ptrCast(&button.*)), @sizeOf(struct_nk_style_button));
    button.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.border_color = (blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_background = (blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.padding = nk_vec2(2.0, 2.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 0.0;
    button.*.rounding = 1.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    toggle = &style.*.checkbox;
    nk_zero(@as(?*anyopaque, @ptrCast(&toggle.*)), @sizeOf(struct_nk_style_toggle));
    toggle.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.cursor_normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE_CURSOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.cursor_hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE_CURSOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.userdata = nk_handle_ptr(null);
    toggle.*.text_background = (blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    toggle.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    toggle.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    toggle.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    toggle.*.padding = nk_vec2(2.0, 2.0);
    toggle.*.touch_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    toggle.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    toggle.*.border = 0.0;
    toggle.*.spacing = 4;
    toggle.*.color_factor = 1.0;
    toggle.*.disabled_factor = 0.5;
    toggle = &style.*.option;
    nk_zero(@as(?*anyopaque, @ptrCast(&toggle.*)), @sizeOf(struct_nk_style_toggle));
    toggle.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.cursor_normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE_CURSOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.cursor_hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TOGGLE_CURSOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    toggle.*.userdata = nk_handle_ptr(null);
    toggle.*.text_background = (blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    toggle.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    toggle.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    toggle.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    toggle.*.padding = nk_vec2(3.0, 3.0);
    toggle.*.touch_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    toggle.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    toggle.*.border = 0.0;
    toggle.*.spacing = 4;
    toggle.*.color_factor = 1.0;
    toggle.*.disabled_factor = 0.5;
    select = &style.*.selectable;
    nk_zero(@as(?*anyopaque, @ptrCast(&select.*)), @sizeOf(struct_nk_style_selectable));
    select.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SELECT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    select.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SELECT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    select.*.pressed = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SELECT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    select.*.normal_active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SELECT_ACTIVE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    select.*.hover_active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SELECT_ACTIVE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    select.*.pressed_active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SELECT_ACTIVE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    select.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    select.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    select.*.text_pressed = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    select.*.text_normal_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    select.*.text_hover_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    select.*.text_pressed_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    select.*.padding = nk_vec2(2.0, 2.0);
    select.*.image_padding = nk_vec2(2.0, 2.0);
    select.*.touch_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    select.*.userdata = nk_handle_ptr(null);
    select.*.rounding = 0.0;
    select.*.color_factor = 1.0;
    select.*.disabled_factor = 0.5;
    select.*.draw_begin = null;
    select.*.draw_end = null;
    slider = &style.*.slider;
    nk_zero(@as(?*anyopaque, @ptrCast(&slider.*)), @sizeOf(struct_nk_style_slider));
    slider.*.normal = nk_style_item_hide();
    slider.*.hover = nk_style_item_hide();
    slider.*.active = nk_style_item_hide();
    slider.*.bar_normal = (blk: {
        const tmp = NK_COLOR_SLIDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    slider.*.bar_hover = (blk: {
        const tmp = NK_COLOR_SLIDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    slider.*.bar_active = (blk: {
        const tmp = NK_COLOR_SLIDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    slider.*.bar_filled = (blk: {
        const tmp = NK_COLOR_SLIDER_CURSOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    slider.*.cursor_normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SLIDER_CURSOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    slider.*.cursor_hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SLIDER_CURSOR_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    slider.*.cursor_active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SLIDER_CURSOR_ACTIVE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    slider.*.inc_symbol = @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_RIGHT));
    slider.*.dec_symbol = @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_LEFT));
    slider.*.cursor_size = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 16))), @as(f32, @floatFromInt(@as(c_int, 16))));
    slider.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 2))), @as(f32, @floatFromInt(@as(c_int, 2))));
    slider.*.spacing = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 2))), @as(f32, @floatFromInt(@as(c_int, 2))));
    slider.*.userdata = nk_handle_ptr(null);
    slider.*.show_buttons = nk_false;
    slider.*.bar_height = 8;
    slider.*.rounding = 0;
    slider.*.color_factor = 1.0;
    slider.*.disabled_factor = 0.5;
    slider.*.draw_begin = null;
    slider.*.draw_end = null;
    button = &style.*.slider.inc_button;
    button.*.normal = nk_style_item_color(nk_rgb(@as(c_int, 40), @as(c_int, 40), @as(c_int, 40)));
    button.*.hover = nk_style_item_color(nk_rgb(@as(c_int, 42), @as(c_int, 42), @as(c_int, 42)));
    button.*.active = nk_style_item_color(nk_rgb(@as(c_int, 44), @as(c_int, 44), @as(c_int, 44)));
    button.*.border_color = nk_rgb(@as(c_int, 65), @as(c_int, 65), @as(c_int, 65));
    button.*.text_background = nk_rgb(@as(c_int, 40), @as(c_int, 40), @as(c_int, 40));
    button.*.text_normal = nk_rgb(@as(c_int, 175), @as(c_int, 175), @as(c_int, 175));
    button.*.text_hover = nk_rgb(@as(c_int, 175), @as(c_int, 175), @as(c_int, 175));
    button.*.text_active = nk_rgb(@as(c_int, 175), @as(c_int, 175), @as(c_int, 175));
    button.*.padding = nk_vec2(8.0, 8.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 1.0;
    button.*.rounding = 0.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    style.*.slider.dec_button = style.*.slider.inc_button;
    knob = &style.*.knob;
    nk_zero(@as(?*anyopaque, @ptrCast(&knob.*)), @sizeOf(struct_nk_style_knob));
    knob.*.normal = nk_style_item_hide();
    knob.*.hover = nk_style_item_hide();
    knob.*.active = nk_style_item_hide();
    knob.*.knob_normal = (blk: {
        const tmp = NK_COLOR_KNOB;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    knob.*.knob_hover = (blk: {
        const tmp = NK_COLOR_KNOB;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    knob.*.knob_active = (blk: {
        const tmp = NK_COLOR_KNOB;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    knob.*.cursor_normal = (blk: {
        const tmp = NK_COLOR_KNOB_CURSOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    knob.*.cursor_hover = (blk: {
        const tmp = NK_COLOR_KNOB_CURSOR_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    knob.*.cursor_active = (blk: {
        const tmp = NK_COLOR_KNOB_CURSOR_ACTIVE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    knob.*.knob_border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    knob.*.knob_border = 1.0;
    knob.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 2))), @as(f32, @floatFromInt(@as(c_int, 2))));
    knob.*.spacing = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 2))), @as(f32, @floatFromInt(@as(c_int, 2))));
    knob.*.cursor_width = 2;
    knob.*.color_factor = 1.0;
    knob.*.disabled_factor = 0.5;
    knob.*.userdata = nk_handle_ptr(null);
    knob.*.draw_begin = null;
    knob.*.draw_end = null;
    prog = &style.*.progress;
    nk_zero(@as(?*anyopaque, @ptrCast(&prog.*)), @sizeOf(struct_nk_style_progress));
    prog.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SLIDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    prog.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SLIDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    prog.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SLIDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    prog.*.cursor_normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SLIDER_CURSOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    prog.*.cursor_hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SLIDER_CURSOR_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    prog.*.cursor_active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SLIDER_CURSOR_ACTIVE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    prog.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    prog.*.cursor_border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    prog.*.userdata = nk_handle_ptr(null);
    prog.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    prog.*.rounding = 0;
    prog.*.border = 0;
    prog.*.cursor_rounding = 0;
    prog.*.cursor_border = 0;
    prog.*.color_factor = 1.0;
    prog.*.disabled_factor = 0.5;
    prog.*.draw_begin = null;
    prog.*.draw_end = null;
    scroll = &style.*.scrollh;
    nk_zero(@as(?*anyopaque, @ptrCast(&scroll.*)), @sizeOf(struct_nk_style_scrollbar));
    scroll.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SCROLLBAR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    scroll.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SCROLLBAR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    scroll.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SCROLLBAR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    scroll.*.cursor_normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SCROLLBAR_CURSOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    scroll.*.cursor_hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SCROLLBAR_CURSOR_HOVER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    scroll.*.cursor_active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_SCROLLBAR_CURSOR_ACTIVE;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    scroll.*.dec_symbol = @as(c_uint, @bitCast(NK_SYMBOL_CIRCLE_SOLID));
    scroll.*.inc_symbol = @as(c_uint, @bitCast(NK_SYMBOL_CIRCLE_SOLID));
    scroll.*.userdata = nk_handle_ptr(null);
    scroll.*.border_color = (blk: {
        const tmp = NK_COLOR_SCROLLBAR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    scroll.*.cursor_border_color = (blk: {
        const tmp = NK_COLOR_SCROLLBAR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    scroll.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    scroll.*.show_buttons = nk_false;
    scroll.*.border = 0;
    scroll.*.rounding = 0;
    scroll.*.border_cursor = 0;
    scroll.*.rounding_cursor = 0;
    scroll.*.color_factor = 1.0;
    scroll.*.disabled_factor = 0.5;
    scroll.*.draw_begin = null;
    scroll.*.draw_end = null;
    style.*.scrollv = style.*.scrollh;
    button = &style.*.scrollh.inc_button;
    button.*.normal = nk_style_item_color(nk_rgb(@as(c_int, 40), @as(c_int, 40), @as(c_int, 40)));
    button.*.hover = nk_style_item_color(nk_rgb(@as(c_int, 42), @as(c_int, 42), @as(c_int, 42)));
    button.*.active = nk_style_item_color(nk_rgb(@as(c_int, 44), @as(c_int, 44), @as(c_int, 44)));
    button.*.border_color = nk_rgb(@as(c_int, 65), @as(c_int, 65), @as(c_int, 65));
    button.*.text_background = nk_rgb(@as(c_int, 40), @as(c_int, 40), @as(c_int, 40));
    button.*.text_normal = nk_rgb(@as(c_int, 175), @as(c_int, 175), @as(c_int, 175));
    button.*.text_hover = nk_rgb(@as(c_int, 175), @as(c_int, 175), @as(c_int, 175));
    button.*.text_active = nk_rgb(@as(c_int, 175), @as(c_int, 175), @as(c_int, 175));
    button.*.padding = nk_vec2(4.0, 4.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 1.0;
    button.*.rounding = 0.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    style.*.scrollh.dec_button = style.*.scrollh.inc_button;
    style.*.scrollv.inc_button = style.*.scrollh.inc_button;
    style.*.scrollv.dec_button = style.*.scrollh.inc_button;
    edit = &style.*.edit;
    nk_zero(@as(?*anyopaque, @ptrCast(&edit.*)), @sizeOf(struct_nk_style_edit));
    edit.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    edit.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    edit.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    edit.*.cursor_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.cursor_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.cursor_text_normal = (blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.cursor_text_hover = (blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.selected_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.selected_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.selected_text_normal = (blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.selected_text_hover = (blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.scrollbar_size = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 10))), @as(f32, @floatFromInt(@as(c_int, 10))));
    edit.*.scrollbar = style.*.scrollv;
    edit.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    edit.*.row_padding = 2;
    edit.*.cursor_size = 4;
    edit.*.border = 1;
    edit.*.rounding = 0;
    edit.*.color_factor = 1.0;
    edit.*.disabled_factor = 0.5;
    property = &style.*.property;
    nk_zero(@as(?*anyopaque, @ptrCast(&property.*)), @sizeOf(struct_nk_style_property));
    property.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    property.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    property.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    property.*.border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    property.*.label_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    property.*.label_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    property.*.label_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    property.*.sym_left = @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_LEFT));
    property.*.sym_right = @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_RIGHT));
    property.*.userdata = nk_handle_ptr(null);
    property.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    property.*.border = 1;
    property.*.rounding = 10;
    property.*.draw_begin = null;
    property.*.draw_end = null;
    property.*.color_factor = 1.0;
    property.*.disabled_factor = 0.5;
    button = &style.*.property.dec_button;
    nk_zero(@as(?*anyopaque, @ptrCast(&button.*)), @sizeOf(struct_nk_style_button));
    button.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    button.*.text_background = (blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.padding = nk_vec2(0.0, 0.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 0.0;
    button.*.rounding = 0.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    style.*.property.inc_button = style.*.property.dec_button;
    edit = &style.*.property.edit;
    nk_zero(@as(?*anyopaque, @ptrCast(&edit.*)), @sizeOf(struct_nk_style_edit));
    edit.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    edit.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    edit.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_PROPERTY;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    edit.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    edit.*.cursor_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.cursor_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.cursor_text_normal = (blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.cursor_text_hover = (blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.selected_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.selected_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.selected_text_normal = (blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.selected_text_hover = (blk: {
        const tmp = NK_COLOR_EDIT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    edit.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    edit.*.cursor_size = 8;
    edit.*.border = 0;
    edit.*.rounding = 0;
    edit.*.color_factor = 1.0;
    edit.*.disabled_factor = 0.5;
    chart = &style.*.chart;
    nk_zero(@as(?*anyopaque, @ptrCast(&chart.*)), @sizeOf(struct_nk_style_chart));
    chart.*.background = nk_style_item_color((blk: {
        const tmp = NK_COLOR_CHART;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    chart.*.border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    chart.*.selected_color = (blk: {
        const tmp = NK_COLOR_CHART_COLOR_HIGHLIGHT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    chart.*.color = (blk: {
        const tmp = NK_COLOR_CHART_COLOR;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    chart.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    chart.*.border = 0;
    chart.*.rounding = 0;
    chart.*.color_factor = 1.0;
    chart.*.disabled_factor = 0.5;
    chart.*.show_markers = nk_true;
    combo = &style.*.combo;
    combo.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_COMBO;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    combo.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_COMBO;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    combo.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_COMBO;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    combo.*.border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    combo.*.label_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    combo.*.label_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    combo.*.label_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    combo.*.sym_normal = @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_DOWN));
    combo.*.sym_hover = @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_DOWN));
    combo.*.sym_active = @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_DOWN));
    combo.*.content_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    combo.*.button_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 4))));
    combo.*.spacing = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 0))));
    combo.*.border = 1;
    combo.*.rounding = 0;
    combo.*.color_factor = 1.0;
    combo.*.disabled_factor = 0.5;
    button = &style.*.combo.button;
    nk_zero(@as(?*anyopaque, @ptrCast(&button.*)), @sizeOf(struct_nk_style_button));
    button.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_COMBO;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_COMBO;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_COMBO;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    button.*.text_background = (blk: {
        const tmp = NK_COLOR_COMBO;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.padding = nk_vec2(2.0, 2.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 0.0;
    button.*.rounding = 0.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    tab = &style.*.tab;
    tab.*.background = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TAB_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    tab.*.border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    tab.*.text = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    tab.*.sym_minimize = @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_RIGHT));
    tab.*.sym_maximize = @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_DOWN));
    tab.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    tab.*.spacing = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    tab.*.indent = 10.0;
    tab.*.border = 1;
    tab.*.rounding = 0;
    tab.*.color_factor = 1.0;
    tab.*.disabled_factor = 0.5;
    button = &style.*.tab.tab_minimize_button;
    nk_zero(@as(?*anyopaque, @ptrCast(&button.*)), @sizeOf(struct_nk_style_button));
    button.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TAB_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TAB_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TAB_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    button.*.text_background = (blk: {
        const tmp = NK_COLOR_TAB_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.padding = nk_vec2(2.0, 2.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 0.0;
    button.*.rounding = 0.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    style.*.tab.tab_maximize_button = button.*;
    button = &style.*.tab.node_minimize_button;
    nk_zero(@as(?*anyopaque, @ptrCast(&button.*)), @sizeOf(struct_nk_style_button));
    button.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    button.*.text_background = (blk: {
        const tmp = NK_COLOR_TAB_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.padding = nk_vec2(2.0, 2.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 0.0;
    button.*.rounding = 0.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    style.*.tab.node_maximize_button = button.*;
    win = &style.*.window;
    win.*.header.@"align" = @as(c_uint, @bitCast(NK_HEADER_RIGHT));
    win.*.header.close_symbol = @as(c_uint, @bitCast(NK_SYMBOL_X));
    win.*.header.minimize_symbol = @as(c_uint, @bitCast(NK_SYMBOL_MINUS));
    win.*.header.maximize_symbol = @as(c_uint, @bitCast(NK_SYMBOL_PLUS));
    win.*.header.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    win.*.header.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    win.*.header.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    win.*.header.label_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.header.label_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.header.label_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.header.label_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    win.*.header.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    win.*.header.spacing = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    button = &style.*.window.header.close_button;
    nk_zero(@as(?*anyopaque, @ptrCast(&button.*)), @sizeOf(struct_nk_style_button));
    button.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    button.*.text_background = (blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.padding = nk_vec2(0.0, 0.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 0.0;
    button.*.rounding = 0.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    button = &style.*.window.header.minimize_button;
    nk_zero(@as(?*anyopaque, @ptrCast(&button.*)), @sizeOf(struct_nk_style_button));
    button.*.normal = nk_style_item_color((blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.hover = nk_style_item_color((blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.active = nk_style_item_color((blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    button.*.border_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    button.*.text_background = (blk: {
        const tmp = NK_COLOR_HEADER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_normal = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_hover = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.text_active = (blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    button.*.padding = nk_vec2(0.0, 0.0);
    button.*.touch_padding = nk_vec2(0.0, 0.0);
    button.*.userdata = nk_handle_ptr(null);
    button.*.text_alignment = @as(nk_flags, @bitCast(NK_TEXT_CENTERED));
    button.*.border = 0.0;
    button.*.rounding = 0.0;
    button.*.color_factor_text = 1.0;
    button.*.color_factor_background = 1.0;
    button.*.disabled_factor = 0.5;
    button.*.draw_begin = null;
    button.*.draw_end = null;
    win.*.background = (blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.fixed_background = nk_style_item_color((blk: {
        const tmp = NK_COLOR_WINDOW;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    win.*.border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.popup_border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.combo_border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.contextual_border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.menu_border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.group_border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.tooltip_border_color = (blk: {
        const tmp = NK_COLOR_BORDER;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*;
    win.*.scaler = nk_style_item_color((blk: {
        const tmp = NK_COLOR_TEXT;
        if (tmp >= 0) break :blk table + @as(usize, @intCast(tmp)) else break :blk table - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).*);
    win.*.rounding = 0.0;
    win.*.spacing = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    win.*.scrollbar_size = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 10))), @as(f32, @floatFromInt(@as(c_int, 10))));
    win.*.min_size = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 64))), @as(f32, @floatFromInt(@as(c_int, 64))));
    win.*.combo_border = 1.0;
    win.*.contextual_border = 1.0;
    win.*.menu_border = 1.0;
    win.*.group_border = 1.0;
    win.*.tooltip_border = 1.0;
    win.*.popup_border = 1.0;
    win.*.border = 2.0;
    win.*.min_row_height_padding = 8;
    win.*.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    win.*.group_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    win.*.popup_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    win.*.combo_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    win.*.contextual_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    win.*.menu_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
    win.*.tooltip_padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4))));
}
pub fn nk_style_load_cursor(arg_ctx: [*c]struct_nk_context, arg_cursor: enum_nk_style_cursor, arg_c: [*c]const struct_nk_cursor) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var cursor = arg_cursor;
    _ = &cursor;
    var c = arg_c;
    _ = &c;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19313))), "void nk_style_load_cursor(struct nk_context *, enum nk_style_cursor, const struct nk_cursor *)");
            };
        };
    };
    if (!(ctx != null)) return;
    style = &ctx.*.style;
    style.*.cursors[cursor] = c;
}
pub fn nk_style_load_all_cursors(arg_ctx: [*c]struct_nk_context, arg_cursors: [*c]const struct_nk_cursor) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var cursors = arg_cursors;
    _ = &cursors;
    var i: c_int = 0;
    _ = &i;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19323))), "void nk_style_load_all_cursors(struct nk_context *, const struct nk_cursor *)");
            };
        };
    };
    if (!(ctx != null)) return;
    style = &ctx.*.style;
    {
        i = 0;
        while (i < NK_CURSOR_COUNT) : (i += 1) {
            style.*.cursors[@as(c_uint, @intCast(i))] = &(blk: {
                const tmp = i;
                if (tmp >= 0) break :blk cursors + @as(usize, @intCast(tmp)) else break :blk cursors - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*;
        }
    }
    style.*.cursor_visible = nk_true;
}
pub fn nk_style_get_color_by_name(arg_c: enum_nk_style_colors) callconv(.c) [*c]const u8 {
    var c = arg_c;
    _ = &c;
    return nk_color_names[c];
}
pub fn nk_style_set_font(arg_ctx: [*c]struct_nk_context, arg_font: [*c]const struct_nk_user_font) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var font = arg_font;
    _ = &font;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19194))), "void nk_style_set_font(struct nk_context *, const struct nk_user_font *)");
            };
        };
    };
    if (!(ctx != null)) return;
    style = &ctx.*.style;
    style.*.font = font;
    ctx.*.stacks.fonts.head = 0;
    if (ctx.*.current != null) {
        nk_layout_reset_min_row_height(ctx);
    }
}
pub fn nk_style_set_cursor(arg_ctx: [*c]struct_nk_context, arg_c: enum_nk_style_cursor) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var c = arg_c;
    _ = &c;
    var style: [*c]struct_nk_style = undefined;
    _ = &style;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19289))), "nk_bool nk_style_set_cursor(struct nk_context *, enum nk_style_cursor)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    style = &ctx.*.style;
    if (style.*.cursors[c] != null) {
        style.*.cursor_active = style.*.cursors[c];
        return 1;
    }
    return 0;
}
pub fn nk_style_show_cursor(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    ctx.*.style.cursor_visible = nk_true;
}
pub fn nk_style_hide_cursor(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    ctx.*.style.cursor_visible = nk_false;
}
pub fn nk_style_push_font(arg_ctx: [*c]struct_nk_context, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var font = arg_font;
    _ = &font;
    var font_stack: [*c]struct_nk_config_stack_user_font = undefined;
    _ = &font_stack;
    var element: [*c]struct_nk_config_stack_user_font_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19209))), "nk_bool nk_style_push_font(struct nk_context *, const struct nk_user_font *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    font_stack = &ctx.*.stacks.fonts;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font_stack.*.head < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([8]struct_nk_config_stack_user_font_element) / @sizeOf(struct_nk_config_stack_user_font_element)))))) {} else {
                __assert_fail("font_stack->head < (int)(sizeof(font_stack->elements)/sizeof(font_stack->elements)[0])", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19213))), "nk_bool nk_style_push_font(struct nk_context *, const struct nk_user_font *)");
            };
        };
    };
    if (font_stack.*.head >= @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([8]struct_nk_config_stack_user_font_element) / @sizeOf(struct_nk_config_stack_user_font_element)))))) return 0;
    element = &font_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &font_stack.*.head;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))];
    element.*.address = &ctx.*.style.font;
    element.*.old_value = ctx.*.style.font;
    ctx.*.style.font = font;
    return 1;
}
pub fn nk_style_push_float(arg_ctx: [*c]struct_nk_context, arg_address: [*c]f32, arg_value: f32) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var address = arg_address;
    _ = &address;
    var value = arg_value;
    _ = &value;
    var type_stack: [*c]struct_nk_config_stack_float = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_float_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19274))), "nk_bool nk_style_push_float(struct nk_context *, float *, float)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.floats;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([32]struct_nk_config_stack_float_element) / @sizeOf(struct_nk_config_stack_float_element)))))) {} else {
                __assert_fail("type_stack->head < (int)(sizeof(type_stack->elements)/sizeof(type_stack->elements)[0])", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19274))), "nk_bool nk_style_push_float(struct nk_context *, float *, float)");
            };
        };
    };
    if (type_stack.*.head >= @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([32]struct_nk_config_stack_float_element) / @sizeOf(struct_nk_config_stack_float_element)))))) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))];
    element.*.address = address;
    element.*.old_value = address.*;
    address.* = value;
    return 1;
}
pub fn nk_style_push_vec2(arg_ctx: [*c]struct_nk_context, arg_address: [*c]struct_nk_vec2, arg_value: struct_nk_vec2) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var address = arg_address;
    _ = &address;
    var value = arg_value;
    _ = &value;
    var type_stack: [*c]struct_nk_config_stack_vec2 = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_vec2_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19275))), "nk_bool nk_style_push_vec2(struct nk_context *, struct nk_vec2 *, struct nk_vec2)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.vectors;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([16]struct_nk_config_stack_vec2_element) / @sizeOf(struct_nk_config_stack_vec2_element)))))) {} else {
                __assert_fail("type_stack->head < (int)(sizeof(type_stack->elements)/sizeof(type_stack->elements)[0])", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19275))), "nk_bool nk_style_push_vec2(struct nk_context *, struct nk_vec2 *, struct nk_vec2)");
            };
        };
    };
    if (type_stack.*.head >= @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([16]struct_nk_config_stack_vec2_element) / @sizeOf(struct_nk_config_stack_vec2_element)))))) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))];
    element.*.address = address;
    element.*.old_value = address.*;
    address.* = value;
    return 1;
}
pub fn nk_style_push_style_item(arg_ctx: [*c]struct_nk_context, arg_address: [*c]struct_nk_style_item, arg_value: struct_nk_style_item) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var address = arg_address;
    _ = &address;
    var value = arg_value;
    _ = &value;
    var type_stack: [*c]struct_nk_config_stack_style_item = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_style_item_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19273))), "nk_bool nk_style_push_style_item(struct nk_context *, struct nk_style_item *, struct nk_style_item)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.style_items;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([16]struct_nk_config_stack_style_item_element) / @sizeOf(struct_nk_config_stack_style_item_element)))))) {} else {
                __assert_fail("type_stack->head < (int)(sizeof(type_stack->elements)/sizeof(type_stack->elements)[0])", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19273))), "nk_bool nk_style_push_style_item(struct nk_context *, struct nk_style_item *, struct nk_style_item)");
            };
        };
    };
    if (type_stack.*.head >= @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([16]struct_nk_config_stack_style_item_element) / @sizeOf(struct_nk_config_stack_style_item_element)))))) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))];
    element.*.address = address;
    element.*.old_value = address.*;
    address.* = value;
    return 1;
}
pub fn nk_style_push_flags(arg_ctx: [*c]struct_nk_context, arg_address: [*c]nk_flags, arg_value: nk_flags) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var address = arg_address;
    _ = &address;
    var value = arg_value;
    _ = &value;
    var type_stack: [*c]struct_nk_config_stack_flags = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_flags_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19276))), "nk_bool nk_style_push_flags(struct nk_context *, nk_flags *, nk_flags)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.flags;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([32]struct_nk_config_stack_flags_element) / @sizeOf(struct_nk_config_stack_flags_element)))))) {} else {
                __assert_fail("type_stack->head < (int)(sizeof(type_stack->elements)/sizeof(type_stack->elements)[0])", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19276))), "nk_bool nk_style_push_flags(struct nk_context *, nk_flags *, nk_flags)");
            };
        };
    };
    if (type_stack.*.head >= @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([32]struct_nk_config_stack_flags_element) / @sizeOf(struct_nk_config_stack_flags_element)))))) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))];
    element.*.address = address;
    element.*.old_value = address.*;
    address.* = value;
    return 1;
}
pub fn nk_style_push_color(arg_ctx: [*c]struct_nk_context, arg_address: [*c]struct_nk_color, arg_value: struct_nk_color) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var address = arg_address;
    _ = &address;
    var value = arg_value;
    _ = &value;
    var type_stack: [*c]struct_nk_config_stack_color = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_color_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19277))), "nk_bool nk_style_push_color(struct nk_context *, struct nk_color *, struct nk_color)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.colors;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([32]struct_nk_config_stack_color_element) / @sizeOf(struct_nk_config_stack_color_element)))))) {} else {
                __assert_fail("type_stack->head < (int)(sizeof(type_stack->elements)/sizeof(type_stack->elements)[0])", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19277))), "nk_bool nk_style_push_color(struct nk_context *, struct nk_color *, struct nk_color)");
            };
        };
    };
    if (type_stack.*.head >= @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([32]struct_nk_config_stack_color_element) / @sizeOf(struct_nk_config_stack_color_element)))))) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))];
    element.*.address = address;
    element.*.old_value = address.*;
    address.* = value;
    return 1;
}
pub fn nk_style_pop_font(arg_ctx: [*c]struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var font_stack: [*c]struct_nk_config_stack_user_font = undefined;
    _ = &font_stack;
    var element: [*c]struct_nk_config_stack_user_font_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19229))), "nk_bool nk_style_pop_font(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    font_stack = &ctx.*.stacks.fonts;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font_stack.*.head > @as(c_int, 0)) {} else {
                __assert_fail("font_stack->head > 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19233))), "nk_bool nk_style_pop_font(struct nk_context *)");
            };
        };
    };
    if (font_stack.*.head < @as(c_int, 1)) return 0;
    element = &font_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &font_stack.*.head;
        ref.* -= 1;
        break :blk ref.*;
    }))];
    element.*.address.* = element.*.old_value;
    return 1;
}
pub fn nk_style_pop_float(arg_ctx: [*c]struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var type_stack: [*c]struct_nk_config_stack_float = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_float_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19280))), "nk_bool nk_style_pop_float(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.floats;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head > @as(c_int, 0)) {} else {
                __assert_fail("type_stack->head > 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19280))), "nk_bool nk_style_pop_float(struct nk_context *)");
            };
        };
    };
    if (type_stack.*.head < @as(c_int, 1)) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        ref.* -= 1;
        break :blk ref.*;
    }))];
    element.*.address.* = element.*.old_value;
    return 1;
}
pub fn nk_style_pop_vec2(arg_ctx: [*c]struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var type_stack: [*c]struct_nk_config_stack_vec2 = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_vec2_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19281))), "nk_bool nk_style_pop_vec2(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.vectors;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head > @as(c_int, 0)) {} else {
                __assert_fail("type_stack->head > 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19281))), "nk_bool nk_style_pop_vec2(struct nk_context *)");
            };
        };
    };
    if (type_stack.*.head < @as(c_int, 1)) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        ref.* -= 1;
        break :blk ref.*;
    }))];
    element.*.address.* = element.*.old_value;
    return 1;
}
pub fn nk_style_pop_style_item(arg_ctx: [*c]struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var type_stack: [*c]struct_nk_config_stack_style_item = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_style_item_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19279))), "nk_bool nk_style_pop_style_item(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.style_items;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head > @as(c_int, 0)) {} else {
                __assert_fail("type_stack->head > 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19279))), "nk_bool nk_style_pop_style_item(struct nk_context *)");
            };
        };
    };
    if (type_stack.*.head < @as(c_int, 1)) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        ref.* -= 1;
        break :blk ref.*;
    }))];
    element.*.address.* = element.*.old_value;
    return 1;
}
pub fn nk_style_pop_flags(arg_ctx: [*c]struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var type_stack: [*c]struct_nk_config_stack_flags = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_flags_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19282))), "nk_bool nk_style_pop_flags(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.flags;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head > @as(c_int, 0)) {} else {
                __assert_fail("type_stack->head > 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19282))), "nk_bool nk_style_pop_flags(struct nk_context *)");
            };
        };
    };
    if (type_stack.*.head < @as(c_int, 1)) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        ref.* -= 1;
        break :blk ref.*;
    }))];
    element.*.address.* = element.*.old_value;
    return 1;
}
pub fn nk_style_pop_color(arg_ctx: [*c]struct_nk_context) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var type_stack: [*c]struct_nk_config_stack_color = undefined;
    _ = &type_stack;
    var element: [*c]struct_nk_config_stack_color_element = undefined;
    _ = &element;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19283))), "nk_bool nk_style_pop_color(struct nk_context *)");
            };
        };
    };
    if (!(ctx != null)) return 0;
    type_stack = &ctx.*.stacks.colors;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (type_stack.*.head > @as(c_int, 0)) {} else {
                __assert_fail("type_stack->head > 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19283))), "nk_bool nk_style_pop_color(struct nk_context *)");
            };
        };
    };
    if (type_stack.*.head < @as(c_int, 1)) return 0;
    element = &type_stack.*.elements[@as(c_uint, @intCast(blk: {
        const ref = &type_stack.*.head;
        ref.* -= 1;
        break :blk ref.*;
    }))];
    element.*.address.* = element.*.old_value;
    return 1;
}
pub fn nk_rgb(arg_r: c_int, arg_g: c_int, arg_b: c_int) callconv(.c) struct_nk_color {
    var r = arg_r;
    _ = &r;
    var g = arg_g;
    _ = &g;
    var b = arg_b;
    _ = &b;
    var ret: struct_nk_color = undefined;
    _ = &ret;
    ret.r = @as(nk_byte, @bitCast(@as(i8, @truncate(if ((if (r < @as(c_int, 255)) r else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (r < @as(c_int, 255)) r else @as(c_int, 255)))));
    ret.g = @as(nk_byte, @bitCast(@as(i8, @truncate(if ((if (g < @as(c_int, 255)) g else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (g < @as(c_int, 255)) g else @as(c_int, 255)))));
    ret.b = @as(nk_byte, @bitCast(@as(i8, @truncate(if ((if (b < @as(c_int, 255)) b else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (b < @as(c_int, 255)) b else @as(c_int, 255)))));
    ret.a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255)))));
    return ret;
}
pub fn nk_rgb_iv(arg_c: [*c]const c_int) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_rgb(c[@as(c_uint, @intCast(@as(c_int, 0)))], c[@as(c_uint, @intCast(@as(c_int, 1)))], c[@as(c_uint, @intCast(@as(c_int, 2)))]);
}
pub fn nk_rgb_bv(arg_c: [*c]const nk_byte) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_rgb(@as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 2)))]))));
}
pub fn nk_rgb_f(arg_r: f32, arg_g: f32, arg_b: f32) callconv(.c) struct_nk_color {
    var r = arg_r;
    _ = &r;
    var g = arg_g;
    _ = &g;
    var b = arg_b;
    _ = &b;
    var ret: struct_nk_color = undefined;
    _ = &ret;
    ret.r = @as(nk_byte, @intFromFloat((if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < r) 1.0 else r)) if (1.0 < r) 1.0 else r else @as(f32, @floatFromInt(@as(c_int, 0)))) * 255.0));
    ret.g = @as(nk_byte, @intFromFloat((if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < g) 1.0 else g)) if (1.0 < g) 1.0 else g else @as(f32, @floatFromInt(@as(c_int, 0)))) * 255.0));
    ret.b = @as(nk_byte, @intFromFloat((if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < b) 1.0 else b)) if (1.0 < b) 1.0 else b else @as(f32, @floatFromInt(@as(c_int, 0)))) * 255.0));
    ret.a = 255;
    return ret;
}
pub fn nk_rgb_fv(arg_c: [*c]const f32) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_rgb_f(c[@as(c_uint, @intCast(@as(c_int, 0)))], c[@as(c_uint, @intCast(@as(c_int, 1)))], c[@as(c_uint, @intCast(@as(c_int, 2)))]);
}
pub fn nk_rgb_cf(arg_c: struct_nk_colorf) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_rgb_f(c.r, c.g, c.b);
}
pub fn nk_rgb_hex(arg_rgb: [*c]const u8) callconv(.c) struct_nk_color {
    var rgb = arg_rgb;
    _ = &rgb;
    var col: struct_nk_color = undefined;
    _ = &col;
    var c: [*c]const u8 = rgb;
    _ = &c;
    if (@as(c_int, @bitCast(@as(c_uint, c.*))) == @as(c_int, '#')) {
        c += 1;
    }
    col.r = @as(nk_byte, @bitCast(@as(i8, @truncate(nk_parse_hex(c, @as(c_int, 2))))));
    col.g = @as(nk_byte, @bitCast(@as(i8, @truncate(nk_parse_hex(c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 2))))), @as(c_int, 2))))));
    col.b = @as(nk_byte, @bitCast(@as(i8, @truncate(nk_parse_hex(c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))), @as(c_int, 2))))));
    col.a = 255;
    return col;
}
pub fn nk_rgb_factor(arg_col: struct_nk_color, arg_factor: f32) callconv(.c) struct_nk_color {
    var col = arg_col;
    _ = &col;
    var factor = arg_factor;
    _ = &factor;
    if (factor == 1.0) return col;
    col.r = @as(nk_byte, @intFromFloat(@as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, col.r))))) * factor));
    col.g = @as(nk_byte, @intFromFloat(@as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, col.g))))) * factor));
    col.b = @as(nk_byte, @intFromFloat(@as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, col.b))))) * factor));
    return col;
}
pub fn nk_rgba(arg_r: c_int, arg_g: c_int, arg_b: c_int, arg_a: c_int) callconv(.c) struct_nk_color {
    var r = arg_r;
    _ = &r;
    var g = arg_g;
    _ = &g;
    var b = arg_b;
    _ = &b;
    var a = arg_a;
    _ = &a;
    var ret: struct_nk_color = undefined;
    _ = &ret;
    ret.r = @as(nk_byte, @bitCast(@as(i8, @truncate(if ((if (r < @as(c_int, 255)) r else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (r < @as(c_int, 255)) r else @as(c_int, 255)))));
    ret.g = @as(nk_byte, @bitCast(@as(i8, @truncate(if ((if (g < @as(c_int, 255)) g else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (g < @as(c_int, 255)) g else @as(c_int, 255)))));
    ret.b = @as(nk_byte, @bitCast(@as(i8, @truncate(if ((if (b < @as(c_int, 255)) b else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (b < @as(c_int, 255)) b else @as(c_int, 255)))));
    ret.a = @as(nk_byte, @bitCast(@as(i8, @truncate(if ((if (a < @as(c_int, 255)) a else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (a < @as(c_int, 255)) a else @as(c_int, 255)))));
    return ret;
}
pub fn nk_rgba_u32(arg_in: nk_uint) callconv(.c) struct_nk_color {
    var in = arg_in;
    _ = &in;
    var ret: struct_nk_color = undefined;
    _ = &ret;
    ret.r = @as(nk_byte, @bitCast(@as(u8, @truncate(in & @as(nk_uint, @bitCast(@as(c_int, 255)))))));
    ret.g = @as(nk_byte, @bitCast(@as(u8, @truncate((in >> @intCast(8)) & @as(nk_uint, @bitCast(@as(c_int, 255)))))));
    ret.b = @as(nk_byte, @bitCast(@as(u8, @truncate((in >> @intCast(16)) & @as(nk_uint, @bitCast(@as(c_int, 255)))))));
    ret.a = @as(nk_byte, @bitCast(@as(u8, @truncate((in >> @intCast(24)) & @as(nk_uint, @bitCast(@as(c_int, 255)))))));
    return ret;
}
pub fn nk_rgba_iv(arg_c: [*c]const c_int) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_rgba(c[@as(c_uint, @intCast(@as(c_int, 0)))], c[@as(c_uint, @intCast(@as(c_int, 1)))], c[@as(c_uint, @intCast(@as(c_int, 2)))], c[@as(c_uint, @intCast(@as(c_int, 3)))]);
}
pub fn nk_rgba_bv(arg_c: [*c]const nk_byte) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_rgba(@as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 2)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 3)))]))));
}
pub fn nk_rgba_f(arg_r: f32, arg_g: f32, arg_b: f32, arg_a: f32) callconv(.c) struct_nk_color {
    var r = arg_r;
    _ = &r;
    var g = arg_g;
    _ = &g;
    var b = arg_b;
    _ = &b;
    var a = arg_a;
    _ = &a;
    var ret: struct_nk_color = undefined;
    _ = &ret;
    ret.r = @as(nk_byte, @intFromFloat((if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < r) 1.0 else r)) if (1.0 < r) 1.0 else r else @as(f32, @floatFromInt(@as(c_int, 0)))) * 255.0));
    ret.g = @as(nk_byte, @intFromFloat((if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < g) 1.0 else g)) if (1.0 < g) 1.0 else g else @as(f32, @floatFromInt(@as(c_int, 0)))) * 255.0));
    ret.b = @as(nk_byte, @intFromFloat((if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < b) 1.0 else b)) if (1.0 < b) 1.0 else b else @as(f32, @floatFromInt(@as(c_int, 0)))) * 255.0));
    ret.a = @as(nk_byte, @intFromFloat((if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < a) 1.0 else a)) if (1.0 < a) 1.0 else a else @as(f32, @floatFromInt(@as(c_int, 0)))) * 255.0));
    return ret;
}
pub fn nk_rgba_fv(arg_c: [*c]const f32) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_rgba_f(c[@as(c_uint, @intCast(@as(c_int, 0)))], c[@as(c_uint, @intCast(@as(c_int, 1)))], c[@as(c_uint, @intCast(@as(c_int, 2)))], c[@as(c_uint, @intCast(@as(c_int, 3)))]);
}
pub fn nk_rgba_cf(arg_c: struct_nk_colorf) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_rgba_f(c.r, c.g, c.b, c.a);
}
pub fn nk_rgba_hex(arg_rgb: [*c]const u8) callconv(.c) struct_nk_color {
    var rgb = arg_rgb;
    _ = &rgb;
    var col: struct_nk_color = undefined;
    _ = &col;
    var c: [*c]const u8 = rgb;
    _ = &c;
    if (@as(c_int, @bitCast(@as(c_uint, c.*))) == @as(c_int, '#')) {
        c += 1;
    }
    col.r = @as(nk_byte, @bitCast(@as(i8, @truncate(nk_parse_hex(c, @as(c_int, 2))))));
    col.g = @as(nk_byte, @bitCast(@as(i8, @truncate(nk_parse_hex(c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 2))))), @as(c_int, 2))))));
    col.b = @as(nk_byte, @bitCast(@as(i8, @truncate(nk_parse_hex(c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 4))))), @as(c_int, 2))))));
    col.a = @as(nk_byte, @bitCast(@as(i8, @truncate(nk_parse_hex(c + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 6))))), @as(c_int, 2))))));
    return col;
}
pub fn nk_hsva_colorf(arg_h: f32, arg_s: f32, arg_v: f32, arg_a: f32) callconv(.c) struct_nk_colorf {
    var h = arg_h;
    _ = &h;
    var s = arg_s;
    _ = &s;
    var v = arg_v;
    _ = &v;
    var a = arg_a;
    _ = &a;
    var i: c_int = undefined;
    _ = &i;
    var p: f32 = undefined;
    _ = &p;
    var q: f32 = undefined;
    _ = &q;
    var t: f32 = undefined;
    _ = &t;
    var f: f32 = undefined;
    _ = &f;
    var out: struct_nk_colorf = struct_nk_colorf{
        .r = @as(f32, @floatFromInt(@as(c_int, 0))),
        .g = @as(f32, @floatFromInt(@as(c_int, 0))),
        .b = @as(f32, @floatFromInt(@as(c_int, 0))),
        .a = @as(f32, @floatFromInt(@as(c_int, 0))),
    };
    _ = &out;
    if (s <= 0.0) {
        out.r = v;
        out.g = v;
        out.b = v;
        out.a = a;
        return out;
    }
    h = h / (60.0 / 360.0);
    i = @as(c_int, @intFromFloat(h));
    f = h - @as(f32, @floatFromInt(i));
    p = v * (1.0 - s);
    q = v * (1.0 - (s * f));
    t = v * (1.0 - (s * (1.0 - f)));
    while (true) {
        switch (i) {
            else => {
                out.r = v;
                out.g = t;
                out.b = p;
                break;
            },
            @as(c_int, 1) => {
                out.r = q;
                out.g = v;
                out.b = p;
                break;
            },
            @as(c_int, 2) => {
                out.r = p;
                out.g = v;
                out.b = t;
                break;
            },
            @as(c_int, 3) => {
                out.r = p;
                out.g = q;
                out.b = v;
                break;
            },
            @as(c_int, 4) => {
                out.r = t;
                out.g = p;
                out.b = v;
                break;
            },
            @as(c_int, 5) => {
                out.r = v;
                out.g = p;
                out.b = q;
                break;
            },
        }
        break;
    }
    out.a = a;
    return out;
}
pub fn nk_hsva_colorfv(arg_c: [*c]const f32) callconv(.c) struct_nk_colorf {
    var c = arg_c;
    _ = &c;
    return nk_hsva_colorf(c[@as(c_uint, @intCast(@as(c_int, 0)))], c[@as(c_uint, @intCast(@as(c_int, 1)))], c[@as(c_uint, @intCast(@as(c_int, 2)))], c[@as(c_uint, @intCast(@as(c_int, 3)))]);
}
pub fn nk_colorf_hsva_f(arg_out_h: [*c]f32, arg_out_s: [*c]f32, arg_out_v: [*c]f32, arg_out_a: [*c]f32, arg_in: struct_nk_colorf) callconv(.c) void {
    var out_h = arg_out_h;
    _ = &out_h;
    var out_s = arg_out_s;
    _ = &out_s;
    var out_v = arg_out_v;
    _ = &out_v;
    var out_a = arg_out_a;
    _ = &out_a;
    var in = arg_in;
    _ = &in;
    var chroma: f32 = undefined;
    _ = &chroma;
    var K: f32 = 0.0;
    _ = &K;
    if (in.g < in.b) {
        const t: f32 = in.g;
        _ = &t;
        in.g = in.b;
        in.b = t;
        K = -1.0;
    }
    if (in.r < in.g) {
        const t: f32 = in.r;
        _ = &t;
        in.r = in.g;
        in.g = t;
        K = (-2.0 / 6.0) - K;
    }
    chroma = in.r - (if (in.g < in.b) in.g else in.b);
    out_h.* = if ((K + ((in.g - in.b) / ((6.0 * chroma) + 0.000000000000000000009999999682655225))) < @as(f32, @floatFromInt(@as(c_int, 0)))) -(K + ((in.g - in.b) / ((6.0 * chroma) + 0.000000000000000000009999999682655225))) else K + ((in.g - in.b) / ((6.0 * chroma) + 0.000000000000000000009999999682655225));
    out_s.* = chroma / (in.r + 0.000000000000000000009999999682655225);
    out_v.* = in.r;
    out_a.* = in.a;
}
pub fn nk_colorf_hsva_fv(arg_hsva: [*c]f32, arg_in: struct_nk_colorf) callconv(.c) void {
    var hsva = arg_hsva;
    _ = &hsva;
    var in = arg_in;
    _ = &in;
    nk_colorf_hsva_f(&hsva[@as(c_uint, @intCast(@as(c_int, 0)))], &hsva[@as(c_uint, @intCast(@as(c_int, 1)))], &hsva[@as(c_uint, @intCast(@as(c_int, 2)))], &hsva[@as(c_uint, @intCast(@as(c_int, 3)))], in);
}
pub fn nk_hsv(arg_h: c_int, arg_s: c_int, arg_v: c_int) callconv(.c) struct_nk_color {
    var h = arg_h;
    _ = &h;
    var s = arg_s;
    _ = &s;
    var v = arg_v;
    _ = &v;
    return nk_hsva(h, s, v, @as(c_int, 255));
}
pub fn nk_hsv_iv(arg_c: [*c]const c_int) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_hsv(c[@as(c_uint, @intCast(@as(c_int, 0)))], c[@as(c_uint, @intCast(@as(c_int, 1)))], c[@as(c_uint, @intCast(@as(c_int, 2)))]);
}
pub fn nk_hsv_bv(arg_c: [*c]const nk_byte) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_hsv(@as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 2)))]))));
}
pub fn nk_hsv_f(arg_h: f32, arg_s: f32, arg_v: f32) callconv(.c) struct_nk_color {
    var h = arg_h;
    _ = &h;
    var s = arg_s;
    _ = &s;
    var v = arg_v;
    _ = &v;
    return nk_hsva_f(h, s, v, 1.0);
}
pub fn nk_hsv_fv(arg_c: [*c]const f32) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_hsv_f(c[@as(c_uint, @intCast(@as(c_int, 0)))], c[@as(c_uint, @intCast(@as(c_int, 1)))], c[@as(c_uint, @intCast(@as(c_int, 2)))]);
}
pub fn nk_hsva(arg_h: c_int, arg_s: c_int, arg_v: c_int, arg_a: c_int) callconv(.c) struct_nk_color {
    var h = arg_h;
    _ = &h;
    var s = arg_s;
    _ = &s;
    var v = arg_v;
    _ = &v;
    var a = arg_a;
    _ = &a;
    var hf: f32 = @as(f32, @floatFromInt(if ((if (h < @as(c_int, 255)) h else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (h < @as(c_int, 255)) h else @as(c_int, 255))) / 255.0;
    _ = &hf;
    var sf: f32 = @as(f32, @floatFromInt(if ((if (s < @as(c_int, 255)) s else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (s < @as(c_int, 255)) s else @as(c_int, 255))) / 255.0;
    _ = &sf;
    var vf: f32 = @as(f32, @floatFromInt(if ((if (v < @as(c_int, 255)) v else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (v < @as(c_int, 255)) v else @as(c_int, 255))) / 255.0;
    _ = &vf;
    var af: f32 = @as(f32, @floatFromInt(if ((if (a < @as(c_int, 255)) a else @as(c_int, 255)) < @as(c_int, 0)) @as(c_int, 0) else if (a < @as(c_int, 255)) a else @as(c_int, 255))) / 255.0;
    _ = &af;
    return nk_hsva_f(hf, sf, vf, af);
}
pub fn nk_hsva_iv(arg_c: [*c]const c_int) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_hsva(c[@as(c_uint, @intCast(@as(c_int, 0)))], c[@as(c_uint, @intCast(@as(c_int, 1)))], c[@as(c_uint, @intCast(@as(c_int, 2)))], c[@as(c_uint, @intCast(@as(c_int, 3)))]);
}
pub fn nk_hsva_bv(arg_c: [*c]const nk_byte) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_hsva(@as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 0)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 1)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 2)))]))), @as(c_int, @bitCast(@as(c_uint, c[@as(c_uint, @intCast(@as(c_int, 3)))]))));
}
pub fn nk_hsva_f(arg_h: f32, arg_s: f32, arg_v: f32, arg_a: f32) callconv(.c) struct_nk_color {
    var h = arg_h;
    _ = &h;
    var s = arg_s;
    _ = &s;
    var v = arg_v;
    _ = &v;
    var a = arg_a;
    _ = &a;
    var c: struct_nk_colorf = nk_hsva_colorf(h, s, v, a);
    _ = &c;
    return nk_rgba_f(c.r, c.g, c.b, c.a);
}
pub fn nk_hsva_fv(arg_c: [*c]const f32) callconv(.c) struct_nk_color {
    var c = arg_c;
    _ = &c;
    return nk_hsva_f(c[@as(c_uint, @intCast(@as(c_int, 0)))], c[@as(c_uint, @intCast(@as(c_int, 1)))], c[@as(c_uint, @intCast(@as(c_int, 2)))], c[@as(c_uint, @intCast(@as(c_int, 3)))]);
}
pub fn nk_color_f(arg_r: [*c]f32, arg_g: [*c]f32, arg_b: [*c]f32, arg_a: [*c]f32, arg_in: struct_nk_color) callconv(.c) void {
    var r = arg_r;
    _ = &r;
    var g = arg_g;
    _ = &g;
    var b = arg_b;
    _ = &b;
    var a = arg_a;
    _ = &a;
    var in = arg_in;
    _ = &in;
    const s = struct {
        const static: f32 = 1.0 / 255.0;
    };
    _ = &s;
    r.* = @as(f32, @floatFromInt(in.r)) * s.static;
    g.* = @as(f32, @floatFromInt(in.g)) * s.static;
    b.* = @as(f32, @floatFromInt(in.b)) * s.static;
    a.* = @as(f32, @floatFromInt(in.a)) * s.static;
}
pub fn nk_color_fv(arg_c: [*c]f32, arg_in: struct_nk_color) callconv(.c) void {
    var c = arg_c;
    _ = &c;
    var in = arg_in;
    _ = &in;
    nk_color_f(&c[@as(c_uint, @intCast(@as(c_int, 0)))], &c[@as(c_uint, @intCast(@as(c_int, 1)))], &c[@as(c_uint, @intCast(@as(c_int, 2)))], &c[@as(c_uint, @intCast(@as(c_int, 3)))], in);
}
pub fn nk_color_cf(arg_in: struct_nk_color) callconv(.c) struct_nk_colorf {
    var in = arg_in;
    _ = &in;
    var o: struct_nk_colorf = undefined;
    _ = &o;
    nk_color_f(&o.r, &o.g, &o.b, &o.a, in);
    return o;
}
pub fn nk_color_d(arg_r: [*c]f64, arg_g: [*c]f64, arg_b: [*c]f64, arg_a: [*c]f64, arg_in: struct_nk_color) callconv(.c) void {
    var r = arg_r;
    _ = &r;
    var g = arg_g;
    _ = &g;
    var b = arg_b;
    _ = &b;
    var a = arg_a;
    _ = &a;
    var in = arg_in;
    _ = &in;
    const s = struct {
        const static: f64 = 1.0 / 255.0;
    };
    _ = &s;
    r.* = @as(f64, @floatFromInt(in.r)) * s.static;
    g.* = @as(f64, @floatFromInt(in.g)) * s.static;
    b.* = @as(f64, @floatFromInt(in.b)) * s.static;
    a.* = @as(f64, @floatFromInt(in.a)) * s.static;
}
pub fn nk_color_dv(arg_c: [*c]f64, arg_in: struct_nk_color) callconv(.c) void {
    var c = arg_c;
    _ = &c;
    var in = arg_in;
    _ = &in;
    nk_color_d(&c[@as(c_uint, @intCast(@as(c_int, 0)))], &c[@as(c_uint, @intCast(@as(c_int, 1)))], &c[@as(c_uint, @intCast(@as(c_int, 2)))], &c[@as(c_uint, @intCast(@as(c_int, 3)))], in);
}
pub fn nk_color_u32(arg_in: struct_nk_color) callconv(.c) nk_uint {
    var in = arg_in;
    _ = &in;
    var out: nk_uint = @as(nk_uint, @bitCast(@as(c_uint, in.r)));
    _ = &out;
    out |= @as(nk_uint, @bitCast(@as(c_uint, in.g))) << @intCast(8);
    out |= @as(nk_uint, @bitCast(@as(c_uint, in.b))) << @intCast(16);
    out |= @as(nk_uint, @bitCast(@as(c_uint, in.a))) << @intCast(24);
    return out;
}
pub fn nk_color_hex_rgba(arg_output: [*c]u8, arg_col: struct_nk_color) callconv(.c) void {
    var output = arg_output;
    _ = &output;
    var col = arg_col;
    _ = &col;
    output[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(i8, @truncate(if (((@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 240)) >> @intCast(4)) <= @as(c_int, 9)) @as(c_int, '0') + ((@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 240)) >> @intCast(4)) else (@as(c_int, 'A') - @as(c_int, 10)) + ((@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 240)) >> @intCast(4))))));
    output[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(i8, @truncate(if ((@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 15)) <= @as(c_int, 9)) @as(c_int, '0') + (@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 15)) else (@as(c_int, 'A') - @as(c_int, 10)) + (@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 15))))));
    output[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(i8, @truncate(if (((@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 240)) >> @intCast(4)) <= @as(c_int, 9)) @as(c_int, '0') + ((@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 240)) >> @intCast(4)) else (@as(c_int, 'A') - @as(c_int, 10)) + ((@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 240)) >> @intCast(4))))));
    output[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(i8, @truncate(if ((@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 15)) <= @as(c_int, 9)) @as(c_int, '0') + (@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 15)) else (@as(c_int, 'A') - @as(c_int, 10)) + (@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 15))))));
    output[@as(c_uint, @intCast(@as(c_int, 4)))] = @as(u8, @bitCast(@as(i8, @truncate(if (((@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 240)) >> @intCast(4)) <= @as(c_int, 9)) @as(c_int, '0') + ((@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 240)) >> @intCast(4)) else (@as(c_int, 'A') - @as(c_int, 10)) + ((@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 240)) >> @intCast(4))))));
    output[@as(c_uint, @intCast(@as(c_int, 5)))] = @as(u8, @bitCast(@as(i8, @truncate(if ((@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 15)) <= @as(c_int, 9)) @as(c_int, '0') + (@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 15)) else (@as(c_int, 'A') - @as(c_int, 10)) + (@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 15))))));
    output[@as(c_uint, @intCast(@as(c_int, 6)))] = @as(u8, @bitCast(@as(i8, @truncate(if (((@as(c_int, @bitCast(@as(c_uint, col.a))) & @as(c_int, 240)) >> @intCast(4)) <= @as(c_int, 9)) @as(c_int, '0') + ((@as(c_int, @bitCast(@as(c_uint, col.a))) & @as(c_int, 240)) >> @intCast(4)) else (@as(c_int, 'A') - @as(c_int, 10)) + ((@as(c_int, @bitCast(@as(c_uint, col.a))) & @as(c_int, 240)) >> @intCast(4))))));
    output[@as(c_uint, @intCast(@as(c_int, 7)))] = @as(u8, @bitCast(@as(i8, @truncate(if ((@as(c_int, @bitCast(@as(c_uint, col.a))) & @as(c_int, 15)) <= @as(c_int, 9)) @as(c_int, '0') + (@as(c_int, @bitCast(@as(c_uint, col.a))) & @as(c_int, 15)) else (@as(c_int, 'A') - @as(c_int, 10)) + (@as(c_int, @bitCast(@as(c_uint, col.a))) & @as(c_int, 15))))));
    output[@as(c_uint, @intCast(@as(c_int, 8)))] = '\x00';
}
pub fn nk_color_hex_rgb(arg_output: [*c]u8, arg_col: struct_nk_color) callconv(.c) void {
    var output = arg_output;
    _ = &output;
    var col = arg_col;
    _ = &col;
    output[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(u8, @bitCast(@as(i8, @truncate(if (((@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 240)) >> @intCast(4)) <= @as(c_int, 9)) @as(c_int, '0') + ((@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 240)) >> @intCast(4)) else (@as(c_int, 'A') - @as(c_int, 10)) + ((@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 240)) >> @intCast(4))))));
    output[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(u8, @bitCast(@as(i8, @truncate(if ((@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 15)) <= @as(c_int, 9)) @as(c_int, '0') + (@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 15)) else (@as(c_int, 'A') - @as(c_int, 10)) + (@as(c_int, @bitCast(@as(c_uint, col.r))) & @as(c_int, 15))))));
    output[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(u8, @bitCast(@as(i8, @truncate(if (((@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 240)) >> @intCast(4)) <= @as(c_int, 9)) @as(c_int, '0') + ((@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 240)) >> @intCast(4)) else (@as(c_int, 'A') - @as(c_int, 10)) + ((@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 240)) >> @intCast(4))))));
    output[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(u8, @bitCast(@as(i8, @truncate(if ((@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 15)) <= @as(c_int, 9)) @as(c_int, '0') + (@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 15)) else (@as(c_int, 'A') - @as(c_int, 10)) + (@as(c_int, @bitCast(@as(c_uint, col.g))) & @as(c_int, 15))))));
    output[@as(c_uint, @intCast(@as(c_int, 4)))] = @as(u8, @bitCast(@as(i8, @truncate(if (((@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 240)) >> @intCast(4)) <= @as(c_int, 9)) @as(c_int, '0') + ((@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 240)) >> @intCast(4)) else (@as(c_int, 'A') - @as(c_int, 10)) + ((@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 240)) >> @intCast(4))))));
    output[@as(c_uint, @intCast(@as(c_int, 5)))] = @as(u8, @bitCast(@as(i8, @truncate(if ((@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 15)) <= @as(c_int, 9)) @as(c_int, '0') + (@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 15)) else (@as(c_int, 'A') - @as(c_int, 10)) + (@as(c_int, @bitCast(@as(c_uint, col.b))) & @as(c_int, 15))))));
    output[@as(c_uint, @intCast(@as(c_int, 6)))] = '\x00';
}
pub fn nk_color_hsv_i(arg_out_h: [*c]c_int, arg_out_s: [*c]c_int, arg_out_v: [*c]c_int, arg_in: struct_nk_color) callconv(.c) void {
    var out_h = arg_out_h;
    _ = &out_h;
    var out_s = arg_out_s;
    _ = &out_s;
    var out_v = arg_out_v;
    _ = &out_v;
    var in = arg_in;
    _ = &in;
    var a: c_int = undefined;
    _ = &a;
    nk_color_hsva_i(out_h, out_s, out_v, &a, in);
}
pub fn nk_color_hsv_b(arg_out_h: [*c]nk_byte, arg_out_s: [*c]nk_byte, arg_out_v: [*c]nk_byte, arg_in: struct_nk_color) callconv(.c) void {
    var out_h = arg_out_h;
    _ = &out_h;
    var out_s = arg_out_s;
    _ = &out_s;
    var out_v = arg_out_v;
    _ = &out_v;
    var in = arg_in;
    _ = &in;
    var tmp: [4]c_int = undefined;
    _ = &tmp;
    nk_color_hsva_i(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))], &tmp[@as(c_uint, @intCast(@as(c_int, 1)))], &tmp[@as(c_uint, @intCast(@as(c_int, 2)))], &tmp[@as(c_uint, @intCast(@as(c_int, 3)))], in);
    out_h.* = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))));
    out_s.* = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 1)))]))));
    out_v.* = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 2)))]))));
}
pub fn nk_color_hsv_iv(arg_out: [*c]c_int, arg_in: struct_nk_color) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var in = arg_in;
    _ = &in;
    nk_color_hsv_i(&out[@as(c_uint, @intCast(@as(c_int, 0)))], &out[@as(c_uint, @intCast(@as(c_int, 1)))], &out[@as(c_uint, @intCast(@as(c_int, 2)))], in);
}
pub fn nk_color_hsv_bv(arg_out: [*c]nk_byte, arg_in: struct_nk_color) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var in = arg_in;
    _ = &in;
    var tmp: [4]c_int = undefined;
    _ = &tmp;
    nk_color_hsv_i(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))], &tmp[@as(c_uint, @intCast(@as(c_int, 1)))], &tmp[@as(c_uint, @intCast(@as(c_int, 2)))], in);
    out[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))));
    out[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 1)))]))));
    out[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 2)))]))));
}
pub fn nk_color_hsv_f(arg_out_h: [*c]f32, arg_out_s: [*c]f32, arg_out_v: [*c]f32, arg_in: struct_nk_color) callconv(.c) void {
    var out_h = arg_out_h;
    _ = &out_h;
    var out_s = arg_out_s;
    _ = &out_s;
    var out_v = arg_out_v;
    _ = &out_v;
    var in = arg_in;
    _ = &in;
    var a: f32 = undefined;
    _ = &a;
    nk_color_hsva_f(out_h, out_s, out_v, &a, in);
}
pub fn nk_color_hsv_fv(arg_out: [*c]f32, arg_in: struct_nk_color) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var in = arg_in;
    _ = &in;
    var a: f32 = undefined;
    _ = &a;
    nk_color_hsva_f(&out[@as(c_uint, @intCast(@as(c_int, 0)))], &out[@as(c_uint, @intCast(@as(c_int, 1)))], &out[@as(c_uint, @intCast(@as(c_int, 2)))], &a, in);
}
pub fn nk_color_hsva_i(arg_out_h: [*c]c_int, arg_out_s: [*c]c_int, arg_out_v: [*c]c_int, arg_out_a: [*c]c_int, arg_in: struct_nk_color) callconv(.c) void {
    var out_h = arg_out_h;
    _ = &out_h;
    var out_s = arg_out_s;
    _ = &out_s;
    var out_v = arg_out_v;
    _ = &out_v;
    var out_a = arg_out_a;
    _ = &out_a;
    var in = arg_in;
    _ = &in;
    var h: f32 = undefined;
    _ = &h;
    var s: f32 = undefined;
    _ = &s;
    var v: f32 = undefined;
    _ = &v;
    var a: f32 = undefined;
    _ = &a;
    nk_color_hsva_f(&h, &s, &v, &a, in);
    out_h.* = @as(c_int, @bitCast(@as(c_uint, @as(nk_byte, @intFromFloat(h * 255.0)))));
    out_s.* = @as(c_int, @bitCast(@as(c_uint, @as(nk_byte, @intFromFloat(s * 255.0)))));
    out_v.* = @as(c_int, @bitCast(@as(c_uint, @as(nk_byte, @intFromFloat(v * 255.0)))));
    out_a.* = @as(c_int, @bitCast(@as(c_uint, @as(nk_byte, @intFromFloat(a * 255.0)))));
}
pub fn nk_color_hsva_b(arg_h: [*c]nk_byte, arg_s: [*c]nk_byte, arg_v: [*c]nk_byte, arg_a: [*c]nk_byte, arg_in: struct_nk_color) callconv(.c) void {
    var h = arg_h;
    _ = &h;
    var s = arg_s;
    _ = &s;
    var v = arg_v;
    _ = &v;
    var a = arg_a;
    _ = &a;
    var in = arg_in;
    _ = &in;
    var tmp: [4]c_int = undefined;
    _ = &tmp;
    nk_color_hsva_i(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))], &tmp[@as(c_uint, @intCast(@as(c_int, 1)))], &tmp[@as(c_uint, @intCast(@as(c_int, 2)))], &tmp[@as(c_uint, @intCast(@as(c_int, 3)))], in);
    h.* = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))));
    s.* = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 1)))]))));
    v.* = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 2)))]))));
    a.* = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 3)))]))));
}
pub fn nk_color_hsva_iv(arg_out: [*c]c_int, arg_in: struct_nk_color) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var in = arg_in;
    _ = &in;
    nk_color_hsva_i(&out[@as(c_uint, @intCast(@as(c_int, 0)))], &out[@as(c_uint, @intCast(@as(c_int, 1)))], &out[@as(c_uint, @intCast(@as(c_int, 2)))], &out[@as(c_uint, @intCast(@as(c_int, 3)))], in);
}
pub fn nk_color_hsva_bv(arg_out: [*c]nk_byte, arg_in: struct_nk_color) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var in = arg_in;
    _ = &in;
    var tmp: [4]c_int = undefined;
    _ = &tmp;
    nk_color_hsva_i(&tmp[@as(c_uint, @intCast(@as(c_int, 0)))], &tmp[@as(c_uint, @intCast(@as(c_int, 1)))], &tmp[@as(c_uint, @intCast(@as(c_int, 2)))], &tmp[@as(c_uint, @intCast(@as(c_int, 3)))], in);
    out[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 0)))]))));
    out[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 1)))]))));
    out[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 2)))]))));
    out[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_byte, @bitCast(@as(i8, @truncate(tmp[@as(c_uint, @intCast(@as(c_int, 3)))]))));
}
pub fn nk_color_hsva_f(arg_out_h: [*c]f32, arg_out_s: [*c]f32, arg_out_v: [*c]f32, arg_out_a: [*c]f32, arg_in: struct_nk_color) callconv(.c) void {
    var out_h = arg_out_h;
    _ = &out_h;
    var out_s = arg_out_s;
    _ = &out_s;
    var out_v = arg_out_v;
    _ = &out_v;
    var out_a = arg_out_a;
    _ = &out_a;
    var in = arg_in;
    _ = &in;
    var col: struct_nk_colorf = undefined;
    _ = &col;
    nk_color_f(&col.r, &col.g, &col.b, &col.a, in);
    nk_colorf_hsva_f(out_h, out_s, out_v, out_a, col);
}
pub fn nk_color_hsva_fv(arg_out: [*c]f32, arg_in: struct_nk_color) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var in = arg_in;
    _ = &in;
    nk_color_hsva_f(&out[@as(c_uint, @intCast(@as(c_int, 0)))], &out[@as(c_uint, @intCast(@as(c_int, 1)))], &out[@as(c_uint, @intCast(@as(c_int, 2)))], &out[@as(c_uint, @intCast(@as(c_int, 3)))], in);
}
pub fn nk_handle_ptr(arg_ptr: ?*anyopaque) callconv(.c) nk_handle {
    var ptr = arg_ptr;
    _ = &ptr;
    var handle: nk_handle = nk_handle{
        .ptr = null,
    };
    _ = &handle;
    handle.ptr = ptr;
    return handle;
}
pub fn nk_handle_id(arg_id: c_int) callconv(.c) nk_handle {
    var id = arg_id;
    _ = &id;
    var handle: nk_handle = undefined;
    _ = &handle;
    nk_zero(@as(?*anyopaque, @ptrCast(&handle)), @sizeOf(nk_handle));
    handle.id = id;
    return handle;
}
pub fn nk_image_handle(arg_handle: nk_handle) callconv(.c) struct_nk_image {
    var handle = arg_handle;
    _ = &handle;
    var s: struct_nk_image = undefined;
    _ = &s;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_image));
    s.handle = handle;
    s.w = 0;
    s.h = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
    return s;
}
pub fn nk_image_ptr(arg_ptr: ?*anyopaque) callconv(.c) struct_nk_image {
    var ptr = arg_ptr;
    _ = &ptr;
    var s: struct_nk_image = undefined;
    _ = &s;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_image));
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ptr != null) {} else {
                __assert_fail("ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24160))), "struct nk_image nk_image_ptr(void *)");
            };
        };
    };
    s.handle.ptr = ptr;
    s.w = 0;
    s.h = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
    return s;
}
pub fn nk_image_id(arg_id: c_int) callconv(.c) struct_nk_image {
    var id = arg_id;
    _ = &id;
    var s: struct_nk_image = undefined;
    _ = &s;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_image));
    s.handle.id = id;
    s.w = 0;
    s.h = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    s.region[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
    return s;
}
pub fn nk_image_is_subimage(arg_img: [*c]const struct_nk_image) callconv(.c) nk_bool {
    var img = arg_img;
    _ = &img;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (img != null) {} else {
                __assert_fail("img", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24185))), "nk_bool nk_image_is_subimage(const struct nk_image *)");
            };
        };
    };
    return @intFromBool(!((@as(c_int, @bitCast(@as(c_uint, img.*.w))) == @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, img.*.h))) == @as(c_int, 0))));
}
pub fn nk_subimage_ptr(arg_ptr: ?*anyopaque, arg_w: nk_ushort, arg_h: nk_ushort, arg_r: struct_nk_rect) callconv(.c) struct_nk_image {
    var ptr = arg_ptr;
    _ = &ptr;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    var r = arg_r;
    _ = &r;
    var s: struct_nk_image = undefined;
    _ = &s;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_image));
    s.handle.ptr = ptr;
    s.w = w;
    s.h = h;
    s.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @intFromFloat(r.x));
    s.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @intFromFloat(r.y));
    s.region[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_ushort, @intFromFloat(r.w));
    s.region[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_ushort, @intFromFloat(r.h));
    return s;
}
pub fn nk_subimage_id(arg_id: c_int, arg_w: nk_ushort, arg_h: nk_ushort, arg_r: struct_nk_rect) callconv(.c) struct_nk_image {
    var id = arg_id;
    _ = &id;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    var r = arg_r;
    _ = &r;
    var s: struct_nk_image = undefined;
    _ = &s;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_image));
    s.handle.id = id;
    s.w = w;
    s.h = h;
    s.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @intFromFloat(r.x));
    s.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @intFromFloat(r.y));
    s.region[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_ushort, @intFromFloat(r.w));
    s.region[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_ushort, @intFromFloat(r.h));
    return s;
}
pub fn nk_subimage_handle(arg_handle: nk_handle, arg_w: nk_ushort, arg_h: nk_ushort, arg_r: struct_nk_rect) callconv(.c) struct_nk_image {
    var handle = arg_handle;
    _ = &handle;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    var r = arg_r;
    _ = &r;
    var s: struct_nk_image = undefined;
    _ = &s;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_image));
    s.handle = handle;
    s.w = w;
    s.h = h;
    s.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @intFromFloat(r.x));
    s.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @intFromFloat(r.y));
    s.region[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_ushort, @intFromFloat(r.w));
    s.region[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_ushort, @intFromFloat(r.h));
    return s;
}
pub fn nk_nine_slice_handle(arg_handle: nk_handle, arg_l: nk_ushort, arg_t: nk_ushort, arg_r: nk_ushort, arg_b: nk_ushort) callconv(.c) struct_nk_nine_slice {
    var handle = arg_handle;
    _ = &handle;
    var l = arg_l;
    _ = &l;
    var t = arg_t;
    _ = &t;
    var r = arg_r;
    _ = &r;
    var b = arg_b;
    _ = &b;
    var s: struct_nk_nine_slice = undefined;
    _ = &s;
    var i: [*c]struct_nk_image = &s.img;
    _ = &i;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_nine_slice));
    i.*.handle = handle;
    i.*.w = 0;
    i.*.h = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
    s.l = l;
    s.t = t;
    s.r = r;
    s.b = b;
    return s;
}
pub fn nk_nine_slice_ptr(arg_ptr: ?*anyopaque, arg_l: nk_ushort, arg_t: nk_ushort, arg_r: nk_ushort, arg_b: nk_ushort) callconv(.c) struct_nk_nine_slice {
    var ptr = arg_ptr;
    _ = &ptr;
    var l = arg_l;
    _ = &l;
    var t = arg_t;
    _ = &t;
    var r = arg_r;
    _ = &r;
    var b = arg_b;
    _ = &b;
    var s: struct_nk_nine_slice = undefined;
    _ = &s;
    var i: [*c]struct_nk_image = &s.img;
    _ = &i;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_nine_slice));
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ptr != null) {} else {
                __assert_fail("ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24294))), "struct nk_nine_slice nk_nine_slice_ptr(void *, nk_ushort, nk_ushort, nk_ushort, nk_ushort)");
            };
        };
    };
    i.*.handle.ptr = ptr;
    i.*.w = 0;
    i.*.h = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
    s.l = l;
    s.t = t;
    s.r = r;
    s.b = b;
    return s;
}
pub fn nk_nine_slice_id(arg_id: c_int, arg_l: nk_ushort, arg_t: nk_ushort, arg_r: nk_ushort, arg_b: nk_ushort) callconv(.c) struct_nk_nine_slice {
    var id = arg_id;
    _ = &id;
    var l = arg_l;
    _ = &l;
    var t = arg_t;
    _ = &t;
    var r = arg_r;
    _ = &r;
    var b = arg_b;
    _ = &b;
    var s: struct_nk_nine_slice = undefined;
    _ = &s;
    var i: [*c]struct_nk_image = &s.img;
    _ = &i;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_nine_slice));
    i.*.handle.id = id;
    i.*.w = 0;
    i.*.h = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 0)))] = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 1)))] = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 2)))] = 0;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 3)))] = 0;
    s.l = l;
    s.t = t;
    s.r = r;
    s.b = b;
    return s;
}
pub fn nk_nine_slice_is_sub9slice(arg_slice: [*c]const struct_nk_nine_slice) callconv(.c) c_int {
    var slice = arg_slice;
    _ = &slice;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (slice != null) {} else {
                __assert_fail("slice", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24322))), "int nk_nine_slice_is_sub9slice(const struct nk_nine_slice *)");
            };
        };
    };
    return @intFromBool(!((@as(c_int, @bitCast(@as(c_uint, slice.*.img.w))) == @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, slice.*.img.h))) == @as(c_int, 0))));
}
pub fn nk_sub9slice_ptr(arg_ptr: ?*anyopaque, arg_w: nk_ushort, arg_h: nk_ushort, arg_rgn: struct_nk_rect, arg_l: nk_ushort, arg_t: nk_ushort, arg_r: nk_ushort, arg_b: nk_ushort) callconv(.c) struct_nk_nine_slice {
    var ptr = arg_ptr;
    _ = &ptr;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    var rgn = arg_rgn;
    _ = &rgn;
    var l = arg_l;
    _ = &l;
    var t = arg_t;
    _ = &t;
    var r = arg_r;
    _ = &r;
    var b = arg_b;
    _ = &b;
    var s: struct_nk_nine_slice = undefined;
    _ = &s;
    var i: [*c]struct_nk_image = &s.img;
    _ = &i;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_nine_slice));
    i.*.handle.ptr = ptr;
    i.*.w = w;
    i.*.h = h;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @intFromFloat(rgn.x));
    i.*.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @intFromFloat(rgn.y));
    i.*.region[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_ushort, @intFromFloat(rgn.w));
    i.*.region[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_ushort, @intFromFloat(rgn.h));
    s.l = l;
    s.t = t;
    s.r = r;
    s.b = b;
    return s;
}
pub fn nk_sub9slice_id(arg_id: c_int, arg_w: nk_ushort, arg_h: nk_ushort, arg_rgn: struct_nk_rect, arg_l: nk_ushort, arg_t: nk_ushort, arg_r: nk_ushort, arg_b: nk_ushort) callconv(.c) struct_nk_nine_slice {
    var id = arg_id;
    _ = &id;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    var rgn = arg_rgn;
    _ = &rgn;
    var l = arg_l;
    _ = &l;
    var t = arg_t;
    _ = &t;
    var r = arg_r;
    _ = &r;
    var b = arg_b;
    _ = &b;
    var s: struct_nk_nine_slice = undefined;
    _ = &s;
    var i: [*c]struct_nk_image = &s.img;
    _ = &i;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_nine_slice));
    i.*.handle.id = id;
    i.*.w = w;
    i.*.h = h;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @intFromFloat(rgn.x));
    i.*.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @intFromFloat(rgn.y));
    i.*.region[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_ushort, @intFromFloat(rgn.w));
    i.*.region[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_ushort, @intFromFloat(rgn.h));
    s.l = l;
    s.t = t;
    s.r = r;
    s.b = b;
    return s;
}
pub fn nk_sub9slice_handle(arg_handle: nk_handle, arg_w: nk_ushort, arg_h: nk_ushort, arg_rgn: struct_nk_rect, arg_l: nk_ushort, arg_t: nk_ushort, arg_r: nk_ushort, arg_b: nk_ushort) callconv(.c) struct_nk_nine_slice {
    var handle = arg_handle;
    _ = &handle;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    var rgn = arg_rgn;
    _ = &rgn;
    var l = arg_l;
    _ = &l;
    var t = arg_t;
    _ = &t;
    var r = arg_r;
    _ = &r;
    var b = arg_b;
    _ = &b;
    var s: struct_nk_nine_slice = undefined;
    _ = &s;
    var i: [*c]struct_nk_image = &s.img;
    _ = &i;
    nk_zero(@as(?*anyopaque, @ptrCast(&s)), @sizeOf(struct_nk_nine_slice));
    i.*.handle = handle;
    i.*.w = w;
    i.*.h = h;
    i.*.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @intFromFloat(rgn.x));
    i.*.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @intFromFloat(rgn.y));
    i.*.region[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_ushort, @intFromFloat(rgn.w));
    i.*.region[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_ushort, @intFromFloat(rgn.h));
    s.l = l;
    s.t = t;
    s.r = r;
    s.b = b;
    return s;
}
pub fn nk_murmur_hash(arg_key: ?*const anyopaque, arg_len: c_int, arg_seed: nk_hash) callconv(.c) nk_hash {
    var key = arg_key;
    _ = &key;
    var len = arg_len;
    _ = &len;
    var seed = arg_seed;
    _ = &seed;
    var h1: nk_uint = seed;
    _ = &h1;
    var k1: nk_uint = undefined;
    _ = &k1;
    var data: [*c]const nk_byte = @as([*c]const nk_byte, @ptrCast(@alignCast(key)));
    _ = &data;
    var keyptr: [*c]const nk_byte = data;
    _ = &keyptr;
    var k1ptr: [*c]nk_byte = undefined;
    _ = &k1ptr;
    const bsize: c_int = @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf(nk_uint)))));
    _ = &bsize;
    const nblocks: c_int = @divTrunc(len, @as(c_int, 4));
    _ = &nblocks;
    const c1: nk_uint = 3432918353;
    _ = &c1;
    const c2: nk_uint = @as(nk_uint, @bitCast(@as(c_int, 461845907)));
    _ = &c2;
    var tail: [*c]const nk_byte = undefined;
    _ = &tail;
    var i: c_int = undefined;
    _ = &i;
    if (!(key != null)) return 0;
    {
        i = 0;
        while (i < nblocks) : (_ = blk: {
            i += 1;
            break :blk blk_1: {
                const ref = &keyptr;
                ref.* += @as(usize, @bitCast(@as(isize, @intCast(bsize))));
                break :blk_1 ref.*;
            };
        }) {
            k1ptr = @as([*c]nk_byte, @ptrCast(@alignCast(&k1)));
            k1ptr[@as(c_uint, @intCast(@as(c_int, 0)))] = keyptr[@as(c_uint, @intCast(@as(c_int, 0)))];
            k1ptr[@as(c_uint, @intCast(@as(c_int, 1)))] = keyptr[@as(c_uint, @intCast(@as(c_int, 1)))];
            k1ptr[@as(c_uint, @intCast(@as(c_int, 2)))] = keyptr[@as(c_uint, @intCast(@as(c_int, 2)))];
            k1ptr[@as(c_uint, @intCast(@as(c_int, 3)))] = keyptr[@as(c_uint, @intCast(@as(c_int, 3)))];
            k1 *%= c1;
            k1 = (k1 << @intCast(@as(c_int, 15))) | (k1 >> @intCast(@as(c_int, 32) - @as(c_int, 15)));
            k1 *%= c2;
            h1 ^= k1;
            h1 = (h1 << @intCast(@as(c_int, 13))) | (h1 >> @intCast(@as(c_int, 32) - @as(c_int, 13)));
            h1 = (h1 *% @as(nk_uint, @bitCast(@as(c_int, 5)))) +% @as(c_uint, 3864292196);
        }
    }
    tail = data + @as(usize, @bitCast(@as(isize, @intCast(nblocks * @as(c_int, 4)))));
    k1 = 0;
    while (true) {
        switch (len & @as(c_int, 3)) {
            @as(c_int, 3) => {
                k1 ^= @as(nk_uint, @bitCast(@as(c_int, @bitCast(@as(c_uint, tail[@as(c_uint, @intCast(@as(c_int, 2)))]))) << @intCast(16)));
                k1 ^= @as(nk_uint, @bitCast(@as(c_int, @bitCast(@as(c_uint, tail[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8)));
                k1 ^= @as(nk_uint, @bitCast(@as(c_uint, tail[@as(c_uint, @intCast(@as(c_int, 0)))])));
                k1 *%= c1;
                k1 = (k1 << @intCast(@as(c_int, 15))) | (k1 >> @intCast(@as(c_int, 32) - @as(c_int, 15)));
                k1 *%= c2;
                h1 ^= k1;
                break;
            },
            @as(c_int, 2) => {
                k1 ^= @as(nk_uint, @bitCast(@as(c_int, @bitCast(@as(c_uint, tail[@as(c_uint, @intCast(@as(c_int, 1)))]))) << @intCast(8)));
                k1 ^= @as(nk_uint, @bitCast(@as(c_uint, tail[@as(c_uint, @intCast(@as(c_int, 0)))])));
                k1 *%= c1;
                k1 = (k1 << @intCast(@as(c_int, 15))) | (k1 >> @intCast(@as(c_int, 32) - @as(c_int, 15)));
                k1 *%= c2;
                h1 ^= k1;
                break;
            },
            @as(c_int, 1) => {
                k1 ^= @as(nk_uint, @bitCast(@as(c_uint, tail[@as(c_uint, @intCast(@as(c_int, 0)))])));
                k1 *%= c1;
                k1 = (k1 << @intCast(@as(c_int, 15))) | (k1 >> @intCast(@as(c_int, 32) - @as(c_int, 15)));
                k1 *%= c2;
                h1 ^= k1;
                break;
            },
            else => break,
        }
        break;
    }
    h1 ^= @as(nk_uint, @bitCast(len));
    h1 ^= h1 >> @intCast(16);
    h1 *%= @as(nk_uint, @bitCast(@as(c_uint, 2246822507)));
    h1 ^= h1 >> @intCast(13);
    h1 *%= @as(nk_uint, @bitCast(@as(c_uint, 3266489909)));
    h1 ^= h1 >> @intCast(16);
    return h1;
}
pub fn nk_triangle_from_direction(arg_result: [*c]struct_nk_vec2, arg_r: struct_nk_rect, arg_pad_x: f32, arg_pad_y: f32, arg_direction: enum_nk_heading) callconv(.c) void {
    var result = arg_result;
    _ = &result;
    var r = arg_r;
    _ = &r;
    var pad_x = arg_pad_x;
    _ = &pad_x;
    var pad_y = arg_pad_y;
    _ = &pad_y;
    var direction = arg_direction;
    _ = &direction;
    var w_half: f32 = undefined;
    _ = &w_half;
    var h_half: f32 = undefined;
    _ = &h_half;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (result != null) {} else {
                __assert_fail("result", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 6751))), "void nk_triangle_from_direction(struct nk_vec2 *, struct nk_rect, float, float, enum nk_heading)");
            };
        };
    };
    r.w = if ((@as(f32, @floatFromInt(@as(c_int, 2))) * pad_x) < r.w) r.w else @as(f32, @floatFromInt(@as(c_int, 2))) * pad_x;
    r.h = if ((@as(f32, @floatFromInt(@as(c_int, 2))) * pad_y) < r.h) r.h else @as(f32, @floatFromInt(@as(c_int, 2))) * pad_y;
    r.w = r.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * pad_x);
    r.h = r.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * pad_y);
    r.x = r.x + pad_x;
    r.y = r.y + pad_y;
    w_half = r.w / 2.0;
    h_half = r.h / 2.0;
    if (direction == @as(c_uint, @bitCast(NK_UP))) {
        result[@as(c_uint, @intCast(@as(c_int, 0)))] = nk_vec2(r.x + w_half, r.y);
        result[@as(c_uint, @intCast(@as(c_int, 1)))] = nk_vec2(r.x + r.w, r.y + r.h);
        result[@as(c_uint, @intCast(@as(c_int, 2)))] = nk_vec2(r.x, r.y + r.h);
    } else if (direction == @as(c_uint, @bitCast(NK_RIGHT))) {
        result[@as(c_uint, @intCast(@as(c_int, 0)))] = nk_vec2(r.x, r.y);
        result[@as(c_uint, @intCast(@as(c_int, 1)))] = nk_vec2(r.x + r.w, r.y + h_half);
        result[@as(c_uint, @intCast(@as(c_int, 2)))] = nk_vec2(r.x, r.y + r.h);
    } else if (direction == @as(c_uint, @bitCast(NK_DOWN))) {
        result[@as(c_uint, @intCast(@as(c_int, 0)))] = nk_vec2(r.x, r.y);
        result[@as(c_uint, @intCast(@as(c_int, 1)))] = nk_vec2(r.x + r.w, r.y);
        result[@as(c_uint, @intCast(@as(c_int, 2)))] = nk_vec2(r.x + w_half, r.y + r.h);
    } else {
        result[@as(c_uint, @intCast(@as(c_int, 0)))] = nk_vec2(r.x, r.y + h_half);
        result[@as(c_uint, @intCast(@as(c_int, 1)))] = nk_vec2(r.x + r.w, r.y);
        result[@as(c_uint, @intCast(@as(c_int, 2)))] = nk_vec2(r.x + r.w, r.y + r.h);
    }
}
pub fn nk_vec2(arg_x: f32, arg_y: f32) callconv(.c) struct_nk_vec2 {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var ret: struct_nk_vec2 = undefined;
    _ = &ret;
    ret.x = x;
    ret.y = y;
    return ret;
}
pub fn nk_vec2i(arg_x: c_int, arg_y: c_int) callconv(.c) struct_nk_vec2 {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var ret: struct_nk_vec2 = undefined;
    _ = &ret;
    ret.x = @as(f32, @floatFromInt(x));
    ret.y = @as(f32, @floatFromInt(y));
    return ret;
}
pub fn nk_vec2v(arg_v: [*c]const f32) callconv(.c) struct_nk_vec2 {
    var v = arg_v;
    _ = &v;
    return nk_vec2(v[@as(c_uint, @intCast(@as(c_int, 0)))], v[@as(c_uint, @intCast(@as(c_int, 1)))]);
}
pub fn nk_vec2iv(arg_v: [*c]const c_int) callconv(.c) struct_nk_vec2 {
    var v = arg_v;
    _ = &v;
    return nk_vec2i(v[@as(c_uint, @intCast(@as(c_int, 0)))], v[@as(c_uint, @intCast(@as(c_int, 1)))]);
}
pub fn nk_get_null_rect() callconv(.c) struct_nk_rect {
    return nk_null_rect;
}
pub fn nk_rect(arg_x: f32, arg_y: f32, arg_w: f32, arg_h: f32) callconv(.c) struct_nk_rect {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    var r: struct_nk_rect = undefined;
    _ = &r;
    r.x = x;
    r.y = y;
    r.w = w;
    r.h = h;
    return r;
}
pub fn nk_recti(arg_x: c_int, arg_y: c_int, arg_w: c_int, arg_h: c_int) callconv(.c) struct_nk_rect {
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var w = arg_w;
    _ = &w;
    var h = arg_h;
    _ = &h;
    var r: struct_nk_rect = undefined;
    _ = &r;
    r.x = @as(f32, @floatFromInt(x));
    r.y = @as(f32, @floatFromInt(y));
    r.w = @as(f32, @floatFromInt(w));
    r.h = @as(f32, @floatFromInt(h));
    return r;
}
pub fn nk_recta(arg_pos: struct_nk_vec2, arg_size: struct_nk_vec2) callconv(.c) struct_nk_rect {
    var pos = arg_pos;
    _ = &pos;
    var size = arg_size;
    _ = &size;
    return nk_rect(pos.x, pos.y, size.x, size.y);
}
pub fn nk_rectv(arg_r: [*c]const f32) callconv(.c) struct_nk_rect {
    var r = arg_r;
    _ = &r;
    return nk_rect(r[@as(c_uint, @intCast(@as(c_int, 0)))], r[@as(c_uint, @intCast(@as(c_int, 1)))], r[@as(c_uint, @intCast(@as(c_int, 2)))], r[@as(c_uint, @intCast(@as(c_int, 3)))]);
}
pub fn nk_rectiv(arg_r: [*c]const c_int) callconv(.c) struct_nk_rect {
    var r = arg_r;
    _ = &r;
    return nk_recti(r[@as(c_uint, @intCast(@as(c_int, 0)))], r[@as(c_uint, @intCast(@as(c_int, 1)))], r[@as(c_uint, @intCast(@as(c_int, 2)))], r[@as(c_uint, @intCast(@as(c_int, 3)))]);
}
pub fn nk_rect_pos(arg_r: struct_nk_rect) callconv(.c) struct_nk_vec2 {
    var r = arg_r;
    _ = &r;
    var ret: struct_nk_vec2 = undefined;
    _ = &ret;
    ret.x = r.x;
    ret.y = r.y;
    return ret;
}
pub fn nk_rect_size(arg_r: struct_nk_rect) callconv(.c) struct_nk_vec2 {
    var r = arg_r;
    _ = &r;
    var ret: struct_nk_vec2 = undefined;
    _ = &ret;
    ret.x = r.w;
    ret.y = r.h;
    return ret;
}
pub fn nk_strlen(arg_str: [*c]const u8) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var siz: c_int = 0;
    _ = &siz;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 6922))), "int nk_strlen(const char *)");
            };
        };
    };
    while ((str != null) and (@as(c_int, @bitCast(@as(c_uint, (blk: {
        const ref = &str;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }).*))) != @as(c_int, '\x00'))) {
        siz += 1;
    }
    return siz;
}
pub fn nk_stricmp(arg_s1: [*c]const u8, arg_s2: [*c]const u8) callconv(.c) c_int {
    var s1 = arg_s1;
    _ = &s1;
    var s2 = arg_s2;
    _ = &s2;
    var c1: nk_int = undefined;
    _ = &c1;
    var c2: nk_int = undefined;
    _ = &c2;
    var d: nk_int = undefined;
    _ = &d;
    while (true) {
        c1 = @as(nk_int, @bitCast(@as(c_uint, (blk: {
            const ref = &s1;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*)));
        c2 = @as(nk_int, @bitCast(@as(c_uint, (blk: {
            const ref = &s2;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*)));
        d = c1 - c2;
        while (d != 0) {
            if ((c1 <= @as(c_int, 'Z')) and (c1 >= @as(c_int, 'A'))) {
                d += @as(nk_int, @bitCast(@as(c_int, 'a') - @as(c_int, 'A')));
                if (!(d != 0)) break;
            }
            if ((c2 <= @as(c_int, 'Z')) and (c2 >= @as(c_int, 'A'))) {
                d -= @as(nk_int, @bitCast(@as(c_int, 'a') - @as(c_int, 'A')));
                if (!(d != 0)) break;
            }
            return ((d >= @as(c_int, 0)) << @intCast(1)) - @as(c_int, 1);
        }
        if (!(c1 != 0)) break;
    }
    return 0;
}
pub fn nk_stricmpn(arg_s1: [*c]const u8, arg_s2: [*c]const u8, arg_n: c_int) callconv(.c) c_int {
    var s1 = arg_s1;
    _ = &s1;
    var s2 = arg_s2;
    _ = &s2;
    var n = arg_n;
    _ = &n;
    var c1: c_int = undefined;
    _ = &c1;
    var c2: c_int = undefined;
    _ = &c2;
    var d: c_int = undefined;
    _ = &d;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (n >= @as(c_int, 0)) {} else {
                __assert_fail("n >= 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 7042))), "int nk_stricmpn(const char *, const char *, int)");
            };
        };
    };
    while (true) {
        c1 = @as(c_int, @bitCast(@as(c_uint, (blk: {
            const ref = &s1;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*)));
        c2 = @as(c_int, @bitCast(@as(c_uint, (blk: {
            const ref = &s2;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*)));
        if (!((blk: {
            const ref = &n;
            const tmp = ref.*;
            ref.* -= 1;
            break :blk tmp;
        }) != 0)) return 0;
        d = c1 - c2;
        while (d != 0) {
            if ((c1 <= @as(c_int, 'Z')) and (c1 >= @as(c_int, 'A'))) {
                d += @as(c_int, 'a') - @as(c_int, 'A');
                if (!(d != 0)) break;
            }
            if ((c2 <= @as(c_int, 'Z')) and (c2 >= @as(c_int, 'A'))) {
                d -= @as(c_int, 'a') - @as(c_int, 'A');
                if (!(d != 0)) break;
            }
            return ((d >= @as(c_int, 0)) << @intCast(1)) - @as(c_int, 1);
        }
        if (!(c1 != 0)) break;
    }
    return 0;
}
pub fn nk_strtoi(arg_str: [*c]const u8, arg_endptr: [*c][*c]u8) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var endptr = arg_endptr;
    _ = &endptr;
    var neg: c_int = 1;
    _ = &neg;
    var p: [*c]const u8 = str;
    _ = &p;
    var value: c_int = 0;
    _ = &value;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 6933))), "int nk_strtoi(const char *, char **)");
            };
        };
    };
    if (!(str != null)) return 0;
    while (@as(c_int, @bitCast(@as(c_uint, p.*))) == @as(c_int, ' ')) {
        p += 1;
    }
    if (@as(c_int, @bitCast(@as(c_uint, p.*))) == @as(c_int, '-')) {
        neg = -@as(c_int, 1);
        p += 1;
    }
    while (((@as(c_int, @bitCast(@as(c_uint, p.*))) != 0) and (@as(c_int, @bitCast(@as(c_uint, p.*))) >= @as(c_int, '0'))) and (@as(c_int, @bitCast(@as(c_uint, p.*))) <= @as(c_int, '9'))) {
        value = (value * @as(c_int, 10)) + (@as(c_int, @bitCast(@as(c_uint, p.*))) - @as(c_int, '0'));
        p += 1;
    }
    if (endptr != null) {
        endptr.* = @as([*c]u8, @ptrCast(@volatileCast(@constCast(p))));
    }
    return neg * value;
}
pub fn nk_strtof(arg_str: [*c]const u8, arg_endptr: [*c][*c]u8) callconv(.c) f32 {
    var str = arg_str;
    _ = &str;
    var endptr = arg_endptr;
    _ = &endptr;
    var float_value: f32 = undefined;
    _ = &float_value;
    var double_value: f64 = undefined;
    _ = &double_value;
    double_value = nk_strtod(str, endptr);
    float_value = @as(f32, @floatCast(double_value));
    return float_value;
}
pub fn nk_strtod(arg_str: [*c]const u8, arg_endptr: [*c][*c]u8) callconv(.c) f64 {
    var str = arg_str;
    _ = &str;
    var endptr = arg_endptr;
    _ = &endptr;
    var m: f64 = undefined;
    _ = &m;
    var neg: f64 = 1.0;
    _ = &neg;
    var p: [*c]u8 = @as([*c]u8, @ptrCast(@volatileCast(@constCast(str))));
    _ = &p;
    var value: f64 = 0;
    _ = &value;
    var number: f64 = 0;
    _ = &number;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 6959))), "double nk_strtod(const char *, char **)");
            };
        };
    };
    if (!(str != null)) return 0;
    while (@as(c_int, @bitCast(@as(c_uint, p.*))) == @as(c_int, ' ')) {
        p += 1;
    }
    if (@as(c_int, @bitCast(@as(c_uint, p.*))) == @as(c_int, '-')) {
        neg = -1.0;
        p += 1;
    }
    while (((@as(c_int, @bitCast(@as(c_uint, p.*))) != 0) and (@as(c_int, @bitCast(@as(c_uint, p.*))) != @as(c_int, '.'))) and (@as(c_int, @bitCast(@as(c_uint, p.*))) != @as(c_int, 'e'))) {
        value = (value * 10.0) + @as(f64, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, p.*))) - @as(c_int, '0')));
        p += 1;
    }
    if (@as(c_int, @bitCast(@as(c_uint, p.*))) == @as(c_int, '.')) {
        p += 1;
        {
            m = 0.1;
            while ((@as(c_int, @bitCast(@as(c_uint, p.*))) != 0) and (@as(c_int, @bitCast(@as(c_uint, p.*))) != @as(c_int, 'e'))) : (p += 1) {
                value = value + (@as(f64, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, p.*))) - @as(c_int, '0'))) * m);
                m *= 0.1;
            }
        }
    }
    if (@as(c_int, @bitCast(@as(c_uint, p.*))) == @as(c_int, 'e')) {
        var i: c_int = undefined;
        _ = &i;
        var pow: c_int = undefined;
        _ = &pow;
        var div: c_int = undefined;
        _ = &div;
        p += 1;
        if (@as(c_int, @bitCast(@as(c_uint, p.*))) == @as(c_int, '-')) {
            div = nk_true;
            p += 1;
        } else if (@as(c_int, @bitCast(@as(c_uint, p.*))) == @as(c_int, '+')) {
            div = nk_false;
            p += 1;
        } else {
            div = nk_false;
        }
        {
            pow = 0;
            while (p.* != 0) : (p += 1) {
                pow = (pow * @as(c_int, 10)) + (@as(c_int, @bitCast(@as(c_uint, p.*))) - @as(c_int, '0'));
            }
        }
        {
            _ = blk: {
                m = 1.0;
                break :blk blk_1: {
                    const tmp = @as(c_int, 0);
                    i = tmp;
                    break :blk_1 tmp;
                };
            };
            while (i < pow) : (i += 1) {
                m *= 10.0;
            }
        }
        if (div != 0) {
            value /= m;
        } else {
            value *= m;
        }
    }
    number = value * neg;
    if (endptr != null) {
        endptr.* = p;
    }
    return number;
}
pub fn nk_strfilter(arg_text: [*c]const u8, arg_regexp: [*c]const u8) callconv(.c) c_int {
    var text = arg_text;
    _ = &text;
    var regexp = arg_regexp;
    _ = &regexp;
    if (@as(c_int, @bitCast(@as(c_uint, regexp[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, '^')) return nk_str_match_here(regexp + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), text);
    while (true) {
        if (nk_str_match_here(regexp, text) != 0) return 1;
        if (!(@as(c_int, @bitCast(@as(c_uint, (blk: {
            const ref = &text;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*))) != @as(c_int, '\x00'))) break;
    }
    return 0;
}
pub fn nk_strmatch_fuzzy_string(arg_str: [*c]const u8, arg_pattern: [*c]const u8, arg_out_score: [*c]c_int) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var pattern = arg_pattern;
    _ = &pattern;
    var out_score = arg_out_score;
    _ = &out_score;
    return nk_strmatch_fuzzy_text(str, nk_strlen(str), pattern, out_score);
}
pub fn nk_strmatch_fuzzy_text(arg_str: [*c]const u8, arg_str_len: c_int, arg_pattern: [*c]const u8, arg_out_score: [*c]c_int) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var str_len = arg_str_len;
    _ = &str_len;
    var pattern = arg_pattern;
    _ = &pattern;
    var out_score = arg_out_score;
    _ = &out_score;
    var score: c_int = 0;
    _ = &score;
    var pattern_iter: [*c]const u8 = pattern;
    _ = &pattern_iter;
    var str_iter: c_int = 0;
    _ = &str_iter;
    var prev_matched: c_int = nk_false;
    _ = &prev_matched;
    var prev_lower: c_int = nk_false;
    _ = &prev_lower;
    var prev_separator: c_int = nk_true;
    _ = &prev_separator;
    var best_letter: [*c]const u8 = null;
    _ = &best_letter;
    var best_letter_score: c_int = 0;
    _ = &best_letter_score;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 7137))), "int nk_strmatch_fuzzy_text(const char *, int, const char *, int *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (pattern != null) {} else {
                __assert_fail("pattern", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 7138))), "int nk_strmatch_fuzzy_text(const char *, int, const char *, int *)");
            };
        };
    };
    if ((!(str != null) or !(str_len != 0)) or !(pattern != null)) return 0;
    while (str_iter < str_len) {
        const pattern_letter: u8 = pattern_iter.*;
        _ = &pattern_letter;
        const str_letter: u8 = (blk: {
            const tmp = str_iter;
            if (tmp >= 0) break :blk str + @as(usize, @intCast(tmp)) else break :blk str - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        _ = &str_letter;
        var next_match: c_int = @intFromBool((@as(c_int, @bitCast(@as(c_uint, pattern_iter.*))) != @as(c_int, '\x00')) and (nk_to_lower(@as(c_int, @bitCast(@as(c_uint, pattern_letter)))) == nk_to_lower(@as(c_int, @bitCast(@as(c_uint, str_letter))))));
        _ = &next_match;
        var rematch: c_int = @intFromBool((best_letter != null) and (nk_to_upper(@as(c_int, @bitCast(@as(c_uint, best_letter.*)))) == nk_to_upper(@as(c_int, @bitCast(@as(c_uint, str_letter))))));
        _ = &rematch;
        var advanced: c_int = @intFromBool((next_match != 0) and (best_letter != null));
        _ = &advanced;
        var pattern_repeat: c_int = @intFromBool((best_letter != null) and (@as(c_int, @bitCast(@as(c_uint, pattern_iter.*))) != @as(c_int, '\x00')));
        _ = &pattern_repeat;
        pattern_repeat = @intFromBool((pattern_repeat != 0) and (nk_to_lower(@as(c_int, @bitCast(@as(c_uint, best_letter.*)))) == nk_to_lower(@as(c_int, @bitCast(@as(c_uint, pattern_letter))))));
        if ((advanced != 0) or (pattern_repeat != 0)) {
            score += best_letter_score;
            best_letter = null;
            best_letter_score = 0;
        }
        if ((next_match != 0) or (rematch != 0)) {
            var new_score: c_int = 0;
            _ = &new_score;
            if (pattern_iter == pattern) {
                var count: c_int = @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(&(blk: {
                    const tmp = str_iter;
                    if (tmp >= 0) break :blk str + @as(usize, @intCast(tmp)) else break :blk str - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*) -% @intFromPtr(str))), @sizeOf(u8))))));
                _ = &count;
                var penalty: c_int = -@as(c_int, 3) * count;
                _ = &penalty;
                if (penalty < -@as(c_int, 9)) {
                    penalty = -@as(c_int, 9);
                }
                score += penalty;
            }
            if (prev_matched != 0) {
                new_score += @as(c_int, 5);
            }
            if (prev_separator != 0) {
                new_score += @as(c_int, 10);
            }
            if ((prev_lower != 0) and (nk_is_upper(@as(c_int, @bitCast(@as(c_uint, str_letter)))) != 0)) {
                new_score += @as(c_int, 10);
            }
            if (next_match != 0) {
                pattern_iter += 1;
            }
            if (new_score >= best_letter_score) {
                if (best_letter != null) {
                    score += -@as(c_int, 1);
                }
                best_letter = &(blk: {
                    const tmp = str_iter;
                    if (tmp >= 0) break :blk str + @as(usize, @intCast(tmp)) else break :blk str - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*;
                best_letter_score = new_score;
            }
            prev_matched = nk_true;
        } else {
            score += -@as(c_int, 1);
            prev_matched = nk_false;
        }
        prev_lower = @intFromBool(nk_is_lower(@as(c_int, @bitCast(@as(c_uint, str_letter)))) != @as(c_int, 0));
        prev_separator = @intFromBool((@as(c_int, @bitCast(@as(c_uint, str_letter))) == @as(c_int, '_')) or (@as(c_int, @bitCast(@as(c_uint, str_letter))) == @as(c_int, ' ')));
        str_iter += 1;
    }
    if (best_letter != null) {
        score += best_letter_score;
    }
    if (@as(c_int, @bitCast(@as(c_uint, pattern_iter.*))) != @as(c_int, '\x00')) return nk_false;
    if (out_score != null) {
        out_score.* = score;
    }
    return nk_true;
}
pub fn nk_utf_decode(arg_c: [*c]const u8, arg_u: [*c]nk_rune, arg_clen: c_int) callconv(.c) c_int {
    var c = arg_c;
    _ = &c;
    var u = arg_u;
    _ = &u;
    var clen = arg_clen;
    _ = &clen;
    var i: c_int = undefined;
    _ = &i;
    var j: c_int = undefined;
    _ = &j;
    var len: c_int = undefined;
    _ = &len;
    var @"type": c_int = 0;
    _ = &@"type";
    var udecoded: nk_rune = undefined;
    _ = &udecoded;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (c != null) {} else {
                __assert_fail("c", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8378))), "int nk_utf_decode(const char *, nk_rune *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (u != null) {} else {
                __assert_fail("u", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8379))), "int nk_utf_decode(const char *, nk_rune *, int)");
            };
        };
    };
    if (!(c != null) or !(u != null)) return 0;
    if (!(clen != 0)) return 0;
    u.* = @as(nk_rune, @bitCast(@as(c_int, 65533)));
    udecoded = nk_utf_decode_byte(c[@as(c_uint, @intCast(@as(c_int, 0)))], &len);
    if (!((@as(c_int, 1) <= len) and (len < @as(c_int, 4)))) return 1;
    {
        _ = blk: {
            i = 1;
            break :blk blk_1: {
                const tmp = @as(c_int, 1);
                j = tmp;
                break :blk_1 tmp;
            };
        };
        while ((i < clen) and (j < len)) : (_ = blk: {
            i += 1;
            break :blk blk_1: {
                const ref = &j;
                ref.* += 1;
                break :blk_1 ref.*;
            };
        }) {
            udecoded = (udecoded << @intCast(6)) | nk_utf_decode_byte((blk: {
                const tmp = i;
                if (tmp >= 0) break :blk c + @as(usize, @intCast(tmp)) else break :blk c - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*, &@"type");
            if (@"type" != @as(c_int, 0)) return j;
        }
    }
    if (j < len) return 0;
    u.* = udecoded;
    _ = nk_utf_validate(u, len);
    return len;
}
pub fn nk_utf_encode(arg_u: nk_rune, arg_c: [*c]u8, arg_clen: c_int) callconv(.c) c_int {
    var u = arg_u;
    _ = &u;
    var c = arg_c;
    _ = &c;
    var clen = arg_clen;
    _ = &clen;
    var len: c_int = undefined;
    _ = &len;
    var i: c_int = undefined;
    _ = &i;
    len = nk_utf_validate(&u, @as(c_int, 0));
    if (((clen < len) or !(len != 0)) or (len > @as(c_int, 4))) return 0;
    {
        i = len - @as(c_int, 1);
        while (i != @as(c_int, 0)) : (i -= 1) {
            (blk: {
                const tmp = i;
                if (tmp >= 0) break :blk c + @as(usize, @intCast(tmp)) else break :blk c - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).* = nk_utf_encode_byte(u, @as(c_int, 0));
            u >>= @intCast(@as(c_int, 6));
        }
    }
    c[@as(c_uint, @intCast(@as(c_int, 0)))] = nk_utf_encode_byte(u, len);
    return len;
}
pub fn nk_utf_len(arg_str: [*c]const u8, arg_len: c_int) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var text: [*c]const u8 = undefined;
    _ = &text;
    var glyphs: c_int = 0;
    _ = &glyphs;
    var text_len: c_int = undefined;
    _ = &text_len;
    var glyph_len: c_int = undefined;
    _ = &glyph_len;
    var src_len: c_int = 0;
    _ = &src_len;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8430))), "int nk_utf_len(const char *, int)");
            };
        };
    };
    if (!(str != null) or !(len != 0)) return 0;
    text = str;
    text_len = len;
    glyph_len = nk_utf_decode(text, &unicode, text_len);
    while ((glyph_len != 0) and (src_len < len)) {
        glyphs += 1;
        src_len = src_len + glyph_len;
        glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(src_len)))), &unicode, text_len - src_len);
    }
    return glyphs;
}
pub fn nk_utf_at(arg_buffer: [*c]const u8, arg_length: c_int, arg_index: c_int, arg_unicode: [*c]nk_rune, arg_len: [*c]c_int) callconv(.c) [*c]const u8 {
    var buffer = arg_buffer;
    _ = &buffer;
    var length = arg_length;
    _ = &length;
    var index = arg_index;
    _ = &index;
    var unicode = arg_unicode;
    _ = &unicode;
    var len = arg_len;
    _ = &len;
    var i: c_int = 0;
    _ = &i;
    var src_len: c_int = 0;
    _ = &src_len;
    var glyph_len: c_int = 0;
    _ = &glyph_len;
    var text: [*c]const u8 = undefined;
    _ = &text;
    var text_len: c_int = undefined;
    _ = &text_len;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (buffer != null) {} else {
                __assert_fail("buffer", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8453))), "const char *nk_utf_at(const char *, int, int, nk_rune *, int *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (unicode != null) {} else {
                __assert_fail("unicode", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8454))), "const char *nk_utf_at(const char *, int, int, nk_rune *, int *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len != null) {} else {
                __assert_fail("len", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8455))), "const char *nk_utf_at(const char *, int, int, nk_rune *, int *)");
            };
        };
    };
    if ((!(buffer != null) or !(unicode != null)) or !(len != null)) return null;
    if (index < @as(c_int, 0)) {
        unicode.* = @as(nk_rune, @bitCast(@as(c_int, 65533)));
        len.* = 0;
        return null;
    }
    text = buffer;
    text_len = length;
    glyph_len = nk_utf_decode(text, unicode, text_len);
    while (glyph_len != 0) {
        if (i == index) {
            len.* = glyph_len;
            break;
        }
        i += 1;
        src_len = src_len + glyph_len;
        glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(src_len)))), unicode, text_len - src_len);
    }
    if (i != index) return null;
    return buffer + @as(usize, @bitCast(@as(isize, @intCast(src_len))));
}
pub const struct_nk_user_font_glyph = opaque {};
pub const nk_query_font_glyph_f = ?*const fn (nk_handle, f32, ?*struct_nk_user_font_glyph, nk_rune, nk_rune) callconv(.c) void;
pub const struct_nk_memory_status = extern struct {
    memory: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    type: c_uint = @import("std").mem.zeroes(c_uint),
    size: nk_size = @import("std").mem.zeroes(nk_size),
    allocated: nk_size = @import("std").mem.zeroes(nk_size),
    needed: nk_size = @import("std").mem.zeroes(nk_size),
    calls: nk_size = @import("std").mem.zeroes(nk_size),
};
pub const NK_BUFFER_FRONT: c_int = 0;
pub const NK_BUFFER_BACK: c_int = 1;
pub const NK_BUFFER_MAX: c_int = 2;
pub const enum_nk_buffer_allocation_type = c_uint;
pub fn nk_buffer_init(arg_b: [*c]struct_nk_buffer, arg_a: [*c]const struct_nk_allocator, arg_initial_size: nk_size) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var a = arg_a;
    _ = &a;
    var initial_size = arg_initial_size;
    _ = &initial_size;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8519))), "void nk_buffer_init(struct nk_buffer *, const struct nk_allocator *, nk_size)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (a != null) {} else {
                __assert_fail("a", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8520))), "void nk_buffer_init(struct nk_buffer *, const struct nk_allocator *, nk_size)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (initial_size != 0) {} else {
                __assert_fail("initial_size", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8521))), "void nk_buffer_init(struct nk_buffer *, const struct nk_allocator *, nk_size)");
            };
        };
    };
    if ((!(b != null) or !(a != null)) or !(initial_size != 0)) return;
    nk_zero(@as(?*anyopaque, @ptrCast(b)), @sizeOf(struct_nk_buffer));
    b.*.type = @as(c_uint, @bitCast(NK_BUFFER_DYNAMIC));
    b.*.memory.ptr = a.*.alloc.?(a.*.userdata, null, initial_size);
    b.*.memory.size = initial_size;
    b.*.size = initial_size;
    b.*.grow_factor = 2.0;
    b.*.pool = a.*;
}
pub fn nk_buffer_init_fixed(arg_b: [*c]struct_nk_buffer, arg_m: ?*anyopaque, arg_size: nk_size) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var m = arg_m;
    _ = &m;
    var size = arg_size;
    _ = &size;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8535))), "void nk_buffer_init_fixed(struct nk_buffer *, void *, nk_size)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (m != null) {} else {
                __assert_fail("m", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8536))), "void nk_buffer_init_fixed(struct nk_buffer *, void *, nk_size)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (size != 0) {} else {
                __assert_fail("size", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8537))), "void nk_buffer_init_fixed(struct nk_buffer *, void *, nk_size)");
            };
        };
    };
    if ((!(b != null) or !(m != null)) or !(size != 0)) return;
    nk_zero(@as(?*anyopaque, @ptrCast(b)), @sizeOf(struct_nk_buffer));
    b.*.type = @as(c_uint, @bitCast(NK_BUFFER_FIXED));
    b.*.memory.ptr = m;
    b.*.memory.size = size;
    b.*.size = size;
}
pub fn nk_buffer_info(arg_s: [*c]struct_nk_memory_status, arg_b: [*c]const struct_nk_buffer) callconv(.c) void {
    var s = arg_s;
    _ = &s;
    var b = arg_b;
    _ = &b;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8728))), "void nk_buffer_info(struct nk_memory_status *, const struct nk_buffer *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8729))), "void nk_buffer_info(struct nk_memory_status *, const struct nk_buffer *)");
            };
        };
    };
    if (!(s != null) or !(b != null)) return;
    s.*.allocated = b.*.allocated;
    s.*.size = b.*.memory.size;
    s.*.needed = b.*.needed;
    s.*.memory = b.*.memory.ptr;
    s.*.calls = b.*.calls;
}
pub fn nk_buffer_push(arg_b: [*c]struct_nk_buffer, arg_type: enum_nk_buffer_allocation_type, arg_memory: ?*const anyopaque, arg_size: nk_size, arg_align: nk_size) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var @"type" = arg_type;
    _ = &@"type";
    var memory = arg_memory;
    _ = &memory;
    var size = arg_size;
    _ = &size;
    var @"align" = arg_align;
    _ = &@"align";
    var mem: ?*anyopaque = nk_buffer_alloc(b, @"type", size, @"align");
    _ = &mem;
    if (!(mem != null)) return;
    _ = nk_memcopy(mem, memory, size);
}
pub fn nk_buffer_mark(arg_buffer: [*c]struct_nk_buffer, arg_type: enum_nk_buffer_allocation_type) callconv(.c) void {
    var buffer = arg_buffer;
    _ = &buffer;
    var @"type" = arg_type;
    _ = &@"type";
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (buffer != null) {} else {
                __assert_fail("buffer", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8677))), "void nk_buffer_mark(struct nk_buffer *, enum nk_buffer_allocation_type)");
            };
        };
    };
    if (!(buffer != null)) return;
    buffer.*.marker[@"type"].active = nk_true;
    if (@"type" == @as(c_uint, @bitCast(NK_BUFFER_BACK))) {
        buffer.*.marker[@"type"].offset = buffer.*.size;
    } else {
        buffer.*.marker[@"type"].offset = buffer.*.allocated;
    }
}
pub fn nk_buffer_reset(arg_buffer: [*c]struct_nk_buffer, arg_type: enum_nk_buffer_allocation_type) callconv(.c) void {
    var buffer = arg_buffer;
    _ = &buffer;
    var @"type" = arg_type;
    _ = &@"type";
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (buffer != null) {} else {
                __assert_fail("buffer", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8687))), "void nk_buffer_reset(struct nk_buffer *, enum nk_buffer_allocation_type)");
            };
        };
    };
    if (!(buffer != null)) return;
    if (@"type" == @as(c_uint, @bitCast(NK_BUFFER_BACK))) {
        buffer.*.needed -%= buffer.*.memory.size -% buffer.*.marker[@"type"].offset;
        if (buffer.*.marker[@"type"].active != 0) {
            buffer.*.size = buffer.*.marker[@"type"].offset;
        } else {
            buffer.*.size = buffer.*.memory.size;
        }
        buffer.*.marker[@"type"].active = nk_false;
    } else {
        buffer.*.needed -%= buffer.*.allocated -% buffer.*.marker[@"type"].offset;
        if (buffer.*.marker[@"type"].active != 0) {
            buffer.*.allocated = buffer.*.marker[@"type"].offset;
        } else {
            buffer.*.allocated = 0;
        }
        buffer.*.marker[@"type"].active = nk_false;
    }
}
pub fn nk_buffer_clear(arg_b: [*c]struct_nk_buffer) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8708))), "void nk_buffer_clear(struct nk_buffer *)");
            };
        };
    };
    if (!(b != null)) return;
    b.*.allocated = 0;
    b.*.size = b.*.memory.size;
    b.*.calls = 0;
    b.*.needed = 0;
}
pub fn nk_buffer_free(arg_b: [*c]struct_nk_buffer) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8718))), "void nk_buffer_free(struct nk_buffer *)");
            };
        };
    };
    if (!(b != null) or !(b.*.memory.ptr != null)) return;
    if (b.*.type == @as(c_uint, @bitCast(NK_BUFFER_FIXED))) return;
    if (!(b.*.pool.free != null)) return;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b.*.pool.free != null) {} else {
                __assert_fail("b->pool.free", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8722))), "void nk_buffer_free(struct nk_buffer *)");
            };
        };
    };
    b.*.pool.free.?(b.*.pool.userdata, b.*.memory.ptr);
}
pub fn nk_buffer_memory(arg_buffer: [*c]struct_nk_buffer) callconv(.c) ?*anyopaque {
    var buffer = arg_buffer;
    _ = &buffer;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (buffer != null) {} else {
                __assert_fail("buffer", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8740))), "void *nk_buffer_memory(struct nk_buffer *)");
            };
        };
    };
    if (!(buffer != null)) return null;
    return buffer.*.memory.ptr;
}
pub fn nk_buffer_memory_const(arg_buffer: [*c]const struct_nk_buffer) callconv(.c) ?*const anyopaque {
    var buffer = arg_buffer;
    _ = &buffer;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (buffer != null) {} else {
                __assert_fail("buffer", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8747))), "const void *nk_buffer_memory_const(const struct nk_buffer *)");
            };
        };
    };
    if (!(buffer != null)) return null;
    return buffer.*.memory.ptr;
}
pub fn nk_buffer_total(arg_buffer: [*c]const struct_nk_buffer) callconv(.c) nk_size {
    var buffer = arg_buffer;
    _ = &buffer;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (buffer != null) {} else {
                __assert_fail("buffer", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8754))), "nk_size nk_buffer_total(const struct nk_buffer *)");
            };
        };
    };
    if (!(buffer != null)) return 0;
    return buffer.*.memory.size;
}
pub fn nk_str_init(arg_str: [*c]struct_nk_str, arg_alloc: [*c]const struct_nk_allocator, arg_size: nk_size) callconv(.c) void {
    var str = arg_str;
    _ = &str;
    var alloc = arg_alloc;
    _ = &alloc;
    var size = arg_size;
    _ = &size;
    nk_buffer_init(&str.*.buffer, alloc, size);
    str.*.len = 0;
}
pub fn nk_str_init_fixed(arg_str: [*c]struct_nk_str, arg_memory: ?*anyopaque, arg_size: nk_size) callconv(.c) void {
    var str = arg_str;
    _ = &str;
    var memory = arg_memory;
    _ = &memory;
    var size = arg_size;
    _ = &size;
    nk_buffer_init_fixed(&str.*.buffer, memory, size);
    str.*.len = 0;
}
pub fn nk_str_clear(arg_str: [*c]struct_nk_str) callconv(.c) void {
    var str = arg_str;
    _ = &str;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9196))), "void nk_str_clear(struct nk_str *)");
            };
        };
    };
    nk_buffer_clear(&str.*.buffer);
    str.*.len = 0;
}
pub fn nk_str_free(arg_str: [*c]struct_nk_str) callconv(.c) void {
    var str = arg_str;
    _ = &str;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9203))), "void nk_str_free(struct nk_str *)");
            };
        };
    };
    nk_buffer_free(&str.*.buffer);
    str.*.len = 0;
}
pub fn nk_str_append_text_char(arg_s: [*c]struct_nk_str, arg_str: [*c]const u8, arg_len: c_int) callconv(.c) c_int {
    var s = arg_s;
    _ = &s;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var mem: [*c]u8 = undefined;
    _ = &mem;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8796))), "int nk_str_append_text_char(struct nk_str *, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8797))), "int nk_str_append_text_char(struct nk_str *, const char *, int)");
            };
        };
    };
    if ((!(s != null) or !(str != null)) or !(len != 0)) return 0;
    mem = @as([*c]u8, @ptrCast(@alignCast(nk_buffer_alloc(&s.*.buffer, @as(c_uint, @bitCast(NK_BUFFER_FRONT)), @as(nk_size, @bitCast(@as(c_long, len))) *% @sizeOf(u8), @as(nk_size, @bitCast(@as(c_long, @as(c_int, 0))))))));
    if (!(mem != null)) return 0;
    _ = nk_memcopy(@as(?*anyopaque, @ptrCast(mem)), @as(?*const anyopaque, @ptrCast(str)), @as(nk_size, @bitCast(@as(c_long, len))) *% @sizeOf(u8));
    s.*.len += nk_utf_len(str, len);
    return len;
}
pub fn nk_str_append_str_char(arg_s: [*c]struct_nk_str, arg_str: [*c]const u8) callconv(.c) c_int {
    var s = arg_s;
    _ = &s;
    var str = arg_str;
    _ = &str;
    return nk_str_append_text_char(s, str, nk_strlen(str));
}
pub fn nk_str_append_text_utf8(arg_str: [*c]struct_nk_str, arg_text: [*c]const u8, arg_len: c_int) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var i: c_int = 0;
    _ = &i;
    var byte_len: c_int = 0;
    _ = &byte_len;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    if ((!(str != null) or !(text != null)) or !(len != 0)) return 0;
    {
        i = 0;
        while (i < len) : (i += 1) {
            byte_len += nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(byte_len)))), &unicode, @as(c_int, 4));
        }
    }
    _ = nk_str_append_text_char(str, text, byte_len);
    return len;
}
pub fn nk_str_append_str_utf8(arg_str: [*c]struct_nk_str, arg_text: [*c]const u8) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var text = arg_text;
    _ = &text;
    var byte_len: c_int = 0;
    _ = &byte_len;
    var num_runes: c_int = 0;
    _ = &num_runes;
    var glyph_len: c_int = 0;
    _ = &glyph_len;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    if (!(str != null) or !(text != null)) return 0;
    glyph_len = blk: {
        const tmp = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(byte_len)))), &unicode, @as(c_int, 4));
        byte_len = tmp;
        break :blk tmp;
    };
    while ((unicode != @as(nk_rune, @bitCast(@as(c_int, '\x00')))) and (glyph_len != 0)) {
        glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(byte_len)))), &unicode, @as(c_int, 4));
        byte_len += glyph_len;
        num_runes += 1;
    }
    _ = nk_str_append_text_char(str, text, byte_len);
    return num_runes;
}
pub fn nk_str_append_text_runes(arg_str: [*c]struct_nk_str, arg_text: [*c]const nk_rune, arg_len: c_int) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var i: c_int = 0;
    _ = &i;
    var byte_len: c_int = 0;
    _ = &byte_len;
    var glyph: nk_glyph = undefined;
    _ = &glyph;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8847))), "int nk_str_append_text_runes(struct nk_str *, const nk_rune *, int)");
            };
        };
    };
    if ((!(str != null) or !(text != null)) or !(len != 0)) return 0;
    {
        i = 0;
        while (i < len) : (i += 1) {
            byte_len = nk_utf_encode((blk: {
                const tmp = i;
                if (tmp >= 0) break :blk text + @as(usize, @intCast(tmp)) else break :blk text - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*, @as([*c]u8, @ptrCast(@alignCast(&glyph))), @as(c_int, 4));
            if (!(byte_len != 0)) break;
            _ = nk_str_append_text_char(str, @as([*c]u8, @ptrCast(@alignCast(&glyph))), byte_len);
        }
    }
    return len;
}
pub fn nk_str_append_str_runes(arg_str: [*c]struct_nk_str, arg_runes: [*c]const nk_rune) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var runes = arg_runes;
    _ = &runes;
    var i: c_int = 0;
    _ = &i;
    var glyph: nk_glyph = undefined;
    _ = &glyph;
    var byte_len: c_int = undefined;
    _ = &byte_len;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8862))), "int nk_str_append_str_runes(struct nk_str *, const nk_rune *)");
            };
        };
    };
    if (!(str != null) or !(runes != null)) return 0;
    while ((blk: {
        const tmp = i;
        if (tmp >= 0) break :blk runes + @as(usize, @intCast(tmp)) else break :blk runes - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* != @as(nk_rune, @bitCast(@as(c_int, '\x00')))) {
        byte_len = nk_utf_encode((blk: {
            const tmp = i;
            if (tmp >= 0) break :blk runes + @as(usize, @intCast(tmp)) else break :blk runes - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*, @as([*c]u8, @ptrCast(@alignCast(&glyph))), @as(c_int, 4));
        _ = nk_str_append_text_char(str, @as([*c]u8, @ptrCast(@alignCast(&glyph))), byte_len);
        i += 1;
    }
    return i;
}
pub fn nk_str_insert_at_char(arg_s: [*c]struct_nk_str, arg_pos: c_int, arg_str: [*c]const u8, arg_len: c_int) callconv(.c) c_int {
    var s = arg_s;
    _ = &s;
    var pos = arg_pos;
    _ = &pos;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var i: c_int = undefined;
    _ = &i;
    var mem: ?*anyopaque = undefined;
    _ = &mem;
    var src: [*c]u8 = undefined;
    _ = &src;
    var dst: [*c]u8 = undefined;
    _ = &dst;
    var copylen: c_int = undefined;
    _ = &copylen;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8880))), "int nk_str_insert_at_char(struct nk_str *, int, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8881))), "int nk_str_insert_at_char(struct nk_str *, int, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len >= @as(c_int, 0)) {} else {
                __assert_fail("len >= 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8882))), "int nk_str_insert_at_char(struct nk_str *, int, const char *, int)");
            };
        };
    };
    if (((!(s != null) or !(str != null)) or !(len != 0)) or (@as(nk_size, @bitCast(@as(c_long, pos))) > s.*.buffer.allocated)) return 0;
    if (((s.*.buffer.allocated +% @as(nk_size, @bitCast(@as(c_long, len)))) >= s.*.buffer.memory.size) and (s.*.buffer.type == @as(c_uint, @bitCast(NK_BUFFER_FIXED)))) return 0;
    copylen = @as(c_int, @bitCast(@as(c_uint, @truncate(s.*.buffer.allocated)))) - pos;
    if (!(copylen != 0)) {
        _ = nk_str_append_text_char(s, str, len);
        return 1;
    }
    mem = nk_buffer_alloc(&s.*.buffer, @as(c_uint, @bitCast(NK_BUFFER_FRONT)), @as(nk_size, @bitCast(@as(c_long, len))) *% @sizeOf(u8), @as(nk_size, @bitCast(@as(c_long, @as(c_int, 0)))));
    if (!(mem != null)) return 0;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (((pos + len) + (copylen - @as(c_int, 1))) >= @as(c_int, 0)) {} else {
                __assert_fail("((int)pos + (int)len + ((int)copylen - 1)) >= 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8896))), "int nk_str_insert_at_char(struct nk_str *, int, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((pos + (copylen - @as(c_int, 1))) >= @as(c_int, 0)) {} else {
                __assert_fail("((int)pos + ((int)copylen - 1)) >= 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8897))), "int nk_str_insert_at_char(struct nk_str *, int, const char *, int)");
            };
        };
    };
    dst = @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(s.*.buffer.memory.ptr))) + @as(usize, @bitCast(@as(isize, @intCast((pos + len) + (copylen - @as(c_int, 1)))))))))));
    src = @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(s.*.buffer.memory.ptr))) + @as(usize, @bitCast(@as(isize, @intCast(pos + (copylen - @as(c_int, 1)))))))))));
    {
        i = 0;
        while (i < copylen) : (i += 1) {
            (blk: {
                const ref = &dst;
                const tmp = ref.*;
                ref.* -= 1;
                break :blk tmp;
            }).* = (blk: {
                const ref = &src;
                const tmp = ref.*;
                ref.* -= 1;
                break :blk tmp;
            }).*;
        }
    }
    mem = @as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(s.*.buffer.memory.ptr))) + @as(usize, @bitCast(@as(isize, @intCast(pos))))));
    _ = nk_memcopy(mem, @as(?*const anyopaque, @ptrCast(str)), @as(nk_size, @bitCast(@as(c_long, len))) *% @sizeOf(u8));
    s.*.len = nk_utf_len(@as([*c]u8, @ptrCast(@alignCast(s.*.buffer.memory.ptr))), @as(c_int, @bitCast(@as(c_uint, @truncate(s.*.buffer.allocated)))));
    return 1;
}
pub fn nk_str_insert_at_rune(arg_str: [*c]struct_nk_str, arg_pos: c_int, arg_cstr: [*c]const u8, arg_len: c_int) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var cstr = arg_cstr;
    _ = &cstr;
    var len = arg_len;
    _ = &len;
    var glyph_len: c_int = undefined;
    _ = &glyph_len;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    var begin: [*c]const u8 = undefined;
    _ = &begin;
    var buffer: [*c]const u8 = undefined;
    _ = &buffer;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8914))), "int nk_str_insert_at_rune(struct nk_str *, int, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (cstr != null) {} else {
                __assert_fail("cstr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8915))), "int nk_str_insert_at_rune(struct nk_str *, int, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len != 0) {} else {
                __assert_fail("len", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8916))), "int nk_str_insert_at_rune(struct nk_str *, int, const char *, int)");
            };
        };
    };
    if ((!(str != null) or !(cstr != null)) or !(len != 0)) return 0;
    begin = nk_str_at_rune(str, pos, &unicode, &glyph_len);
    if (!(str.*.len != 0)) return nk_str_append_text_char(str, cstr, len);
    buffer = nk_str_get_const(str);
    if (!(begin != null)) return 0;
    return nk_str_insert_at_char(str, @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(begin) -% @intFromPtr(buffer))), @sizeOf(u8)))))), cstr, len);
}
pub fn nk_str_insert_text_char(arg_str: [*c]struct_nk_str, arg_pos: c_int, arg_text: [*c]const u8, arg_len: c_int) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    return nk_str_insert_text_utf8(str, pos, text, len);
}
pub fn nk_str_insert_str_char(arg_str: [*c]struct_nk_str, arg_pos: c_int, arg_text: [*c]const u8) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var text = arg_text;
    _ = &text;
    return nk_str_insert_text_utf8(str, pos, text, nk_strlen(text));
}
pub fn nk_str_insert_text_utf8(arg_str: [*c]struct_nk_str, arg_pos: c_int, arg_text: [*c]const u8, arg_len: c_int) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var text = arg_text;
    _ = &text;
    var len = arg_len;
    _ = &len;
    var i: c_int = 0;
    _ = &i;
    var byte_len: c_int = 0;
    _ = &byte_len;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8942))), "int nk_str_insert_text_utf8(struct nk_str *, int, const char *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (text != null) {} else {
                __assert_fail("text", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8943))), "int nk_str_insert_text_utf8(struct nk_str *, int, const char *, int)");
            };
        };
    };
    if ((!(str != null) or !(text != null)) or !(len != 0)) return 0;
    {
        i = 0;
        while (i < len) : (i += 1) {
            byte_len += nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(byte_len)))), &unicode, @as(c_int, 4));
        }
    }
    _ = nk_str_insert_at_rune(str, pos, text, byte_len);
    return len;
}
pub fn nk_str_insert_str_utf8(arg_str: [*c]struct_nk_str, arg_pos: c_int, arg_text: [*c]const u8) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var text = arg_text;
    _ = &text;
    var byte_len: c_int = 0;
    _ = &byte_len;
    var num_runes: c_int = 0;
    _ = &num_runes;
    var glyph_len: c_int = 0;
    _ = &glyph_len;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    if (!(str != null) or !(text != null)) return 0;
    glyph_len = blk: {
        const tmp = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(byte_len)))), &unicode, @as(c_int, 4));
        byte_len = tmp;
        break :blk tmp;
    };
    while ((unicode != @as(nk_rune, @bitCast(@as(c_int, '\x00')))) and (glyph_len != 0)) {
        glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(byte_len)))), &unicode, @as(c_int, 4));
        byte_len += glyph_len;
        num_runes += 1;
    }
    _ = nk_str_insert_at_rune(str, pos, text, byte_len);
    return num_runes;
}
pub fn nk_str_insert_text_runes(arg_str: [*c]struct_nk_str, arg_pos: c_int, arg_runes: [*c]const nk_rune, arg_len: c_int) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var runes = arg_runes;
    _ = &runes;
    var len = arg_len;
    _ = &len;
    var i: c_int = 0;
    _ = &i;
    var byte_len: c_int = 0;
    _ = &byte_len;
    var glyph: nk_glyph = undefined;
    _ = &glyph;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8975))), "int nk_str_insert_text_runes(struct nk_str *, int, const nk_rune *, int)");
            };
        };
    };
    if ((!(str != null) or !(runes != null)) or !(len != 0)) return 0;
    {
        i = 0;
        while (i < len) : (i += 1) {
            byte_len = nk_utf_encode((blk: {
                const tmp = i;
                if (tmp >= 0) break :blk runes + @as(usize, @intCast(tmp)) else break :blk runes - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*, @as([*c]u8, @ptrCast(@alignCast(&glyph))), @as(c_int, 4));
            if (!(byte_len != 0)) break;
            _ = nk_str_insert_at_rune(str, pos + i, @as([*c]u8, @ptrCast(@alignCast(&glyph))), byte_len);
        }
    }
    return len;
}
pub fn nk_str_insert_str_runes(arg_str: [*c]struct_nk_str, arg_pos: c_int, arg_runes: [*c]const nk_rune) callconv(.c) c_int {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var runes = arg_runes;
    _ = &runes;
    var i: c_int = 0;
    _ = &i;
    var glyph: nk_glyph = undefined;
    _ = &glyph;
    var byte_len: c_int = undefined;
    _ = &byte_len;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8990))), "int nk_str_insert_str_runes(struct nk_str *, int, const nk_rune *)");
            };
        };
    };
    if (!(str != null) or !(runes != null)) return 0;
    while ((blk: {
        const tmp = i;
        if (tmp >= 0) break :blk runes + @as(usize, @intCast(tmp)) else break :blk runes - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* != @as(nk_rune, @bitCast(@as(c_int, '\x00')))) {
        byte_len = nk_utf_encode((blk: {
            const tmp = i;
            if (tmp >= 0) break :blk runes + @as(usize, @intCast(tmp)) else break :blk runes - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*, @as([*c]u8, @ptrCast(@alignCast(&glyph))), @as(c_int, 4));
        _ = nk_str_insert_at_rune(str, pos + i, @as([*c]u8, @ptrCast(@alignCast(&glyph))), byte_len);
        i += 1;
    }
    return i;
}
pub fn nk_str_remove_chars(arg_s: [*c]struct_nk_str, arg_len: c_int) callconv(.c) void {
    var s = arg_s;
    _ = &s;
    var len = arg_len;
    _ = &len;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9002))), "void nk_str_remove_chars(struct nk_str *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len >= @as(c_int, 0)) {} else {
                __assert_fail("len >= 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9003))), "void nk_str_remove_chars(struct nk_str *, int)");
            };
        };
    };
    if ((!(s != null) or (len < @as(c_int, 0))) or (@as(nk_size, @bitCast(@as(c_long, len))) > s.*.buffer.allocated)) return;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((@as(c_int, @bitCast(@as(c_uint, @truncate(s.*.buffer.allocated)))) - len) >= @as(c_int, 0)) {} else {
                __assert_fail("((int)s->buffer.allocated - (int)len) >= 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9005))), "void nk_str_remove_chars(struct nk_str *, int)");
            };
        };
    };
    s.*.buffer.allocated -%= @as(nk_size, @bitCast(@as(c_long, len)));
    s.*.len = nk_utf_len(@as([*c]u8, @ptrCast(@alignCast(s.*.buffer.memory.ptr))), @as(c_int, @bitCast(@as(c_uint, @truncate(s.*.buffer.allocated)))));
}
pub fn nk_str_remove_runes(arg_str: [*c]struct_nk_str, arg_len: c_int) callconv(.c) void {
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var index: c_int = undefined;
    _ = &index;
    var begin: [*c]const u8 = undefined;
    _ = &begin;
    var end: [*c]const u8 = undefined;
    _ = &end;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9017))), "void nk_str_remove_runes(struct nk_str *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len >= @as(c_int, 0)) {} else {
                __assert_fail("len >= 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9018))), "void nk_str_remove_runes(struct nk_str *, int)");
            };
        };
    };
    if (!(str != null) or (len < @as(c_int, 0))) return;
    if (len >= str.*.len) {
        str.*.len = 0;
        return;
    }
    index = str.*.len - len;
    begin = nk_str_at_rune(str, index, &unicode, &len);
    end = @as([*c]const u8, @ptrCast(@alignCast(str.*.buffer.memory.ptr))) + str.*.buffer.allocated;
    nk_str_remove_chars(str, @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(end) -% @intFromPtr(begin))), @sizeOf(u8)))))) + @as(c_int, 1));
}
pub fn nk_str_delete_chars(arg_s: [*c]struct_nk_str, arg_pos: c_int, arg_len: c_int) callconv(.c) void {
    var s = arg_s;
    _ = &s;
    var pos = arg_pos;
    _ = &pos;
    var len = arg_len;
    _ = &len;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9033))), "void nk_str_delete_chars(struct nk_str *, int, int)");
            };
        };
    };
    if (((!(s != null) or !(len != 0)) or (@as(nk_size, @bitCast(@as(c_long, pos))) > s.*.buffer.allocated)) or (@as(nk_size, @bitCast(@as(c_long, pos + len))) > s.*.buffer.allocated)) return;
    if (@as(nk_size, @bitCast(@as(c_long, pos + len))) < s.*.buffer.allocated) {
        var dst: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(s.*.buffer.memory.ptr))) + @as(usize, @bitCast(@as(isize, @intCast(pos)))))))));
        _ = &dst;
        var src: [*c]u8 = @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(s.*.buffer.memory.ptr))) + @as(usize, @bitCast(@as(isize, @intCast(pos + len)))))))));
        _ = &src;
        _ = nk_memcopy(@as(?*anyopaque, @ptrCast(dst)), @as(?*const anyopaque, @ptrCast(src)), s.*.buffer.allocated -% @as(nk_size, @bitCast(@as(c_long, pos + len))));
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if ((@as(c_int, @bitCast(@as(c_uint, @truncate(s.*.buffer.allocated)))) - len) >= @as(c_int, 0)) {} else {
                    __assert_fail("((int)s->buffer.allocated - (int)len) >= 0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9042))), "void nk_str_delete_chars(struct nk_str *, int, int)");
                };
            };
        };
        s.*.buffer.allocated -%= @as(nk_size, @bitCast(@as(c_long, len)));
    } else {
        nk_str_remove_chars(s, len);
    }
    s.*.len = nk_utf_len(@as([*c]u8, @ptrCast(@alignCast(s.*.buffer.memory.ptr))), @as(c_int, @bitCast(@as(c_uint, @truncate(s.*.buffer.allocated)))));
}
pub fn nk_str_delete_runes(arg_s: [*c]struct_nk_str, arg_pos: c_int, arg_len: c_int) callconv(.c) void {
    var s = arg_s;
    _ = &s;
    var pos = arg_pos;
    _ = &pos;
    var len = arg_len;
    _ = &len;
    var temp: [*c]u8 = undefined;
    _ = &temp;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    var begin: [*c]u8 = undefined;
    _ = &begin;
    var end: [*c]u8 = undefined;
    _ = &end;
    var unused: c_int = undefined;
    _ = &unused;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9056))), "void nk_str_delete_runes(struct nk_str *, int, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s.*.len >= (pos + len)) {} else {
                __assert_fail("s->len >= pos + len", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9057))), "void nk_str_delete_runes(struct nk_str *, int, int)");
            };
        };
    };
    if (s.*.len < (pos + len)) {
        len = if ((if ((s.*.len - pos) < s.*.len) s.*.len - pos else s.*.len) < @as(c_int, 0)) @as(c_int, 0) else if ((s.*.len - pos) < s.*.len) s.*.len - pos else s.*.len;
    }
    if (!(len != 0)) return;
    temp = @as([*c]u8, @ptrCast(@alignCast(s.*.buffer.memory.ptr)));
    begin = nk_str_at_rune(s, pos, &unicode, &unused);
    if (!(begin != null)) return;
    s.*.buffer.memory.ptr = @as(?*anyopaque, @ptrCast(begin));
    end = nk_str_at_rune(s, len, &unicode, &unused);
    s.*.buffer.memory.ptr = @as(?*anyopaque, @ptrCast(temp));
    if (!(end != null)) return;
    nk_str_delete_chars(s, @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(begin) -% @intFromPtr(temp))), @sizeOf(u8)))))), @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(end) -% @intFromPtr(begin))), @sizeOf(u8)))))));
}
pub fn nk_str_at_char(arg_s: [*c]struct_nk_str, arg_pos: c_int) callconv(.c) [*c]u8 {
    var s = arg_s;
    _ = &s;
    var pos = arg_pos;
    _ = &pos;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9074))), "char *nk_str_at_char(struct nk_str *, int)");
            };
        };
    };
    if (!(s != null) or (pos > @as(c_int, @bitCast(@as(c_uint, @truncate(s.*.buffer.allocated)))))) return null;
    return @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(s.*.buffer.memory.ptr))) + @as(usize, @bitCast(@as(isize, @intCast(pos)))))))));
}
pub fn nk_str_at_rune(arg_str: [*c]struct_nk_str, arg_pos: c_int, arg_unicode: [*c]nk_rune, arg_len: [*c]c_int) callconv(.c) [*c]u8 {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var unicode = arg_unicode;
    _ = &unicode;
    var len = arg_len;
    _ = &len;
    var i: c_int = 0;
    _ = &i;
    var src_len: c_int = 0;
    _ = &src_len;
    var glyph_len: c_int = 0;
    _ = &glyph_len;
    var text: [*c]u8 = undefined;
    _ = &text;
    var text_len: c_int = undefined;
    _ = &text_len;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9087))), "char *nk_str_at_rune(struct nk_str *, int, nk_rune *, int *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (unicode != null) {} else {
                __assert_fail("unicode", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9088))), "char *nk_str_at_rune(struct nk_str *, int, nk_rune *, int *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len != null) {} else {
                __assert_fail("len", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9089))), "char *nk_str_at_rune(struct nk_str *, int, nk_rune *, int *)");
            };
        };
    };
    if ((!(str != null) or !(unicode != null)) or !(len != null)) return null;
    if (pos < @as(c_int, 0)) {
        unicode.* = 0;
        len.* = 0;
        return null;
    }
    text = @as([*c]u8, @ptrCast(@alignCast(str.*.buffer.memory.ptr)));
    text_len = @as(c_int, @bitCast(@as(c_uint, @truncate(str.*.buffer.allocated))));
    glyph_len = nk_utf_decode(text, unicode, text_len);
    while (glyph_len != 0) {
        if (i == pos) {
            len.* = glyph_len;
            break;
        }
        i += 1;
        src_len = src_len + glyph_len;
        glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(src_len)))), unicode, text_len - src_len);
    }
    if (i != pos) return null;
    return text + @as(usize, @bitCast(@as(isize, @intCast(src_len))));
}
pub fn nk_str_rune_at(arg_str: [*c]const struct_nk_str, arg_pos: c_int) callconv(.c) nk_rune {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var len: c_int = undefined;
    _ = &len;
    var unicode: nk_rune = 0;
    _ = &unicode;
    _ = nk_str_at_const(str, pos, &unicode, &len);
    return unicode;
}
pub fn nk_str_at_char_const(arg_s: [*c]const struct_nk_str, arg_pos: c_int) callconv(.c) [*c]const u8 {
    var s = arg_s;
    _ = &s;
    var pos = arg_pos;
    _ = &pos;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9117))), "const char *nk_str_at_char_const(const struct nk_str *, int)");
            };
        };
    };
    if (!(s != null) or (pos > @as(c_int, @bitCast(@as(c_uint, @truncate(s.*.buffer.allocated)))))) return null;
    return @as([*c]u8, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(s.*.buffer.memory.ptr))) + @as(usize, @bitCast(@as(isize, @intCast(pos)))))))));
}
pub fn nk_str_at_const(arg_str: [*c]const struct_nk_str, arg_pos: c_int, arg_unicode: [*c]nk_rune, arg_len: [*c]c_int) callconv(.c) [*c]const u8 {
    var str = arg_str;
    _ = &str;
    var pos = arg_pos;
    _ = &pos;
    var unicode = arg_unicode;
    _ = &unicode;
    var len = arg_len;
    _ = &len;
    var i: c_int = 0;
    _ = &i;
    var src_len: c_int = 0;
    _ = &src_len;
    var glyph_len: c_int = 0;
    _ = &glyph_len;
    var text: [*c]u8 = undefined;
    _ = &text;
    var text_len: c_int = undefined;
    _ = &text_len;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9130))), "const char *nk_str_at_const(const struct nk_str *, int, nk_rune *, int *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (unicode != null) {} else {
                __assert_fail("unicode", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9131))), "const char *nk_str_at_const(const struct nk_str *, int, nk_rune *, int *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len != null) {} else {
                __assert_fail("len", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9132))), "const char *nk_str_at_const(const struct nk_str *, int, nk_rune *, int *)");
            };
        };
    };
    if ((!(str != null) or !(unicode != null)) or !(len != null)) return null;
    if (pos < @as(c_int, 0)) {
        unicode.* = 0;
        len.* = 0;
        return null;
    }
    text = @as([*c]u8, @ptrCast(@alignCast(str.*.buffer.memory.ptr)));
    text_len = @as(c_int, @bitCast(@as(c_uint, @truncate(str.*.buffer.allocated))));
    glyph_len = nk_utf_decode(text, unicode, text_len);
    while (glyph_len != 0) {
        if (i == pos) {
            len.* = glyph_len;
            break;
        }
        i += 1;
        src_len = src_len + glyph_len;
        glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(src_len)))), unicode, text_len - src_len);
    }
    if (i != pos) return null;
    return text + @as(usize, @bitCast(@as(isize, @intCast(src_len))));
}
pub fn nk_str_get(arg_s: [*c]struct_nk_str) callconv(.c) [*c]u8 {
    var s = arg_s;
    _ = &s;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9168))), "char *nk_str_get(struct nk_str *)");
            };
        };
    };
    if ((!(s != null) or !(s.*.len != 0)) or !(s.*.buffer.allocated != 0)) return null;
    return @as([*c]u8, @ptrCast(@alignCast(s.*.buffer.memory.ptr)));
}
pub fn nk_str_get_const(arg_s: [*c]const struct_nk_str) callconv(.c) [*c]const u8 {
    var s = arg_s;
    _ = &s;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9175))), "const char *nk_str_get_const(const struct nk_str *)");
            };
        };
    };
    if ((!(s != null) or !(s.*.len != 0)) or !(s.*.buffer.allocated != 0)) return null;
    return @as([*c]const u8, @ptrCast(@alignCast(s.*.buffer.memory.ptr)));
}
pub fn nk_str_len(arg_s: [*c]const struct_nk_str) callconv(.c) c_int {
    var s = arg_s;
    _ = &s;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9182))), "int nk_str_len(const struct nk_str *)");
            };
        };
    };
    if ((!(s != null) or !(s.*.len != 0)) or !(s.*.buffer.allocated != 0)) return 0;
    return s.*.len;
}
pub fn nk_str_len_char(arg_s: [*c]const struct_nk_str) callconv(.c) c_int {
    var s = arg_s;
    _ = &s;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9189))), "int nk_str_len_char(const struct nk_str *)");
            };
        };
    };
    if ((!(s != null) or !(s.*.len != 0)) or !(s.*.buffer.allocated != 0)) return 0;
    return @as(c_int, @bitCast(@as(c_uint, @truncate(s.*.buffer.allocated))));
}
pub const NK_TEXT_EDIT_SINGLE_LINE: c_int = 0;
pub const NK_TEXT_EDIT_MULTI_LINE: c_int = 1;
pub const enum_nk_text_edit_type = c_uint;
pub const NK_TEXT_EDIT_MODE_VIEW: c_int = 0;
pub const NK_TEXT_EDIT_MODE_INSERT: c_int = 1;
pub const NK_TEXT_EDIT_MODE_REPLACE: c_int = 2;
pub const enum_nk_text_edit_mode = c_uint;
pub fn nk_filter_default(arg_box: [*c]const struct_nk_text_edit, arg_unicode: nk_rune) callconv(.c) nk_bool {
    var box = arg_box;
    _ = &box;
    var unicode = arg_unicode;
    _ = &unicode;
    _ = &unicode;
    _ = &box;
    return nk_true;
}
pub fn nk_filter_ascii(arg_box: [*c]const struct_nk_text_edit, arg_unicode: nk_rune) callconv(.c) nk_bool {
    var box = arg_box;
    _ = &box;
    var unicode = arg_unicode;
    _ = &unicode;
    _ = &box;
    if (unicode > @as(nk_rune, @bitCast(@as(c_int, 128)))) return nk_false else return nk_true;
    return @import("std").mem.zeroes(nk_bool);
}
pub fn nk_filter_float(arg_box: [*c]const struct_nk_text_edit, arg_unicode: nk_rune) callconv(.c) nk_bool {
    var box = arg_box;
    _ = &box;
    var unicode = arg_unicode;
    _ = &unicode;
    _ = &box;
    if ((((unicode < @as(nk_rune, @bitCast(@as(c_int, '0')))) or (unicode > @as(nk_rune, @bitCast(@as(c_int, '9'))))) and (unicode != @as(nk_rune, @bitCast(@as(c_int, '.'))))) and (unicode != @as(nk_rune, @bitCast(@as(c_int, '-'))))) return nk_false else return nk_true;
    return @import("std").mem.zeroes(nk_bool);
}
pub fn nk_filter_decimal(arg_box: [*c]const struct_nk_text_edit, arg_unicode: nk_rune) callconv(.c) nk_bool {
    var box = arg_box;
    _ = &box;
    var unicode = arg_unicode;
    _ = &unicode;
    _ = &box;
    if (((unicode < @as(nk_rune, @bitCast(@as(c_int, '0')))) or (unicode > @as(nk_rune, @bitCast(@as(c_int, '9'))))) and (unicode != @as(nk_rune, @bitCast(@as(c_int, '-'))))) return nk_false else return nk_true;
    return @import("std").mem.zeroes(nk_bool);
}
pub fn nk_filter_hex(arg_box: [*c]const struct_nk_text_edit, arg_unicode: nk_rune) callconv(.c) nk_bool {
    var box = arg_box;
    _ = &box;
    var unicode = arg_unicode;
    _ = &unicode;
    _ = &box;
    if ((((unicode < @as(nk_rune, @bitCast(@as(c_int, '0')))) or (unicode > @as(nk_rune, @bitCast(@as(c_int, '9'))))) and ((unicode < @as(nk_rune, @bitCast(@as(c_int, 'a')))) or (unicode > @as(nk_rune, @bitCast(@as(c_int, 'f')))))) and ((unicode < @as(nk_rune, @bitCast(@as(c_int, 'A')))) or (unicode > @as(nk_rune, @bitCast(@as(c_int, 'F')))))) return nk_false else return nk_true;
    return @import("std").mem.zeroes(nk_bool);
}
pub fn nk_filter_oct(arg_box: [*c]const struct_nk_text_edit, arg_unicode: nk_rune) callconv(.c) nk_bool {
    var box = arg_box;
    _ = &box;
    var unicode = arg_unicode;
    _ = &unicode;
    _ = &box;
    if ((unicode < @as(nk_rune, @bitCast(@as(c_int, '0')))) or (unicode > @as(nk_rune, @bitCast(@as(c_int, '7'))))) return nk_false else return nk_true;
    return @import("std").mem.zeroes(nk_bool);
}
pub fn nk_filter_binary(arg_box: [*c]const struct_nk_text_edit, arg_unicode: nk_rune) callconv(.c) nk_bool {
    var box = arg_box;
    _ = &box;
    var unicode = arg_unicode;
    _ = &unicode;
    _ = &box;
    if ((unicode != @as(nk_rune, @bitCast(@as(c_int, '0')))) and (unicode != @as(nk_rune, @bitCast(@as(c_int, '1'))))) return nk_false else return nk_true;
    return @import("std").mem.zeroes(nk_bool);
}
pub fn nk_textedit_init(arg_state: [*c]struct_nk_text_edit, arg_alloc: [*c]const struct_nk_allocator, arg_size: nk_size) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var alloc = arg_alloc;
    _ = &alloc;
    var size = arg_size;
    _ = &size;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27785))), "void nk_textedit_init(struct nk_text_edit *, const struct nk_allocator *, nk_size)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (alloc != null) {} else {
                __assert_fail("alloc", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27786))), "void nk_textedit_init(struct nk_text_edit *, const struct nk_allocator *, nk_size)");
            };
        };
    };
    if (!(state != null) or !(alloc != null)) return;
    nk_memset(@as(?*anyopaque, @ptrCast(state)), @as(c_int, 0), @sizeOf(struct_nk_text_edit));
    nk_textedit_clear_state(state, @as(c_uint, @bitCast(NK_TEXT_EDIT_SINGLE_LINE)), null);
    nk_str_init(&state.*.string, alloc, size);
}
pub fn nk_textedit_init_fixed(arg_state: [*c]struct_nk_text_edit, arg_memory: ?*anyopaque, arg_size: nk_size) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var memory = arg_memory;
    _ = &memory;
    var size = arg_size;
    _ = &size;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27775))), "void nk_textedit_init_fixed(struct nk_text_edit *, void *, nk_size)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (memory != null) {} else {
                __assert_fail("memory", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27776))), "void nk_textedit_init_fixed(struct nk_text_edit *, void *, nk_size)");
            };
        };
    };
    if ((!(state != null) or !(memory != null)) or !(size != 0)) return;
    nk_memset(@as(?*anyopaque, @ptrCast(state)), @as(c_int, 0), @sizeOf(struct_nk_text_edit));
    nk_textedit_clear_state(state, @as(c_uint, @bitCast(NK_TEXT_EDIT_SINGLE_LINE)), null);
    nk_str_init_fixed(&state.*.string, memory, size);
}
pub fn nk_textedit_free(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27813))), "void nk_textedit_free(struct nk_text_edit *)");
            };
        };
    };
    if (!(state != null)) return;
    nk_str_free(&state.*.string);
}
// libs/nuklear/nuklear.h:27160:29: warning: TODO implement translation of stmt class GotoStmtClass

// libs/nuklear/nuklear.h:27146:1: warning: unable to translate function, demoted to extern
pub extern fn nk_textedit_text(arg_state: [*c]struct_nk_text_edit, arg_text: [*c]const u8, arg_total_len: c_int) callconv(.c) void;
pub fn nk_textedit_delete(arg_state: [*c]struct_nk_text_edit, arg_where: c_int, arg_len: c_int) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var where = arg_where;
    _ = &where;
    var len = arg_len;
    _ = &len;
    nk_textedit_makeundo_delete(state, where, len);
    nk_str_delete_runes(&state.*.string, where, len);
    state.*.has_preferred_x = 0;
}
pub fn nk_textedit_delete_selection(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    nk_textedit_clamp(state);
    if (state.*.select_start != state.*.select_end) {
        if (state.*.select_start < state.*.select_end) {
            nk_textedit_delete(state, state.*.select_start, state.*.select_end - state.*.select_start);
            state.*.select_end = blk: {
                const tmp = state.*.select_start;
                state.*.cursor = tmp;
                break :blk tmp;
            };
        } else {
            nk_textedit_delete(state, state.*.select_end, state.*.select_start - state.*.select_end);
            state.*.select_start = blk: {
                const tmp = state.*.select_end;
                state.*.cursor = tmp;
                break :blk tmp;
            };
        }
        state.*.has_preferred_x = 0;
    }
}
pub fn nk_textedit_select_all(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27806))), "void nk_textedit_select_all(struct nk_text_edit *)");
            };
        };
    };
    state.*.select_start = 0;
    state.*.select_end = state.*.string.len;
}
pub fn nk_textedit_cut(arg_state: [*c]struct_nk_text_edit) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    if (@as(c_int, @bitCast(@as(c_uint, state.*.mode))) == NK_TEXT_EDIT_MODE_VIEW) return 0;
    if (state.*.select_start != state.*.select_end) {
        nk_textedit_delete_selection(state);
        state.*.has_preferred_x = 0;
        return 1;
    }
    return 0;
}
pub fn nk_textedit_paste(arg_state: [*c]struct_nk_text_edit, arg_ctext: [*c]const u8, arg_len: c_int) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var ctext = arg_ctext;
    _ = &ctext;
    var len = arg_len;
    _ = &len;
    var glyphs: c_int = undefined;
    _ = &glyphs;
    var text: [*c]const u8 = ctext;
    _ = &text;
    if (@as(c_int, @bitCast(@as(c_uint, state.*.mode))) == NK_TEXT_EDIT_MODE_VIEW) return 0;
    nk_textedit_clamp(state);
    nk_textedit_delete_selection(state);
    glyphs = nk_utf_len(ctext, len);
    if (nk_str_insert_text_char(&state.*.string, state.*.cursor, text, len) != 0) {
        nk_textedit_makeundo_insert(state, state.*.cursor, glyphs);
        state.*.cursor += len;
        state.*.has_preferred_x = 0;
        return 1;
    }
    if (state.*.undo.undo_point != 0) {
        state.*.undo.undo_point -= 1;
    }
    return 0;
}
pub fn nk_textedit_undo(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var s: [*c]struct_nk_text_undo_state = &state.*.undo;
    _ = &s;
    var u: struct_nk_text_undo_record = undefined;
    _ = &u;
    var r: [*c]struct_nk_text_undo_record = undefined;
    _ = &r;
    if (@as(c_int, @bitCast(@as(c_int, s.*.undo_point))) == @as(c_int, 0)) return;
    u = s.*.undo_rec[@as(c_uint, @intCast(@as(c_int, @bitCast(@as(c_int, s.*.undo_point))) - @as(c_int, 1)))];
    r = &s.*.undo_rec[@as(c_uint, @intCast(@as(c_int, @bitCast(@as(c_int, s.*.redo_point))) - @as(c_int, 1)))];
    r.*.char_storage = @as(c_short, @bitCast(@as(c_short, @truncate(-@as(c_int, 1)))));
    r.*.insert_length = u.delete_length;
    r.*.delete_length = u.insert_length;
    r.*.where = u.where;
    if (u.delete_length != 0) {
        if ((@as(c_int, @bitCast(@as(c_int, s.*.undo_char_point))) + @as(c_int, @bitCast(@as(c_int, u.delete_length)))) >= @as(c_int, 999)) {
            r.*.insert_length = 0;
        } else {
            var i: c_int = undefined;
            _ = &i;
            while ((@as(c_int, @bitCast(@as(c_int, s.*.undo_char_point))) + @as(c_int, @bitCast(@as(c_int, u.delete_length)))) > @as(c_int, @bitCast(@as(c_int, s.*.redo_char_point)))) {
                nk_textedit_discard_redo(s);
                if (@as(c_int, @bitCast(@as(c_int, s.*.redo_point))) == @as(c_int, 99)) return;
            }
            r = &s.*.undo_rec[@as(c_uint, @intCast(@as(c_int, @bitCast(@as(c_int, s.*.redo_point))) - @as(c_int, 1)))];
            r.*.char_storage = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_int, s.*.redo_char_point))) - @as(c_int, @bitCast(@as(c_int, u.delete_length)))))));
            s.*.redo_char_point = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_int, s.*.redo_char_point))) - @as(c_int, @bitCast(@as(c_int, u.delete_length)))))));
            {
                i = 0;
                while (i < @as(c_int, @bitCast(@as(c_int, u.delete_length)))) : (i += 1) {
                    s.*.undo_char[@as(c_uint, @intCast(@as(c_int, @bitCast(@as(c_int, r.*.char_storage))) + i))] = nk_str_rune_at(&state.*.string, u.where + i);
                }
            }
        }
        nk_str_delete_runes(&state.*.string, u.where, @as(c_int, @bitCast(@as(c_int, u.delete_length))));
    }
    if (u.insert_length != 0) {
        _ = nk_str_insert_text_runes(&state.*.string, u.where, &s.*.undo_char[@as(c_ushort, @intCast(u.char_storage))], @as(c_int, @bitCast(@as(c_int, u.insert_length))));
        s.*.undo_char_point = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_int, s.*.undo_char_point))) - @as(c_int, @bitCast(@as(c_int, u.insert_length)))))));
    }
    state.*.cursor = @as(c_int, @bitCast(@as(c_int, @as(c_short, @bitCast(@as(c_short, @truncate(u.where + @as(c_int, @bitCast(@as(c_int, u.insert_length))))))))));
    s.*.undo_point -= 1;
    s.*.redo_point -= 1;
}
pub fn nk_textedit_redo(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var s: [*c]struct_nk_text_undo_state = &state.*.undo;
    _ = &s;
    var u: [*c]struct_nk_text_undo_record = undefined;
    _ = &u;
    var r: struct_nk_text_undo_record = undefined;
    _ = &r;
    if (@as(c_int, @bitCast(@as(c_int, s.*.redo_point))) == @as(c_int, 99)) return;
    u = &s.*.undo_rec[@as(c_ushort, @intCast(s.*.undo_point))];
    r = s.*.undo_rec[@as(c_ushort, @intCast(s.*.redo_point))];
    u.*.delete_length = r.insert_length;
    u.*.insert_length = r.delete_length;
    u.*.where = r.where;
    u.*.char_storage = @as(c_short, @bitCast(@as(c_short, @truncate(-@as(c_int, 1)))));
    if (r.delete_length != 0) {
        if ((@as(c_int, @bitCast(@as(c_int, s.*.undo_char_point))) + @as(c_int, @bitCast(@as(c_int, u.*.insert_length)))) > @as(c_int, @bitCast(@as(c_int, s.*.redo_char_point)))) {
            u.*.insert_length = 0;
            u.*.delete_length = 0;
        } else {
            var i: c_int = undefined;
            _ = &i;
            u.*.char_storage = s.*.undo_char_point;
            s.*.undo_char_point = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_int, s.*.undo_char_point))) + @as(c_int, @bitCast(@as(c_int, u.*.insert_length)))))));
            {
                i = 0;
                while (i < @as(c_int, @bitCast(@as(c_int, u.*.insert_length)))) : (i += 1) {
                    s.*.undo_char[@as(c_uint, @intCast(@as(c_int, @bitCast(@as(c_int, u.*.char_storage))) + i))] = nk_str_rune_at(&state.*.string, u.*.where + i);
                }
            }
        }
        nk_str_delete_runes(&state.*.string, r.where, @as(c_int, @bitCast(@as(c_int, r.delete_length))));
    }
    if (r.insert_length != 0) {
        _ = nk_str_insert_text_runes(&state.*.string, r.where, &s.*.undo_char[@as(c_ushort, @intCast(r.char_storage))], @as(c_int, @bitCast(@as(c_int, r.insert_length))));
    }
    state.*.cursor = r.where + @as(c_int, @bitCast(@as(c_int, r.insert_length)));
    s.*.undo_point += 1;
    s.*.redo_point += 1;
}
pub const struct_nk_command_scissor = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    w: c_ushort = @import("std").mem.zeroes(c_ushort),
    h: c_ushort = @import("std").mem.zeroes(c_ushort),
};
pub const struct_nk_command_line = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    line_thickness: c_ushort = @import("std").mem.zeroes(c_ushort),
    begin: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    end: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_curve = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    line_thickness: c_ushort = @import("std").mem.zeroes(c_ushort),
    begin: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    end: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    ctrl: [2]struct_nk_vec2i = @import("std").mem.zeroes([2]struct_nk_vec2i),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_rect = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    rounding: c_ushort = @import("std").mem.zeroes(c_ushort),
    line_thickness: c_ushort = @import("std").mem.zeroes(c_ushort),
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    w: c_ushort = @import("std").mem.zeroes(c_ushort),
    h: c_ushort = @import("std").mem.zeroes(c_ushort),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_rect_filled = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    rounding: c_ushort = @import("std").mem.zeroes(c_ushort),
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    w: c_ushort = @import("std").mem.zeroes(c_ushort),
    h: c_ushort = @import("std").mem.zeroes(c_ushort),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_rect_multi_color = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    w: c_ushort = @import("std").mem.zeroes(c_ushort),
    h: c_ushort = @import("std").mem.zeroes(c_ushort),
    left: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    top: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    bottom: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    right: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_triangle = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    line_thickness: c_ushort = @import("std").mem.zeroes(c_ushort),
    a: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    b: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    c: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_triangle_filled = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    a: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    b: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    c: struct_nk_vec2i = @import("std").mem.zeroes(struct_nk_vec2i),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_circle = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    line_thickness: c_ushort = @import("std").mem.zeroes(c_ushort),
    w: c_ushort = @import("std").mem.zeroes(c_ushort),
    h: c_ushort = @import("std").mem.zeroes(c_ushort),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_circle_filled = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    w: c_ushort = @import("std").mem.zeroes(c_ushort),
    h: c_ushort = @import("std").mem.zeroes(c_ushort),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_arc = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    cx: c_short = @import("std").mem.zeroes(c_short),
    cy: c_short = @import("std").mem.zeroes(c_short),
    r: c_ushort = @import("std").mem.zeroes(c_ushort),
    line_thickness: c_ushort = @import("std").mem.zeroes(c_ushort),
    a: [2]f32 = @import("std").mem.zeroes([2]f32),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_arc_filled = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    cx: c_short = @import("std").mem.zeroes(c_short),
    cy: c_short = @import("std").mem.zeroes(c_short),
    r: c_ushort = @import("std").mem.zeroes(c_ushort),
    a: [2]f32 = @import("std").mem.zeroes([2]f32),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const struct_nk_command_polygon = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    line_thickness: c_ushort = @import("std").mem.zeroes(c_ushort),
    point_count: c_ushort = @import("std").mem.zeroes(c_ushort),
    points: [1]struct_nk_vec2i = @import("std").mem.zeroes([1]struct_nk_vec2i),
};
pub const struct_nk_command_polygon_filled = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    point_count: c_ushort = @import("std").mem.zeroes(c_ushort),
    points: [1]struct_nk_vec2i = @import("std").mem.zeroes([1]struct_nk_vec2i),
};
pub const struct_nk_command_polyline = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    color: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    line_thickness: c_ushort = @import("std").mem.zeroes(c_ushort),
    point_count: c_ushort = @import("std").mem.zeroes(c_ushort),
    points: [1]struct_nk_vec2i = @import("std").mem.zeroes([1]struct_nk_vec2i),
};
pub const struct_nk_command_image = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    w: c_ushort = @import("std").mem.zeroes(c_ushort),
    h: c_ushort = @import("std").mem.zeroes(c_ushort),
    img: struct_nk_image = @import("std").mem.zeroes(struct_nk_image),
    col: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
};
pub const nk_command_custom_callback = ?*const fn (?*anyopaque, c_short, c_short, c_ushort, c_ushort, nk_handle) callconv(.c) void;
pub const struct_nk_command_custom = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    w: c_ushort = @import("std").mem.zeroes(c_ushort),
    h: c_ushort = @import("std").mem.zeroes(c_ushort),
    callback_data: nk_handle = @import("std").mem.zeroes(nk_handle),
    callback: nk_command_custom_callback = @import("std").mem.zeroes(nk_command_custom_callback),
};
pub const struct_nk_command_text = extern struct {
    header: struct_nk_command = @import("std").mem.zeroes(struct_nk_command),
    font: [*c]const struct_nk_user_font = @import("std").mem.zeroes([*c]const struct_nk_user_font),
    background: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    foreground: struct_nk_color = @import("std").mem.zeroes(struct_nk_color),
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    w: c_ushort = @import("std").mem.zeroes(c_ushort),
    h: c_ushort = @import("std").mem.zeroes(c_ushort),
    height: f32 = @import("std").mem.zeroes(f32),
    length: c_int = @import("std").mem.zeroes(c_int),
    string: [2]u8 = @import("std").mem.zeroes([2]u8),
};
pub const NK_CLIPPING_OFF: c_int = 0;
pub const NK_CLIPPING_ON: c_int = 1;
pub const enum_nk_command_clipping = c_uint;
pub fn nk_stroke_line(arg_b: [*c]struct_nk_command_buffer, arg_x0: f32, arg_y0: f32, arg_x1: f32, arg_y1: f32, arg_line_thickness: f32, arg_c: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var x0 = arg_x0;
    _ = &x0;
    var y0 = arg_y0;
    _ = &y0;
    var x1 = arg_x1;
    _ = &x1;
    var y1 = arg_y1;
    _ = &y1;
    var line_thickness = arg_line_thickness;
    _ = &line_thickness;
    var c = arg_c;
    _ = &c;
    var cmd: [*c]struct_nk_command_line = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9300))), "void nk_stroke_line(struct nk_command_buffer *, float, float, float, float, float, struct nk_color)");
            };
        };
    };
    if (!(b != null) or (line_thickness <= @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    cmd = @as([*c]struct_nk_command_line, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_LINE)), @sizeOf(struct_nk_command_line)))));
    if (!(cmd != null)) return;
    cmd.*.line_thickness = @as(c_ushort, @intFromFloat(line_thickness));
    cmd.*.begin.x = @as(c_short, @intFromFloat(x0));
    cmd.*.begin.y = @as(c_short, @intFromFloat(y0));
    cmd.*.end.x = @as(c_short, @intFromFloat(x1));
    cmd.*.end.y = @as(c_short, @intFromFloat(y1));
    cmd.*.color = c;
}
pub fn nk_stroke_curve(arg_b: [*c]struct_nk_command_buffer, arg_ax: f32, arg_ay: f32, arg_ctrl0x: f32, arg_ctrl0y: f32, arg_ctrl1x: f32, arg_ctrl1y: f32, arg_bx: f32, arg_by: f32, arg_line_thickness: f32, arg_col: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var ax = arg_ax;
    _ = &ax;
    var ay = arg_ay;
    _ = &ay;
    var ctrl0x = arg_ctrl0x;
    _ = &ctrl0x;
    var ctrl0y = arg_ctrl0y;
    _ = &ctrl0y;
    var ctrl1x = arg_ctrl1x;
    _ = &ctrl1x;
    var ctrl1y = arg_ctrl1y;
    _ = &ctrl1y;
    var bx = arg_bx;
    _ = &bx;
    var by = arg_by;
    _ = &by;
    var line_thickness = arg_line_thickness;
    _ = &line_thickness;
    var col = arg_col;
    _ = &col;
    var cmd: [*c]struct_nk_command_curve = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9318))), "void nk_stroke_curve(struct nk_command_buffer *, float, float, float, float, float, float, float, float, float, struct nk_color)");
            };
        };
    };
    if ((!(b != null) or (@as(c_int, @bitCast(@as(c_uint, col.a))) == @as(c_int, 0))) or (line_thickness <= @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    cmd = @as([*c]struct_nk_command_curve, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_CURVE)), @sizeOf(struct_nk_command_curve)))));
    if (!(cmd != null)) return;
    cmd.*.line_thickness = @as(c_ushort, @intFromFloat(line_thickness));
    cmd.*.begin.x = @as(c_short, @intFromFloat(ax));
    cmd.*.begin.y = @as(c_short, @intFromFloat(ay));
    cmd.*.ctrl[@as(c_uint, @intCast(@as(c_int, 0)))].x = @as(c_short, @intFromFloat(ctrl0x));
    cmd.*.ctrl[@as(c_uint, @intCast(@as(c_int, 0)))].y = @as(c_short, @intFromFloat(ctrl0y));
    cmd.*.ctrl[@as(c_uint, @intCast(@as(c_int, 1)))].x = @as(c_short, @intFromFloat(ctrl1x));
    cmd.*.ctrl[@as(c_uint, @intCast(@as(c_int, 1)))].y = @as(c_short, @intFromFloat(ctrl1y));
    cmd.*.end.x = @as(c_short, @intFromFloat(bx));
    cmd.*.end.y = @as(c_short, @intFromFloat(by));
    cmd.*.color = col;
}
pub fn nk_stroke_rect(arg_b: [*c]struct_nk_command_buffer, arg_rect: struct_nk_rect, arg_rounding: f32, arg_line_thickness: f32, arg_c: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var rect = arg_rect;
    _ = &rect;
    var rounding = arg_rounding;
    _ = &rounding;
    var line_thickness = arg_line_thickness;
    _ = &line_thickness;
    var c = arg_c;
    _ = &c;
    var cmd: [*c]struct_nk_command_rect = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9340))), "void nk_stroke_rect(struct nk_command_buffer *, struct nk_rect, float, float, struct nk_color)");
            };
        };
    };
    if ((((!(b != null) or (@as(c_int, @bitCast(@as(c_uint, c.a))) == @as(c_int, 0))) or (rect.w == @as(f32, @floatFromInt(@as(c_int, 0))))) or (rect.h == @as(f32, @floatFromInt(@as(c_int, 0))))) or (line_thickness <= @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    if (b.*.use_clipping != 0) {
        var clip: [*c]const struct_nk_rect = &b.*.clip;
        _ = &clip;
        if (!((((clip.*.x < (rect.x + rect.w)) and (rect.x < (clip.*.x + clip.*.w))) and (clip.*.y < (rect.y + rect.h))) and (rect.y < (clip.*.y + clip.*.h)))) return;
    }
    cmd = @as([*c]struct_nk_command_rect, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_RECT)), @sizeOf(struct_nk_command_rect)))));
    if (!(cmd != null)) return;
    cmd.*.rounding = @as(c_ushort, @intFromFloat(rounding));
    cmd.*.line_thickness = @as(c_ushort, @intFromFloat(line_thickness));
    cmd.*.x = @as(c_short, @intFromFloat(rect.x));
    cmd.*.y = @as(c_short, @intFromFloat(rect.y));
    cmd.*.w = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < rect.w) rect.w else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.h = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < rect.h) rect.h else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.color = c;
}
pub fn nk_stroke_circle(arg_b: [*c]struct_nk_command_buffer, arg_r: struct_nk_rect, arg_line_thickness: f32, arg_c: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var r = arg_r;
    _ = &r;
    var line_thickness = arg_line_thickness;
    _ = &line_thickness;
    var c = arg_c;
    _ = &c;
    var cmd: [*c]struct_nk_command_circle = undefined;
    _ = &cmd;
    if (((!(b != null) or (r.w == @as(f32, @floatFromInt(@as(c_int, 0))))) or (r.h == @as(f32, @floatFromInt(@as(c_int, 0))))) or (line_thickness <= @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    if (b.*.use_clipping != 0) {
        var clip: [*c]const struct_nk_rect = &b.*.clip;
        _ = &clip;
        if (!((((clip.*.x < (r.x + r.w)) and (r.x < (clip.*.x + clip.*.w))) and (clip.*.y < (r.y + r.h))) and (r.y < (clip.*.y + clip.*.h)))) return;
    }
    cmd = @as([*c]struct_nk_command_circle, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_CIRCLE)), @sizeOf(struct_nk_command_circle)))));
    if (!(cmd != null)) return;
    cmd.*.line_thickness = @as(c_ushort, @intFromFloat(line_thickness));
    cmd.*.x = @as(c_short, @intFromFloat(r.x));
    cmd.*.y = @as(c_short, @intFromFloat(r.y));
    cmd.*.w = @as(c_ushort, @intFromFloat(if (r.w < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else r.w));
    cmd.*.h = @as(c_ushort, @intFromFloat(if (r.h < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else r.h));
    cmd.*.color = c;
}
pub fn nk_stroke_arc(arg_b: [*c]struct_nk_command_buffer, arg_cx: f32, arg_cy: f32, arg_radius: f32, arg_a_min: f32, arg_a_max: f32, arg_line_thickness: f32, arg_c: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var cx = arg_cx;
    _ = &cx;
    var cy = arg_cy;
    _ = &cy;
    var radius = arg_radius;
    _ = &radius;
    var a_min = arg_a_min;
    _ = &a_min;
    var a_max = arg_a_max;
    _ = &a_max;
    var line_thickness = arg_line_thickness;
    _ = &line_thickness;
    var c = arg_c;
    _ = &c;
    var cmd: [*c]struct_nk_command_arc = undefined;
    _ = &cmd;
    if ((!(b != null) or (@as(c_int, @bitCast(@as(c_uint, c.a))) == @as(c_int, 0))) or (line_thickness <= @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    cmd = @as([*c]struct_nk_command_arc, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_ARC)), @sizeOf(struct_nk_command_arc)))));
    if (!(cmd != null)) return;
    cmd.*.line_thickness = @as(c_ushort, @intFromFloat(line_thickness));
    cmd.*.cx = @as(c_short, @intFromFloat(cx));
    cmd.*.cy = @as(c_short, @intFromFloat(cy));
    cmd.*.r = @as(c_ushort, @intFromFloat(radius));
    cmd.*.a[@as(c_uint, @intCast(@as(c_int, 0)))] = a_min;
    cmd.*.a[@as(c_uint, @intCast(@as(c_int, 1)))] = a_max;
    cmd.*.color = c;
}
pub fn nk_stroke_triangle(arg_b: [*c]struct_nk_command_buffer, arg_x0: f32, arg_y0: f32, arg_x1: f32, arg_y1: f32, arg_x2: f32, arg_y2: f32, arg_line_thickness: f32, arg_c: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var x0 = arg_x0;
    _ = &x0;
    var y0 = arg_y0;
    _ = &y0;
    var x1 = arg_x1;
    _ = &x1;
    var y1 = arg_y1;
    _ = &y1;
    var x2 = arg_x2;
    _ = &x2;
    var y2 = arg_y2;
    _ = &y2;
    var line_thickness = arg_line_thickness;
    _ = &line_thickness;
    var c = arg_c;
    _ = &c;
    var cmd: [*c]struct_nk_command_triangle = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9489))), "void nk_stroke_triangle(struct nk_command_buffer *, float, float, float, float, float, float, float, struct nk_color)");
            };
        };
    };
    if ((!(b != null) or (@as(c_int, @bitCast(@as(c_uint, c.a))) == @as(c_int, 0))) or (line_thickness <= @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    if (b.*.use_clipping != 0) {
        var clip: [*c]const struct_nk_rect = &b.*.clip;
        _ = &clip;
        if ((!(((clip.*.x <= x0) and (x0 < (clip.*.x + clip.*.w))) and ((clip.*.y <= y0) and (y0 < (clip.*.y + clip.*.h)))) and !(((clip.*.x <= x1) and (x1 < (clip.*.x + clip.*.w))) and ((clip.*.y <= y1) and (y1 < (clip.*.y + clip.*.h))))) and !(((clip.*.x <= x2) and (x2 < (clip.*.x + clip.*.w))) and ((clip.*.y <= y2) and (y2 < (clip.*.y + clip.*.h))))) return;
    }
    cmd = @as([*c]struct_nk_command_triangle, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_TRIANGLE)), @sizeOf(struct_nk_command_triangle)))));
    if (!(cmd != null)) return;
    cmd.*.line_thickness = @as(c_ushort, @intFromFloat(line_thickness));
    cmd.*.a.x = @as(c_short, @intFromFloat(x0));
    cmd.*.a.y = @as(c_short, @intFromFloat(y0));
    cmd.*.b.x = @as(c_short, @intFromFloat(x1));
    cmd.*.b.y = @as(c_short, @intFromFloat(y1));
    cmd.*.c.x = @as(c_short, @intFromFloat(x2));
    cmd.*.c.y = @as(c_short, @intFromFloat(y2));
    cmd.*.color = c;
}
pub fn nk_stroke_polyline(arg_b: [*c]struct_nk_command_buffer, arg_points: [*c]const f32, arg_point_count: c_int, arg_line_thickness: f32, arg_col: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var points = arg_points;
    _ = &points;
    var point_count = arg_point_count;
    _ = &point_count;
    var line_thickness = arg_line_thickness;
    _ = &line_thickness;
    var col = arg_col;
    _ = &col;
    var i: c_int = undefined;
    _ = &i;
    var size: nk_size = 0;
    _ = &size;
    var cmd: [*c]struct_nk_command_polyline = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9588))), "void nk_stroke_polyline(struct nk_command_buffer *, const float *, int, float, struct nk_color)");
            };
        };
    };
    if ((!(b != null) or (@as(c_int, @bitCast(@as(c_uint, col.a))) == @as(c_int, 0))) or (line_thickness <= @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    size = @sizeOf(struct_nk_command_polyline) +% ((@sizeOf(c_short) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) *% @as(nk_size, @bitCast(@as(c_long, point_count))));
    cmd = @as([*c]struct_nk_command_polyline, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_POLYLINE)), size))));
    if (!(cmd != null)) return;
    cmd.*.color = col;
    cmd.*.point_count = @as(c_ushort, @bitCast(@as(c_short, @truncate(point_count))));
    cmd.*.line_thickness = @as(c_ushort, @intFromFloat(line_thickness));
    {
        i = 0;
        while (i < point_count) : (i += 1) {
            cmd.*.points[@as(c_uint, @intCast(i))].x = @as(c_short, @intFromFloat((blk: {
                const tmp = i * @as(c_int, 2);
                if (tmp >= 0) break :blk points + @as(usize, @intCast(tmp)) else break :blk points - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*));
            cmd.*.points[@as(c_uint, @intCast(i))].y = @as(c_short, @intFromFloat((blk: {
                const tmp = (i * @as(c_int, 2)) + @as(c_int, 1);
                if (tmp >= 0) break :blk points + @as(usize, @intCast(tmp)) else break :blk points - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*));
        }
    }
}
pub fn nk_stroke_polygon(arg_b: [*c]struct_nk_command_buffer, arg_points: [*c]const f32, arg_point_count: c_int, arg_line_thickness: f32, arg_col: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var points = arg_points;
    _ = &points;
    var point_count = arg_point_count;
    _ = &point_count;
    var line_thickness = arg_line_thickness;
    _ = &line_thickness;
    var col = arg_col;
    _ = &col;
    var i: c_int = undefined;
    _ = &i;
    var size: nk_size = 0;
    _ = &size;
    var cmd: [*c]struct_nk_command_polygon = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9546))), "void nk_stroke_polygon(struct nk_command_buffer *, const float *, int, float, struct nk_color)");
            };
        };
    };
    if ((!(b != null) or (@as(c_int, @bitCast(@as(c_uint, col.a))) == @as(c_int, 0))) or (line_thickness <= @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    size = @sizeOf(struct_nk_command_polygon) +% ((@sizeOf(c_short) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) *% @as(nk_size, @bitCast(@as(c_long, point_count))));
    cmd = @as([*c]struct_nk_command_polygon, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_POLYGON)), size))));
    if (!(cmd != null)) return;
    cmd.*.color = col;
    cmd.*.line_thickness = @as(c_ushort, @intFromFloat(line_thickness));
    cmd.*.point_count = @as(c_ushort, @bitCast(@as(c_short, @truncate(point_count))));
    {
        i = 0;
        while (i < point_count) : (i += 1) {
            cmd.*.points[@as(c_uint, @intCast(i))].x = @as(c_short, @intFromFloat((blk: {
                const tmp = i * @as(c_int, 2);
                if (tmp >= 0) break :blk points + @as(usize, @intCast(tmp)) else break :blk points - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*));
            cmd.*.points[@as(c_uint, @intCast(i))].y = @as(c_short, @intFromFloat((blk: {
                const tmp = (i * @as(c_int, 2)) + @as(c_int, 1);
                if (tmp >= 0) break :blk points + @as(usize, @intCast(tmp)) else break :blk points - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*));
        }
    }
}
pub fn nk_fill_rect(arg_b: [*c]struct_nk_command_buffer, arg_rect: struct_nk_rect, arg_rounding: f32, arg_c: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var rect = arg_rect;
    _ = &rect;
    var rounding = arg_rounding;
    _ = &rounding;
    var c = arg_c;
    _ = &c;
    var cmd: [*c]struct_nk_command_rect_filled = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9363))), "void nk_fill_rect(struct nk_command_buffer *, struct nk_rect, float, struct nk_color)");
            };
        };
    };
    if (((!(b != null) or (@as(c_int, @bitCast(@as(c_uint, c.a))) == @as(c_int, 0))) or (rect.w == @as(f32, @floatFromInt(@as(c_int, 0))))) or (rect.h == @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    if (b.*.use_clipping != 0) {
        var clip: [*c]const struct_nk_rect = &b.*.clip;
        _ = &clip;
        if (!((((clip.*.x < (rect.x + rect.w)) and (rect.x < (clip.*.x + clip.*.w))) and (clip.*.y < (rect.y + rect.h))) and (rect.y < (clip.*.y + clip.*.h)))) return;
    }
    cmd = @as([*c]struct_nk_command_rect_filled, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_RECT_FILLED)), @sizeOf(struct_nk_command_rect_filled)))));
    if (!(cmd != null)) return;
    cmd.*.rounding = @as(c_ushort, @intFromFloat(rounding));
    cmd.*.x = @as(c_short, @intFromFloat(rect.x));
    cmd.*.y = @as(c_short, @intFromFloat(rect.y));
    cmd.*.w = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < rect.w) rect.w else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.h = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < rect.h) rect.h else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.color = c;
}
pub fn nk_fill_rect_multi_color(arg_b: [*c]struct_nk_command_buffer, arg_rect: struct_nk_rect, arg_left: struct_nk_color, arg_top: struct_nk_color, arg_right: struct_nk_color, arg_bottom: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var rect = arg_rect;
    _ = &rect;
    var left = arg_left;
    _ = &left;
    var top = arg_top;
    _ = &top;
    var right = arg_right;
    _ = &right;
    var bottom = arg_bottom;
    _ = &bottom;
    var cmd: [*c]struct_nk_command_rect_multi_color = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9387))), "void nk_fill_rect_multi_color(struct nk_command_buffer *, struct nk_rect, struct nk_color, struct nk_color, struct nk_color, struct nk_color)");
            };
        };
    };
    if ((!(b != null) or (rect.w == @as(f32, @floatFromInt(@as(c_int, 0))))) or (rect.h == @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    if (b.*.use_clipping != 0) {
        var clip: [*c]const struct_nk_rect = &b.*.clip;
        _ = &clip;
        if (!((((clip.*.x < (rect.x + rect.w)) and (rect.x < (clip.*.x + clip.*.w))) and (clip.*.y < (rect.y + rect.h))) and (rect.y < (clip.*.y + clip.*.h)))) return;
    }
    cmd = @as([*c]struct_nk_command_rect_multi_color, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_RECT_MULTI_COLOR)), @sizeOf(struct_nk_command_rect_multi_color)))));
    if (!(cmd != null)) return;
    cmd.*.x = @as(c_short, @intFromFloat(rect.x));
    cmd.*.y = @as(c_short, @intFromFloat(rect.y));
    cmd.*.w = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < rect.w) rect.w else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.h = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < rect.h) rect.h else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.left = left;
    cmd.*.top = top;
    cmd.*.right = right;
    cmd.*.bottom = bottom;
}
pub fn nk_fill_circle(arg_b: [*c]struct_nk_command_buffer, arg_r: struct_nk_rect, arg_c: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var r = arg_r;
    _ = &r;
    var c = arg_c;
    _ = &c;
    var cmd: [*c]struct_nk_command_circle_filled = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9433))), "void nk_fill_circle(struct nk_command_buffer *, struct nk_rect, struct nk_color)");
            };
        };
    };
    if (((!(b != null) or (@as(c_int, @bitCast(@as(c_uint, c.a))) == @as(c_int, 0))) or (r.w == @as(f32, @floatFromInt(@as(c_int, 0))))) or (r.h == @as(f32, @floatFromInt(@as(c_int, 0))))) return;
    if (b.*.use_clipping != 0) {
        var clip: [*c]const struct_nk_rect = &b.*.clip;
        _ = &clip;
        if (!((((clip.*.x < (r.x + r.w)) and (r.x < (clip.*.x + clip.*.w))) and (clip.*.y < (r.y + r.h))) and (r.y < (clip.*.y + clip.*.h)))) return;
    }
    cmd = @as([*c]struct_nk_command_circle_filled, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_CIRCLE_FILLED)), @sizeOf(struct_nk_command_circle_filled)))));
    if (!(cmd != null)) return;
    cmd.*.x = @as(c_short, @intFromFloat(r.x));
    cmd.*.y = @as(c_short, @intFromFloat(r.y));
    cmd.*.w = @as(c_ushort, @intFromFloat(if (r.w < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else r.w));
    cmd.*.h = @as(c_ushort, @intFromFloat(if (r.h < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else r.h));
    cmd.*.color = c;
}
pub fn nk_fill_arc(arg_b: [*c]struct_nk_command_buffer, arg_cx: f32, arg_cy: f32, arg_radius: f32, arg_a_min: f32, arg_a_max: f32, arg_c: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var cx = arg_cx;
    _ = &cx;
    var cy = arg_cy;
    _ = &cy;
    var radius = arg_radius;
    _ = &radius;
    var a_min = arg_a_min;
    _ = &a_min;
    var a_max = arg_a_max;
    _ = &a_max;
    var c = arg_c;
    _ = &c;
    var cmd: [*c]struct_nk_command_arc_filled = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9472))), "void nk_fill_arc(struct nk_command_buffer *, float, float, float, float, float, struct nk_color)");
            };
        };
    };
    if (!(b != null) or (@as(c_int, @bitCast(@as(c_uint, c.a))) == @as(c_int, 0))) return;
    cmd = @as([*c]struct_nk_command_arc_filled, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_ARC_FILLED)), @sizeOf(struct_nk_command_arc_filled)))));
    if (!(cmd != null)) return;
    cmd.*.cx = @as(c_short, @intFromFloat(cx));
    cmd.*.cy = @as(c_short, @intFromFloat(cy));
    cmd.*.r = @as(c_ushort, @intFromFloat(radius));
    cmd.*.a[@as(c_uint, @intCast(@as(c_int, 0)))] = a_min;
    cmd.*.a[@as(c_uint, @intCast(@as(c_int, 1)))] = a_max;
    cmd.*.color = c;
}
pub fn nk_fill_triangle(arg_b: [*c]struct_nk_command_buffer, arg_x0: f32, arg_y0: f32, arg_x1: f32, arg_y1: f32, arg_x2: f32, arg_y2: f32, arg_c: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var x0 = arg_x0;
    _ = &x0;
    var y0 = arg_y0;
    _ = &y0;
    var x1 = arg_x1;
    _ = &x1;
    var y1 = arg_y1;
    _ = &y1;
    var x2 = arg_x2;
    _ = &x2;
    var y2 = arg_y2;
    _ = &y2;
    var c = arg_c;
    _ = &c;
    var cmd: [*c]struct_nk_command_triangle_filled = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9516))), "void nk_fill_triangle(struct nk_command_buffer *, float, float, float, float, float, float, struct nk_color)");
            };
        };
    };
    if (!(b != null) or (@as(c_int, @bitCast(@as(c_uint, c.a))) == @as(c_int, 0))) return;
    if (!(b != null)) return;
    if (b.*.use_clipping != 0) {
        var clip: [*c]const struct_nk_rect = &b.*.clip;
        _ = &clip;
        if ((!(((clip.*.x <= x0) and (x0 < (clip.*.x + clip.*.w))) and ((clip.*.y <= y0) and (y0 < (clip.*.y + clip.*.h)))) and !(((clip.*.x <= x1) and (x1 < (clip.*.x + clip.*.w))) and ((clip.*.y <= y1) and (y1 < (clip.*.y + clip.*.h))))) and !(((clip.*.x <= x2) and (x2 < (clip.*.x + clip.*.w))) and ((clip.*.y <= y2) and (y2 < (clip.*.y + clip.*.h))))) return;
    }
    cmd = @as([*c]struct_nk_command_triangle_filled, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_TRIANGLE_FILLED)), @sizeOf(struct_nk_command_triangle_filled)))));
    if (!(cmd != null)) return;
    cmd.*.a.x = @as(c_short, @intFromFloat(x0));
    cmd.*.a.y = @as(c_short, @intFromFloat(y0));
    cmd.*.b.x = @as(c_short, @intFromFloat(x1));
    cmd.*.b.y = @as(c_short, @intFromFloat(y1));
    cmd.*.c.x = @as(c_short, @intFromFloat(x2));
    cmd.*.c.y = @as(c_short, @intFromFloat(y2));
    cmd.*.color = c;
}
pub fn nk_fill_polygon(arg_b: [*c]struct_nk_command_buffer, arg_points: [*c]const f32, arg_point_count: c_int, arg_col: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var points = arg_points;
    _ = &points;
    var point_count = arg_point_count;
    _ = &point_count;
    var col = arg_col;
    _ = &col;
    var i: c_int = undefined;
    _ = &i;
    var size: nk_size = 0;
    _ = &size;
    var cmd: [*c]struct_nk_command_polygon_filled = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9567))), "void nk_fill_polygon(struct nk_command_buffer *, const float *, int, struct nk_color)");
            };
        };
    };
    if (!(b != null) or (@as(c_int, @bitCast(@as(c_uint, col.a))) == @as(c_int, 0))) return;
    size = @sizeOf(struct_nk_command_polygon_filled) +% ((@sizeOf(c_short) *% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) *% @as(nk_size, @bitCast(@as(c_long, point_count))));
    cmd = @as([*c]struct_nk_command_polygon_filled, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_POLYGON_FILLED)), size))));
    if (!(cmd != null)) return;
    cmd.*.color = col;
    cmd.*.point_count = @as(c_ushort, @bitCast(@as(c_short, @truncate(point_count))));
    {
        i = 0;
        while (i < point_count) : (i += 1) {
            cmd.*.points[@as(c_uint, @intCast(i))].x = @as(c_short, @intFromFloat((blk: {
                const tmp = (i * @as(c_int, 2)) + @as(c_int, 0);
                if (tmp >= 0) break :blk points + @as(usize, @intCast(tmp)) else break :blk points - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*));
            cmd.*.points[@as(c_uint, @intCast(i))].y = @as(c_short, @intFromFloat((blk: {
                const tmp = (i * @as(c_int, 2)) + @as(c_int, 1);
                if (tmp >= 0) break :blk points + @as(usize, @intCast(tmp)) else break :blk points - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*));
        }
    }
}
pub fn nk_draw_image(arg_b: [*c]struct_nk_command_buffer, arg_r: struct_nk_rect, arg_img: [*c]const struct_nk_image, arg_col: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var r = arg_r;
    _ = &r;
    var img = arg_img;
    _ = &img;
    var col = arg_col;
    _ = &col;
    var cmd: [*c]struct_nk_command_image = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9606))), "void nk_draw_image(struct nk_command_buffer *, struct nk_rect, const struct nk_image *, struct nk_color)");
            };
        };
    };
    if (!(b != null)) return;
    if (b.*.use_clipping != 0) {
        var c: [*c]const struct_nk_rect = &b.*.clip;
        _ = &c;
        if (((c.*.w == @as(f32, @floatFromInt(@as(c_int, 0)))) or (c.*.h == @as(f32, @floatFromInt(@as(c_int, 0))))) or !((((c.*.x < (r.x + r.w)) and (r.x < (c.*.x + c.*.w))) and (c.*.y < (r.y + r.h))) and (r.y < (c.*.y + c.*.h)))) return;
    }
    cmd = @as([*c]struct_nk_command_image, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_IMAGE)), @sizeOf(struct_nk_command_image)))));
    if (!(cmd != null)) return;
    cmd.*.x = @as(c_short, @intFromFloat(r.x));
    cmd.*.y = @as(c_short, @intFromFloat(r.y));
    cmd.*.w = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < r.w) r.w else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.h = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < r.h) r.h else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.img = img.*;
    cmd.*.col = col;
}
pub fn nk_draw_nine_slice(arg_b: [*c]struct_nk_command_buffer, arg_r: struct_nk_rect, arg_slc: [*c]const struct_nk_nine_slice, arg_col: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var r = arg_r;
    _ = &r;
    var slc = arg_slc;
    _ = &slc;
    var col = arg_col;
    _ = &col;
    var img: struct_nk_image = undefined;
    _ = &img;
    var slcimg: [*c]const struct_nk_image = @as([*c]const struct_nk_image, @ptrCast(@alignCast(slc)));
    _ = &slcimg;
    var rgnX: nk_ushort = undefined;
    _ = &rgnX;
    var rgnY: nk_ushort = undefined;
    _ = &rgnY;
    var rgnW: nk_ushort = undefined;
    _ = &rgnW;
    var rgnH: nk_ushort = undefined;
    _ = &rgnH;
    rgnX = slcimg.*.region[@as(c_uint, @intCast(@as(c_int, 0)))];
    rgnY = slcimg.*.region[@as(c_uint, @intCast(@as(c_int, 1)))];
    rgnW = slcimg.*.region[@as(c_uint, @intCast(@as(c_int, 2)))];
    rgnH = slcimg.*.region[@as(c_uint, @intCast(@as(c_int, 3)))];
    img.handle = slcimg.*.handle;
    img.w = slcimg.*.w;
    img.h = slcimg.*.h;
    img.region[@as(c_uint, @intCast(@as(c_int, 0)))] = rgnX;
    img.region[@as(c_uint, @intCast(@as(c_int, 1)))] = rgnY;
    img.region[@as(c_uint, @intCast(@as(c_int, 2)))] = slc.*.l;
    img.region[@as(c_uint, @intCast(@as(c_int, 3)))] = slc.*.t;
    nk_draw_image(b, nk_rect(r.x, r.y, @as(f32, @floatFromInt(slc.*.l)), @as(f32, @floatFromInt(slc.*.t))), &img, col);
    img.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, rgnX))) + @as(c_int, @bitCast(@as(c_uint, slc.*.l)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 1)))] = rgnY;
    img.region[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnW))) - @as(c_int, @bitCast(@as(c_uint, slc.*.l)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.r)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 3)))] = slc.*.t;
    nk_draw_image(b, nk_rect(r.x + @as(f32, @floatFromInt(slc.*.l)), r.y, (r.w - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.l)))))) - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.r))))), @as(f32, @floatFromInt(slc.*.t))), &img, col);
    img.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnX))) + @as(c_int, @bitCast(@as(c_uint, rgnW)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.r)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 1)))] = rgnY;
    img.region[@as(c_uint, @intCast(@as(c_int, 2)))] = slc.*.r;
    img.region[@as(c_uint, @intCast(@as(c_int, 3)))] = slc.*.t;
    nk_draw_image(b, nk_rect((r.x + r.w) - @as(f32, @floatFromInt(slc.*.r)), r.y, @as(f32, @floatFromInt(slc.*.r)), @as(f32, @floatFromInt(slc.*.t))), &img, col);
    img.region[@as(c_uint, @intCast(@as(c_int, 0)))] = rgnX;
    img.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, rgnY))) + @as(c_int, @bitCast(@as(c_uint, slc.*.t)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 2)))] = slc.*.l;
    img.region[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnH))) - @as(c_int, @bitCast(@as(c_uint, slc.*.t)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.b)))))));
    nk_draw_image(b, nk_rect(r.x, r.y + @as(f32, @floatFromInt(slc.*.t)), @as(f32, @floatFromInt(slc.*.l)), (r.h - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.t)))))) - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.b)))))), &img, col);
    img.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, rgnX))) + @as(c_int, @bitCast(@as(c_uint, slc.*.l)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, rgnY))) + @as(c_int, @bitCast(@as(c_uint, slc.*.t)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnW))) - @as(c_int, @bitCast(@as(c_uint, slc.*.l)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.r)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnH))) - @as(c_int, @bitCast(@as(c_uint, slc.*.t)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.b)))))));
    nk_draw_image(b, nk_rect(r.x + @as(f32, @floatFromInt(slc.*.l)), r.y + @as(f32, @floatFromInt(slc.*.t)), (r.w - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.l)))))) - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.r))))), (r.h - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.t)))))) - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.b)))))), &img, col);
    img.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnX))) + @as(c_int, @bitCast(@as(c_uint, rgnW)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.r)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, rgnY))) + @as(c_int, @bitCast(@as(c_uint, slc.*.t)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 2)))] = slc.*.r;
    img.region[@as(c_uint, @intCast(@as(c_int, 3)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnH))) - @as(c_int, @bitCast(@as(c_uint, slc.*.t)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.b)))))));
    nk_draw_image(b, nk_rect((r.x + r.w) - @as(f32, @floatFromInt(slc.*.r)), r.y + @as(f32, @floatFromInt(slc.*.t)), @as(f32, @floatFromInt(slc.*.r)), (r.h - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.t)))))) - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.b)))))), &img, col);
    img.region[@as(c_uint, @intCast(@as(c_int, 0)))] = rgnX;
    img.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnY))) + @as(c_int, @bitCast(@as(c_uint, rgnH)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.b)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 2)))] = slc.*.l;
    img.region[@as(c_uint, @intCast(@as(c_int, 3)))] = slc.*.b;
    nk_draw_image(b, nk_rect(r.x, (r.y + r.h) - @as(f32, @floatFromInt(slc.*.b)), @as(f32, @floatFromInt(slc.*.l)), @as(f32, @floatFromInt(slc.*.b))), &img, col);
    img.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_uint, rgnX))) + @as(c_int, @bitCast(@as(c_uint, slc.*.l)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnY))) + @as(c_int, @bitCast(@as(c_uint, rgnH)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.b)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 2)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnW))) - @as(c_int, @bitCast(@as(c_uint, slc.*.l)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.r)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 3)))] = slc.*.b;
    nk_draw_image(b, nk_rect(r.x + @as(f32, @floatFromInt(slc.*.l)), (r.y + r.h) - @as(f32, @floatFromInt(slc.*.b)), (r.w - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.l)))))) - @as(f32, @floatFromInt(@as(c_int, @bitCast(@as(c_uint, slc.*.r))))), @as(f32, @floatFromInt(slc.*.b))), &img, col);
    img.region[@as(c_uint, @intCast(@as(c_int, 0)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnX))) + @as(c_int, @bitCast(@as(c_uint, rgnW)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.r)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 1)))] = @as(nk_ushort, @bitCast(@as(c_short, @truncate((@as(c_int, @bitCast(@as(c_uint, rgnY))) + @as(c_int, @bitCast(@as(c_uint, rgnH)))) - @as(c_int, @bitCast(@as(c_uint, slc.*.b)))))));
    img.region[@as(c_uint, @intCast(@as(c_int, 2)))] = slc.*.r;
    img.region[@as(c_uint, @intCast(@as(c_int, 3)))] = slc.*.b;
    nk_draw_image(b, nk_rect((r.x + r.w) - @as(f32, @floatFromInt(slc.*.r)), (r.y + r.h) - @as(f32, @floatFromInt(slc.*.b)), @as(f32, @floatFromInt(slc.*.r)), @as(f32, @floatFromInt(slc.*.b))), &img, col);
}
pub fn nk_draw_text(arg_b: [*c]struct_nk_command_buffer, arg_r: struct_nk_rect, arg_string: [*c]const u8, arg_length: c_int, arg_font: [*c]const struct_nk_user_font, arg_bg: struct_nk_color, arg_fg: struct_nk_color) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var r = arg_r;
    _ = &r;
    var string = arg_string;
    _ = &string;
    var length = arg_length;
    _ = &length;
    var font = arg_font;
    _ = &font;
    var bg = arg_bg;
    _ = &bg;
    var fg = arg_fg;
    _ = &fg;
    var text_width: f32 = 0;
    _ = &text_width;
    var cmd: [*c]struct_nk_command_text = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9732))), "void nk_draw_text(struct nk_command_buffer *, struct nk_rect, const char *, int, const struct nk_user_font *, struct nk_color, struct nk_color)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9733))), "void nk_draw_text(struct nk_command_buffer *, struct nk_rect, const char *, int, const struct nk_user_font *, struct nk_color, struct nk_color)");
            };
        };
    };
    if (((!(b != null) or !(string != null)) or !(length != 0)) or ((@as(c_int, @bitCast(@as(c_uint, bg.a))) == @as(c_int, 0)) and (@as(c_int, @bitCast(@as(c_uint, fg.a))) == @as(c_int, 0)))) return;
    if (b.*.use_clipping != 0) {
        var c: [*c]const struct_nk_rect = &b.*.clip;
        _ = &c;
        if (((c.*.w == @as(f32, @floatFromInt(@as(c_int, 0)))) or (c.*.h == @as(f32, @floatFromInt(@as(c_int, 0))))) or !((((c.*.x < (r.x + r.w)) and (r.x < (c.*.x + c.*.w))) and (c.*.y < (r.y + r.h))) and (r.y < (c.*.y + c.*.h)))) return;
    }
    text_width = font.*.width.?(font.*.userdata, font.*.height, string, length);
    if (text_width > r.w) {
        var glyphs: c_int = 0;
        _ = &glyphs;
        var txt_width: f32 = text_width;
        _ = &txt_width;
        length = nk_text_clamp(font, string, length, r.w, &glyphs, &txt_width, null, @as(c_int, 0));
    }
    if (!(length != 0)) return;
    cmd = @as([*c]struct_nk_command_text, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_TEXT)), @sizeOf(struct_nk_command_text) +% @as(nk_size, @bitCast(@as(c_long, length + @as(c_int, 1))))))));
    if (!(cmd != null)) return;
    cmd.*.x = @as(c_short, @intFromFloat(r.x));
    cmd.*.y = @as(c_short, @intFromFloat(r.y));
    cmd.*.w = @as(c_ushort, @intFromFloat(r.w));
    cmd.*.h = @as(c_ushort, @intFromFloat(r.h));
    cmd.*.background = bg;
    cmd.*.foreground = fg;
    cmd.*.font = font;
    cmd.*.length = length;
    cmd.*.height = font.*.height;
    _ = nk_memcopy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&cmd.*.string))))), @as(?*const anyopaque, @ptrCast(string)), @as(nk_size, @bitCast(@as(c_long, length))));
    cmd.*.string[@as(c_uint, @intCast(length))] = '\x00';
}
pub fn nk_push_scissor(arg_b: [*c]struct_nk_command_buffer, arg_r: struct_nk_rect) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var r = arg_r;
    _ = &r;
    var cmd: [*c]struct_nk_command_scissor = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9279))), "void nk_push_scissor(struct nk_command_buffer *, struct nk_rect)");
            };
        };
    };
    if (!(b != null)) return;
    b.*.clip.x = r.x;
    b.*.clip.y = r.y;
    b.*.clip.w = r.w;
    b.*.clip.h = r.h;
    cmd = @as([*c]struct_nk_command_scissor, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_SCISSOR)), @sizeOf(struct_nk_command_scissor)))));
    if (!(cmd != null)) return;
    cmd.*.x = @as(c_short, @intFromFloat(r.x));
    cmd.*.y = @as(c_short, @intFromFloat(r.y));
    cmd.*.w = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < r.w) r.w else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.h = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < r.h) r.h else @as(f32, @floatFromInt(@as(c_int, 0)))));
}
pub fn nk_push_custom(arg_b: [*c]struct_nk_command_buffer, arg_r: struct_nk_rect, arg_cb: nk_command_custom_callback, arg_usr: nk_handle) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    var r = arg_r;
    _ = &r;
    var cb = arg_cb;
    _ = &cb;
    var usr = arg_usr;
    _ = &usr;
    var cmd: [*c]struct_nk_command_custom = undefined;
    _ = &cmd;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9706))), "void nk_push_custom(struct nk_command_buffer *, struct nk_rect, nk_command_custom_callback, nk_handle)");
            };
        };
    };
    if (!(b != null)) return;
    if (b.*.use_clipping != 0) {
        var c: [*c]const struct_nk_rect = &b.*.clip;
        _ = &c;
        if (((c.*.w == @as(f32, @floatFromInt(@as(c_int, 0)))) or (c.*.h == @as(f32, @floatFromInt(@as(c_int, 0))))) or !((((c.*.x < (r.x + r.w)) and (r.x < (c.*.x + c.*.w))) and (c.*.y < (r.y + r.h))) and (r.y < (c.*.y + c.*.h)))) return;
    }
    cmd = @as([*c]struct_nk_command_custom, @ptrCast(@alignCast(nk_command_buffer_push(b, @as(c_uint, @bitCast(NK_COMMAND_CUSTOM)), @sizeOf(struct_nk_command_custom)))));
    if (!(cmd != null)) return;
    cmd.*.x = @as(c_short, @intFromFloat(r.x));
    cmd.*.y = @as(c_short, @intFromFloat(r.y));
    cmd.*.w = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < r.w) r.w else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.h = @as(c_ushort, @intFromFloat(if (@as(f32, @floatFromInt(@as(c_int, 0))) < r.h) r.h else @as(f32, @floatFromInt(@as(c_int, 0)))));
    cmd.*.callback_data = usr;
    cmd.*.callback = cb;
}
pub fn nk_input_has_mouse_click(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    var btn: [*c]const struct_nk_mouse_button = undefined;
    _ = &btn;
    if (!(i != null)) return nk_false;
    btn = &i.*.mouse.buttons[id];
    return if ((btn.*.clicked != 0) and (btn.*.down == nk_false)) nk_true else nk_false;
}
pub fn nk_input_has_mouse_click_in_rect(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons, arg_b: struct_nk_rect) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    var b = arg_b;
    _ = &b;
    var btn: [*c]const struct_nk_mouse_button = undefined;
    _ = &btn;
    if (!(i != null)) return nk_false;
    btn = &i.*.mouse.buttons[id];
    if (!(((b.x <= btn.*.clicked_pos.x) and (btn.*.clicked_pos.x < (b.x + b.w))) and ((b.y <= btn.*.clicked_pos.y) and (btn.*.clicked_pos.y < (b.y + b.h))))) return nk_false;
    return nk_true;
}
pub fn nk_input_has_mouse_click_in_button_rect(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons, arg_b: struct_nk_rect) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    var b = arg_b;
    _ = &b;
    var btn: [*c]const struct_nk_mouse_button = undefined;
    _ = &btn;
    if (!(i != null)) return nk_false;
    btn = &i.*.mouse.buttons[id];
    if (!(((b.x <= btn.*.clicked_pos.x) and (btn.*.clicked_pos.x < (b.x + b.w))) and ((b.y <= btn.*.clicked_pos.y) and (btn.*.clicked_pos.y < (b.y + b.h))))) return nk_false;
    return nk_true;
}
pub fn nk_input_has_mouse_click_down_in_rect(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons, arg_b: struct_nk_rect, arg_down: nk_bool) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    var b = arg_b;
    _ = &b;
    var down = arg_down;
    _ = &down;
    var btn: [*c]const struct_nk_mouse_button = undefined;
    _ = &btn;
    if (!(i != null)) return nk_false;
    btn = &i.*.mouse.buttons[id];
    return @intFromBool((nk_input_has_mouse_click_in_rect(i, id, b) != 0) and (btn.*.down == down));
}
pub fn nk_input_is_mouse_click_in_rect(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons, arg_b: struct_nk_rect) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    var b = arg_b;
    _ = &b;
    var btn: [*c]const struct_nk_mouse_button = undefined;
    _ = &btn;
    if (!(i != null)) return nk_false;
    btn = &i.*.mouse.buttons[id];
    return if ((nk_input_has_mouse_click_down_in_rect(i, id, b, nk_false) != 0) and (btn.*.clicked != 0)) nk_true else nk_false;
}
pub fn nk_input_is_mouse_click_down_in_rect(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons, arg_b: struct_nk_rect, arg_down: nk_bool) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    var b = arg_b;
    _ = &b;
    var down = arg_down;
    _ = &down;
    var btn: [*c]const struct_nk_mouse_button = undefined;
    _ = &btn;
    if (!(i != null)) return nk_false;
    btn = &i.*.mouse.buttons[id];
    return if ((nk_input_has_mouse_click_down_in_rect(i, id, b, down) != 0) and (btn.*.clicked != 0)) nk_true else nk_false;
}
pub fn nk_input_any_mouse_click_in_rect(arg_in: [*c]const struct_nk_input, arg_b: struct_nk_rect) callconv(.c) nk_bool {
    var in = arg_in;
    _ = &in;
    var b = arg_b;
    _ = &b;
    var i: c_int = undefined;
    _ = &i;
    var down: c_int = 0;
    _ = &down;
    {
        i = 0;
        while (i < NK_BUTTON_MAX) : (i += 1) {
            down = @intFromBool((down != 0) or (nk_input_is_mouse_click_in_rect(in, @as(c_uint, @bitCast(i)), b) != 0));
        }
    }
    return down;
}
pub fn nk_input_is_mouse_prev_hovering_rect(arg_i: [*c]const struct_nk_input, arg_rect: struct_nk_rect) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var rect = arg_rect;
    _ = &rect;
    if (!(i != null)) return nk_false;
    return @intFromBool(((rect.x <= i.*.mouse.prev.x) and (i.*.mouse.prev.x < (rect.x + rect.w))) and ((rect.y <= i.*.mouse.prev.y) and (i.*.mouse.prev.y < (rect.y + rect.h))));
}
pub fn nk_input_is_mouse_hovering_rect(arg_i: [*c]const struct_nk_input, arg_rect: struct_nk_rect) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var rect = arg_rect;
    _ = &rect;
    if (!(i != null)) return nk_false;
    return @intFromBool(((rect.x <= i.*.mouse.pos.x) and (i.*.mouse.pos.x < (rect.x + rect.w))) and ((rect.y <= i.*.mouse.pos.y) and (i.*.mouse.pos.y < (rect.y + rect.h))));
}
pub fn nk_input_mouse_clicked(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons, arg_rect: struct_nk_rect) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    var rect = arg_rect;
    _ = &rect;
    if (!(i != null)) return nk_false;
    if (!(nk_input_is_mouse_hovering_rect(i, rect) != 0)) return nk_false;
    return nk_input_is_mouse_click_in_rect(i, id, rect);
}
pub fn nk_input_is_mouse_down(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    if (!(i != null)) return nk_false;
    return i.*.mouse.buttons[id].down;
}
pub fn nk_input_is_mouse_pressed(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    var b: [*c]const struct_nk_mouse_button = undefined;
    _ = &b;
    if (!(i != null)) return nk_false;
    b = &i.*.mouse.buttons[id];
    if ((b.*.down != 0) and (b.*.clicked != 0)) return nk_true;
    return nk_false;
}
pub fn nk_input_is_mouse_released(arg_i: [*c]const struct_nk_input, arg_id: enum_nk_buttons) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var id = arg_id;
    _ = &id;
    if (!(i != null)) return nk_false;
    return @intFromBool(!(i.*.mouse.buttons[id].down != 0) and (i.*.mouse.buttons[id].clicked != 0));
}
pub fn nk_input_is_key_pressed(arg_i: [*c]const struct_nk_input, arg_key: enum_nk_keys) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var key = arg_key;
    _ = &key;
    var k: [*c]const struct_nk_key = undefined;
    _ = &k;
    if (!(i != null)) return nk_false;
    k = &i.*.keyboard.keys[key];
    if (((k.*.down != 0) and (k.*.clicked != 0)) or (!(k.*.down != 0) and (k.*.clicked >= @as(c_uint, @bitCast(@as(c_int, 2)))))) return nk_true;
    return nk_false;
}
pub fn nk_input_is_key_released(arg_i: [*c]const struct_nk_input, arg_key: enum_nk_keys) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var key = arg_key;
    _ = &key;
    var k: [*c]const struct_nk_key = undefined;
    _ = &k;
    if (!(i != null)) return nk_false;
    k = &i.*.keyboard.keys[key];
    if ((!(k.*.down != 0) and (k.*.clicked != 0)) or ((k.*.down != 0) and (k.*.clicked >= @as(c_uint, @bitCast(@as(c_int, 2)))))) return nk_true;
    return nk_false;
}
pub fn nk_input_is_key_down(arg_i: [*c]const struct_nk_input, arg_key: enum_nk_keys) callconv(.c) nk_bool {
    var i = arg_i;
    _ = &i;
    var key = arg_key;
    _ = &key;
    var k: [*c]const struct_nk_key = undefined;
    _ = &k;
    if (!(i != null)) return nk_false;
    k = &i.*.keyboard.keys[key];
    if (k.*.down != 0) return nk_true;
    return nk_false;
}
pub fn nk_style_item_color(arg_col: struct_nk_color) callconv(.c) struct_nk_style_item {
    var col = arg_col;
    _ = &col;
    var i: struct_nk_style_item = undefined;
    _ = &i;
    i.type = @as(c_uint, @bitCast(NK_STYLE_ITEM_COLOR));
    i.data.color = col;
    return i;
}
pub fn nk_style_item_image(arg_img: struct_nk_image) callconv(.c) struct_nk_style_item {
    var img = arg_img;
    _ = &img;
    var i: struct_nk_style_item = undefined;
    _ = &i;
    i.type = @as(c_uint, @bitCast(NK_STYLE_ITEM_IMAGE));
    i.data.image = img;
    return i;
}
pub fn nk_style_item_nine_slice(arg_slice: struct_nk_nine_slice) callconv(.c) struct_nk_style_item {
    var slice = arg_slice;
    _ = &slice;
    var i: struct_nk_style_item = undefined;
    _ = &i;
    i.type = @as(c_uint, @bitCast(NK_STYLE_ITEM_NINE_SLICE));
    i.data.slice = slice;
    return i;
}
pub fn nk_style_item_hide() callconv(.c) struct_nk_style_item {
    var i: struct_nk_style_item = undefined;
    _ = &i;
    i.type = @as(c_uint, @bitCast(NK_STYLE_ITEM_COLOR));
    i.data.color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
    return i;
}
pub const NK_PANEL_SET_NONBLOCK: c_int = 240;
pub const NK_PANEL_SET_POPUP: c_int = 244;
pub const NK_PANEL_SET_SUB: c_int = 246;
pub const enum_nk_panel_set = c_uint;
pub const NK_WINDOW_PRIVATE: c_int = 2048;
pub const NK_WINDOW_DYNAMIC: c_int = 2048;
pub const NK_WINDOW_ROM: c_int = 4096;
pub const NK_WINDOW_NOT_INTERACTIVE: c_int = 5120;
pub const NK_WINDOW_HIDDEN: c_int = 8192;
pub const NK_WINDOW_CLOSED: c_int = 16384;
pub const NK_WINDOW_MINIMIZED: c_int = 32768;
pub const NK_WINDOW_REMOVE_ROM: c_int = 65536;
pub const enum_nk_window_flags = c_uint;
pub extern fn __assert_fail(__assertion: [*c]const u8, __file: [*c]const u8, __line: c_uint, __function: [*c]const u8) noreturn;
pub extern fn __assert_perror_fail(__errnum: c_int, __file: [*c]const u8, __line: c_uint, __function: [*c]const u8) noreturn;
pub extern fn __assert(__assertion: [*c]const u8, __file: [*c]const u8, __line: c_int) noreturn;
pub const _dummy_array6115 = [1]u8;
pub const _dummy_array6116 = [1]u8;
pub const _dummy_array6117 = [1]u8;
pub const _dummy_array6118 = [1]u8;
pub const _dummy_array6119 = [1]u8;
pub const _dummy_array6120 = [1]u8;
pub const _dummy_array6121 = [1]u8;
pub const _dummy_array6122 = [1]u8;
pub const _dummy_array6123 = [1]u8;
pub const _dummy_array6127 = [1]u8;
pub const nk_null_rect: struct_nk_rect = struct_nk_rect{
    .x = -8192.0,
    .y = -8192.0,
    .w = @as(f32, @floatFromInt(@as(c_int, 16384))),
    .h = @as(f32, @floatFromInt(@as(c_int, 16384))),
};
pub const nk_red: struct_nk_color = struct_nk_color{
    .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
};
pub const nk_green: struct_nk_color = struct_nk_color{
    .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
};
pub const nk_blue: struct_nk_color = struct_nk_color{
    .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
};
pub const nk_white: struct_nk_color = struct_nk_color{
    .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
};
pub const nk_black: struct_nk_color = struct_nk_color{
    .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
};
pub const nk_yellow: struct_nk_color = struct_nk_color{
    .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
    .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
};
pub fn nk_inv_sqrt(arg_n: f32) callconv(.c) f32 {
    var n = arg_n;
    _ = &n;
    var x2: f32 = undefined;
    _ = &x2;
    const threehalfs: f32 = 1.5;
    _ = &threehalfs;
    const union_unnamed_2 = extern union {
        i: nk_uint,
        f: f32,
    };
    _ = &union_unnamed_2;
    var conv: union_unnamed_2 = union_unnamed_2{
        .i = @as(nk_uint, @bitCast(@as(c_int, 0))),
    };
    _ = &conv;
    conv.f = n;
    x2 = n * 0.5;
    conv.i = @as(nk_uint, @bitCast(@as(c_int, 1597463172))) -% (conv.i >> @intCast(1));
    conv.f = conv.f * (threehalfs - ((x2 * conv.f) * conv.f));
    return conv.f;
}
pub fn nk_sin(arg_x: f32) callconv(.c) f32 {
    var x = arg_x;
    _ = &x;
    const a0 = struct {
        const static: f32 = 0.00000000000000000000000000000019105930344931873;
    };
    _ = &a0;
    const a1 = struct {
        const static: f32 = 1.0008676052093506;
    };
    _ = &a1;
    const a2 = struct {
        const static: f32 = -0.012127612717449665;
    };
    _ = &a2;
    const a3 = struct {
        const static: f32 = -0.13807877898216248;
    };
    _ = &a3;
    const a4 = struct {
        const static: f32 = -0.0267353393137455;
    };
    _ = &a4;
    const a5 = struct {
        const static: f32 = 0.020802659913897514;
    };
    _ = &a5;
    const a6 = struct {
        const static: f32 = -0.003039960516616702;
    };
    _ = &a6;
    const a7 = struct {
        const static: f32 = 0.00013823564222548157;
    };
    _ = &a7;
    return a0.static + (x * (a1.static + (x * (a2.static + (x * (a3.static + (x * (a4.static + (x * (a5.static + (x * (a6.static + (x * a7.static)))))))))))));
}
pub fn nk_cos(arg_x: f32) callconv(.c) f32 {
    var x = arg_x;
    _ = &x;
    const a0 = struct {
        const static: f32 = 0.9999600052833557;
    };
    _ = &a0;
    const a1 = struct {
        const static: f32 = 0.001254899543710053;
    };
    _ = &a1;
    const a2 = struct {
        const static: f32 = -0.5064854621887207;
    };
    _ = &a2;
    const a3 = struct {
        const static: f32 = 0.012942246161401272;
    };
    _ = &a3;
    const a4 = struct {
        const static: f32 = 0.02866838499903679;
    };
    _ = &a4;
    const a5 = struct {
        const static: f32 = 0.0073726484552025795;
    };
    _ = &a5;
    const a6 = struct {
        const static: f32 = -0.0038510875310748816;
    };
    _ = &a6;
    const a7 = struct {
        const static: f32 = 0.0004719660500995815;
    };
    _ = &a7;
    const a8 = struct {
        const static: f32 = -0.000018776443539536558;
    };
    _ = &a8;
    return a0.static + (x * (a1.static + (x * (a2.static + (x * (a3.static + (x * (a4.static + (x * (a5.static + (x * (a6.static + (x * (a7.static + (x * a8.static)))))))))))))));
}
pub fn nk_atan(arg_x: f32) callconv(.c) f32 {
    var x = arg_x;
    _ = &x;
    var u: f32 = -0.000010989005204464775;
    _ = &u;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((x >= 0.0) and (@intFromPtr("TODO support negative floats") != 0)) {} else {
                __assert_fail("x >= 0.0f && \"TODO support negative floats\"", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 6522))), "float nk_atan(float)");
            };
        };
    };
    u = (u * x) + 0.0003411794896237552;
    u = (u * x) + -0.004493229556828737;
    u = (u * x) + 0.03259626403450966;
    u = (u * x) + -0.14088021218776703;
    u = (u * x) + 0.36040401458740234;
    u = (u * x) + -0.47017866373062134;
    u = (u * x) + 0.0005019877571612597;
    u = (u * x) + 1.007768154144287;
    u = (u * x) + -0.00047654370428062975;
    return u;
}
pub fn nk_atan2(arg_y: f32, arg_x: f32) callconv(.c) f32 {
    var y = arg_y;
    _ = &y;
    var x = arg_x;
    _ = &x;
    var ax: f32 = if (x < @as(f32, @floatFromInt(@as(c_int, 0)))) -x else x;
    _ = &ax;
    var ay: f32 = if (y < @as(f32, @floatFromInt(@as(c_int, 0)))) -y else y;
    _ = &ay;
    var signs: nk_uint = @as(nk_uint, @bitCast(@intFromBool(y < @as(f32, @floatFromInt(@as(c_int, 0)))) | ((x < @as(f32, @floatFromInt(@as(c_int, 0)))) << @intCast(1))));
    _ = &signs;
    var a: f32 = undefined;
    _ = &a;
    if ((@as(f64, @floatCast(y)) == 0.0) and (@as(f64, @floatCast(x)) == 0.0)) return 0.0;
    a = if (ay > ax) 1.5707963705062866 - nk_atan(ax / ay) else nk_atan(ay / ax);
    while (true) {
        switch (signs) {
            @as(nk_uint, @bitCast(@as(c_int, 0))) => return a,
            @as(nk_uint, @bitCast(@as(c_int, 1))) => return -a,
            @as(nk_uint, @bitCast(@as(c_int, 2))) => return -a + 3.1415927410125732,
            @as(nk_uint, @bitCast(@as(c_int, 3))) => return a - 3.1415927410125732,
            else => {},
        }
        break;
    }
    return 0.0;
}
pub fn nk_round_up_pow2(arg_v: nk_uint) callconv(.c) nk_uint {
    var v = arg_v;
    _ = &v;
    v -%= 1;
    v |= v >> @intCast(1);
    v |= v >> @intCast(2);
    v |= v >> @intCast(4);
    v |= v >> @intCast(8);
    v |= v >> @intCast(16);
    v +%= 1;
    return v;
}
pub fn nk_shrink_rect(arg_r: struct_nk_rect, arg_amount: f32) callconv(.c) struct_nk_rect {
    var r = arg_r;
    _ = &r;
    var amount = arg_amount;
    _ = &amount;
    var res: struct_nk_rect = undefined;
    _ = &res;
    r.w = if (r.w < (@as(f32, @floatFromInt(@as(c_int, 2))) * amount)) @as(f32, @floatFromInt(@as(c_int, 2))) * amount else r.w;
    r.h = if (r.h < (@as(f32, @floatFromInt(@as(c_int, 2))) * amount)) @as(f32, @floatFromInt(@as(c_int, 2))) * amount else r.h;
    res.x = r.x + amount;
    res.y = r.y + amount;
    res.w = r.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * amount);
    res.h = r.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * amount);
    return res;
}
pub fn nk_pad_rect(arg_r: struct_nk_rect, arg_pad: struct_nk_vec2) callconv(.c) struct_nk_rect {
    var r = arg_r;
    _ = &r;
    var pad = arg_pad;
    _ = &pad;
    r.w = if (r.w < (@as(f32, @floatFromInt(@as(c_int, 2))) * pad.x)) @as(f32, @floatFromInt(@as(c_int, 2))) * pad.x else r.w;
    r.h = if (r.h < (@as(f32, @floatFromInt(@as(c_int, 2))) * pad.y)) @as(f32, @floatFromInt(@as(c_int, 2))) * pad.y else r.h;
    r.x += pad.x;
    r.y += pad.y;
    r.w -= @as(f32, @floatFromInt(@as(c_int, 2))) * pad.x;
    r.h -= @as(f32, @floatFromInt(@as(c_int, 2))) * pad.y;
    return r;
}
pub fn nk_unify(arg_clip: [*c]struct_nk_rect, arg_a: [*c]const struct_nk_rect, arg_x0: f32, arg_y0: f32, arg_x1: f32, arg_y1: f32) callconv(.c) void {
    var clip = arg_clip;
    _ = &clip;
    var a = arg_a;
    _ = &a;
    var x0 = arg_x0;
    _ = &x0;
    var y0 = arg_y0;
    _ = &y0;
    var x1 = arg_x1;
    _ = &x1;
    var y1 = arg_y1;
    _ = &y1;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (a != null) {} else {
                __assert_fail("a", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 6736))), "void nk_unify(struct nk_rect *, const struct nk_rect *, float, float, float, float)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (clip != null) {} else {
                __assert_fail("clip", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 6737))), "void nk_unify(struct nk_rect *, const struct nk_rect *, float, float, float, float)");
            };
        };
    };
    clip.*.x = if (a.*.x < x0) x0 else a.*.x;
    clip.*.y = if (a.*.y < y0) y0 else a.*.y;
    clip.*.w = (if ((a.*.x + a.*.w) < x1) a.*.x + a.*.w else x1) - clip.*.x;
    clip.*.h = (if ((a.*.y + a.*.h) < y1) a.*.y + a.*.h else y1) - clip.*.y;
    clip.*.w = if (@as(f32, @floatFromInt(@as(c_int, 0))) < clip.*.w) clip.*.w else @as(f32, @floatFromInt(@as(c_int, 0)));
    clip.*.h = if (@as(f32, @floatFromInt(@as(c_int, 0))) < clip.*.h) clip.*.h else @as(f32, @floatFromInt(@as(c_int, 0)));
}
pub fn nk_pow(arg_x: f64, arg_n: c_int) callconv(.c) f64 {
    var x = arg_x;
    _ = &x;
    var n = arg_n;
    _ = &n;
    var r: f64 = 1;
    _ = &r;
    var plus: c_int = @intFromBool(n >= @as(c_int, 0));
    _ = &plus;
    n = if (plus != 0) n else -n;
    while (n > @as(c_int, 0)) {
        if ((n & @as(c_int, 1)) == @as(c_int, 1)) {
            r *= x;
        }
        n = @divTrunc(n, @as(c_int, 2));
        x *= x;
    }
    return if (plus != 0) r else 1.0 / r;
}
pub fn nk_ifloord(arg_x: f64) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    x = @as(f64, @floatFromInt(@as(c_int, @intFromFloat(x)) - (if (x < 0.0) @as(c_int, 1) else @as(c_int, 0))));
    return @as(c_int, @intFromFloat(x));
}
pub fn nk_ifloorf(arg_x: f32) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    x = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(x)) - (if (x < 0.0) @as(c_int, 1) else @as(c_int, 0))));
    return @as(c_int, @intFromFloat(x));
}
pub fn nk_iceilf(arg_x: f32) callconv(.c) c_int {
    var x = arg_x;
    _ = &x;
    if (x >= @as(f32, @floatFromInt(@as(c_int, 0)))) {
        var i: c_int = @as(c_int, @intFromFloat(x));
        _ = &i;
        return if (x > @as(f32, @floatFromInt(i))) i + @as(c_int, 1) else i;
    } else {
        var t: c_int = @as(c_int, @intFromFloat(x));
        _ = &t;
        var r: f32 = x - @as(f32, @floatFromInt(t));
        _ = &r;
        return if (r > 0.0) t + @as(c_int, 1) else t;
    }
    return 0;
}
pub fn nk_log10(arg_n: f64) callconv(.c) c_int {
    var n = arg_n;
    _ = &n;
    var neg: c_int = undefined;
    _ = &neg;
    var ret: c_int = undefined;
    _ = &ret;
    var exp: c_int = 0;
    _ = &exp;
    neg = if (n < @as(f64, @floatFromInt(@as(c_int, 0)))) @as(c_int, 1) else @as(c_int, 0);
    ret = if (neg != 0) @as(c_int, @intFromFloat(-n)) else @as(c_int, @intFromFloat(n));
    while (@divTrunc(ret, @as(c_int, 10)) > @as(c_int, 0)) {
        ret = @divTrunc(ret, @as(c_int, 10));
        exp += 1;
    }
    if (neg != 0) {
        exp = -exp;
    }
    return exp;
}
pub fn nk_roundf(arg_x: f32) callconv(.c) f32 {
    var x = arg_x;
    _ = &x;
    return if (x >= 0.0) @as(f32, @floatFromInt(nk_ifloorf(x + 0.5))) else @as(f32, @floatFromInt(nk_iceilf(x - 0.5)));
}
pub const NK_DO_NOT_STOP_ON_NEW_LINE: c_int = 0;
pub const NK_STOP_ON_NEW_LINE: c_int = 1;
const enum_unnamed_3 = c_uint;
pub fn nk_is_lower(arg_c: c_int) callconv(.c) nk_bool {
    var c = arg_c;
    _ = &c;
    return @intFromBool(((c >= @as(c_int, 'a')) and (c <= @as(c_int, 'z'))) or ((c >= @as(c_int, 224)) and (c <= @as(c_int, 255))));
}
pub fn nk_is_upper(arg_c: c_int) callconv(.c) nk_bool {
    var c = arg_c;
    _ = &c;
    return @intFromBool(((c >= @as(c_int, 'A')) and (c <= @as(c_int, 'Z'))) or ((c >= @as(c_int, 192)) and (c <= @as(c_int, 223))));
}
pub fn nk_to_upper(arg_c: c_int) callconv(.c) c_int {
    var c = arg_c;
    _ = &c;
    return if ((c >= @as(c_int, 'a')) and (c <= @as(c_int, 'z'))) c - (@as(c_int, 'a') - @as(c_int, 'A')) else c;
}
pub fn nk_to_lower(arg_c: c_int) callconv(.c) c_int {
    var c = arg_c;
    _ = &c;
    return if ((c >= @as(c_int, 'A')) and (c <= @as(c_int, 'Z'))) c - (@as(c_int, 'a') + @as(c_int, 'A')) else c;
}
// libs/nuklear/nuklear.h:6808:9: warning: TODO implement translation of stmt class GotoStmtClass

// libs/nuklear/nuklear.h:6802:1: warning: unable to translate function, demoted to extern
pub extern fn nk_memcopy(arg_dst0: ?*anyopaque, arg_src0: ?*const anyopaque, arg_length: nk_size) callconv(.c) ?*anyopaque;
pub fn nk_memset(arg_ptr: ?*anyopaque, arg_c0: c_int, arg_size: nk_size) callconv(.c) void {
    var ptr = arg_ptr;
    _ = &ptr;
    var c0 = arg_c0;
    _ = &c0;
    var size = arg_size;
    _ = &size;
    var dst: [*c]nk_byte = @as([*c]nk_byte, @ptrCast(@alignCast(ptr)));
    _ = &dst;
    var c: c_uint = 0;
    _ = &c;
    var t: nk_size = 0;
    _ = &t;
    if ((blk: {
        const tmp = @as(c_uint, @bitCast(@as(c_uint, @as(nk_byte, @bitCast(@as(i8, @truncate(c0)))))));
        c = tmp;
        break :blk tmp;
    }) != @as(c_uint, @bitCast(@as(c_int, 0)))) {
        c = (c << @intCast(8)) | c;
        if (@sizeOf(c_uint) > @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))) {
            c = (c << @intCast(16)) | c;
        }
    }
    dst = @as([*c]nk_byte, @ptrCast(@alignCast(ptr)));
    if (size < (@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 3)))) *% @sizeOf(c_uint))) {
        while ((blk: {
            const ref = &size;
            const tmp = ref.*;
            ref.* -%= 1;
            break :blk tmp;
        }) != 0) {
            (blk: {
                const ref = &dst;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = @as(nk_byte, @bitCast(@as(i8, @truncate(c0))));
        }
        return;
    }
    if ((blk: {
        const tmp = @as(nk_size, @bitCast(@as(c_long, @intCast(@intFromPtr(dst))))) & (@sizeOf(c_uint) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))));
        t = tmp;
        break :blk tmp;
    }) != @as(nk_size, @bitCast(@as(c_long, @as(c_int, 0))))) {
        t = @sizeOf(c_uint) -% t;
        size -%= t;
        while (true) {
            (blk: {
                const ref = &dst;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = @as(nk_byte, @bitCast(@as(i8, @truncate(c0))));
            if (!((blk: {
                const ref = &t;
                ref.* -%= 1;
                break :blk ref.*;
            }) != @as(nk_size, @bitCast(@as(c_long, @as(c_int, 0)))))) break;
        }
    }
    t = size / @sizeOf(c_uint);
    while (true) {
        @as([*c]c_uint, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(dst))))).* = c;
        dst += @sizeOf(c_uint);
        if (!((blk: {
            const ref = &t;
            ref.* -%= 1;
            break :blk ref.*;
        }) != @as(nk_size, @bitCast(@as(c_long, @as(c_int, 0)))))) break;
    }
    t = size & (@sizeOf(c_uint) -% @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))));
    if (t != @as(nk_size, @bitCast(@as(c_long, @as(c_int, 0))))) {
        while (true) {
            (blk: {
                const ref = &dst;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = @as(nk_byte, @bitCast(@as(i8, @truncate(c0))));
            if (!((blk: {
                const ref = &t;
                ref.* -%= 1;
                break :blk ref.*;
            }) != @as(nk_size, @bitCast(@as(c_long, @as(c_int, 0)))))) break;
        }
    }
}
pub fn nk_zero(arg_ptr: ?*anyopaque, arg_size: nk_size) callconv(.c) void {
    var ptr = arg_ptr;
    _ = &ptr;
    var size = arg_size;
    _ = &size;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ptr != null) {} else {
                __assert_fail("ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 6915))), "void nk_zero(void *, nk_size)");
            };
        };
    };
    nk_memset(ptr, @as(c_int, 0), size);
}
pub fn nk_itoa(arg_s: [*c]u8, arg_n: c_long) callconv(.c) [*c]u8 {
    var s = arg_s;
    _ = &s;
    var n = arg_n;
    _ = &n;
    var i: c_long = 0;
    _ = &i;
    if (n == @as(c_long, @bitCast(@as(c_long, @as(c_int, 0))))) {
        (blk: {
            const tmp = blk_1: {
                const ref = &i;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = '0';
        (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = 0;
        return s;
    }
    if (n < @as(c_long, @bitCast(@as(c_long, @as(c_int, 0))))) {
        (blk: {
            const tmp = blk_1: {
                const ref = &i;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = '-';
        n = -n;
    }
    while (n > @as(c_long, @bitCast(@as(c_long, @as(c_int, 0))))) {
        (blk: {
            const tmp = blk_1: {
                const ref = &i;
                const tmp_2 = ref.*;
                ref.* += 1;
                break :blk_1 tmp_2;
            };
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = @as(u8, @bitCast(@as(i8, @truncate(@as(c_long, @bitCast(@as(c_long, @as(c_int, '0')))) + @import("std").zig.c_translation.signedRemainder(n, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))))))));
        n = @divTrunc(n, @as(c_long, @bitCast(@as(c_long, @as(c_int, 10)))));
    }
    (blk: {
        const tmp = i;
        if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
    }).* = 0;
    if (@as(c_int, @bitCast(@as(c_uint, s[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, '-')) {
        s += 1;
    }
    nk_strrev_ascii(s);
    return s;
}
pub fn nk_string_float_limit(arg_string: [*c]u8, arg_prec: c_int) callconv(.c) c_int {
    var string = arg_string;
    _ = &string;
    var prec = arg_prec;
    _ = &prec;
    var dot: c_int = 0;
    _ = &dot;
    var c: [*c]u8 = string;
    _ = &c;
    while (c.* != 0) {
        if (@as(c_int, @bitCast(@as(c_uint, c.*))) == @as(c_int, '.')) {
            dot = 1;
            c += 1;
            continue;
        }
        if (dot == (prec + @as(c_int, 1))) {
            c.* = 0;
            break;
        }
        if (dot > @as(c_int, 0)) {
            dot += 1;
        }
        c += 1;
    }
    return @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(c) -% @intFromPtr(string))), @sizeOf(u8))))));
}
pub fn nk_dtoa(arg_s: [*c]u8, arg_n: f64) callconv(.c) [*c]u8 {
    var s = arg_s;
    _ = &s;
    var n = arg_n;
    _ = &n;
    var useExp: c_int = 0;
    _ = &useExp;
    var digit: c_int = 0;
    _ = &digit;
    var m: c_int = 0;
    _ = &m;
    var m1: c_int = 0;
    _ = &m1;
    var c: [*c]u8 = s;
    _ = &c;
    var neg: c_int = 0;
    _ = &neg;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (s != null) {} else {
                __assert_fail("s", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 7295))), "char *nk_dtoa(char *, double)");
            };
        };
    };
    if (!(s != null)) return null;
    if (n == 0.0) {
        s[@as(c_uint, @intCast(@as(c_int, 0)))] = '0';
        s[@as(c_uint, @intCast(@as(c_int, 1)))] = '\x00';
        return s;
    }
    neg = @intFromBool(n < @as(f64, @floatFromInt(@as(c_int, 0))));
    if (neg != 0) {
        n = -n;
    }
    m = nk_log10(n);
    useExp = @intFromBool(((m >= @as(c_int, 14)) or ((neg != 0) and (m >= @as(c_int, 9)))) or (m <= -@as(c_int, 9)));
    if (neg != 0) {
        (blk: {
            const ref = &c;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = '-';
    }
    if (useExp != 0) {
        if (m < @as(c_int, 0)) {
            m -= @as(c_int, 1);
        }
        n = n / nk_pow(10.0, m);
        m1 = m;
        m = 0;
    }
    if (@as(f64, @floatFromInt(m)) < 1.0) {
        m = 0;
    }
    while ((n > 0.00000000000001) or (m >= @as(c_int, 0))) {
        var weight: f64 = nk_pow(10.0, m);
        _ = &weight;
        if (weight > @as(f64, @floatFromInt(@as(c_int, 0)))) {
            var t: f64 = n / weight;
            _ = &t;
            digit = nk_ifloord(t);
            n -= @as(f64, @floatFromInt(digit)) * weight;
            (blk: {
                const ref = &c;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, '0') + @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(digit)))))))))));
        }
        if ((m == @as(c_int, 0)) and (n > @as(f64, @floatFromInt(@as(c_int, 0))))) {
            (blk: {
                const ref = &c;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = '.';
        }
        m -= 1;
    }
    if (useExp != 0) {
        var i: c_int = undefined;
        _ = &i;
        var j: c_int = undefined;
        _ = &j;
        (blk: {
            const ref = &c;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).* = 'e';
        if (m1 > @as(c_int, 0)) {
            (blk: {
                const ref = &c;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = '+';
        } else {
            (blk: {
                const ref = &c;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = '-';
            m1 = -m1;
        }
        m = 0;
        while (m1 > @as(c_int, 0)) {
            (blk: {
                const ref = &c;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).* = @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, '0') + @as(c_int, @bitCast(@as(c_uint, @as(u8, @bitCast(@as(i8, @truncate(@import("std").zig.c_translation.signedRemainder(m1, @as(c_int, 10)))))))))))));
            m1 = @divTrunc(m1, @as(c_int, 10));
            m += 1;
        }
        c -= @as(usize, @bitCast(@as(isize, @intCast(m))));
        {
            _ = blk: {
                i = 0;
                break :blk blk_1: {
                    const tmp = m - @as(c_int, 1);
                    j = tmp;
                    break :blk_1 tmp;
                };
            };
            while (i < j) : (_ = blk: {
                i += 1;
                break :blk blk_1: {
                    const ref = &j;
                    const tmp = ref.*;
                    ref.* -= 1;
                    break :blk_1 tmp;
                };
            }) {
                (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk c + @as(usize, @intCast(tmp)) else break :blk c - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, (blk: {
                    const tmp = j;
                    if (tmp >= 0) break :blk c + @as(usize, @intCast(tmp)) else break :blk c - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)))))));
                (blk: {
                    const tmp = j;
                    if (tmp >= 0) break :blk c + @as(usize, @intCast(tmp)) else break :blk c - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk c + @as(usize, @intCast(tmp)) else break :blk c - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)))))));
                (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk c + @as(usize, @intCast(tmp)) else break :blk c - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* ^= @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, (blk: {
                    const tmp = j;
                    if (tmp >= 0) break :blk c + @as(usize, @intCast(tmp)) else break :blk c - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*)))))));
            }
        }
        c += @as(usize, @bitCast(@as(isize, @intCast(m))));
    }
    c.* = '\x00';
    return s;
}
pub fn nk_text_clamp(arg_font: [*c]const struct_nk_user_font, arg_text: [*c]const u8, arg_text_len: c_int, arg_space: f32, arg_glyphs: [*c]c_int, arg_text_width: [*c]f32, arg_sep_list: [*c]nk_rune, arg_sep_count: c_int) callconv(.c) c_int {
    var font = arg_font;
    _ = &font;
    var text = arg_text;
    _ = &text;
    var text_len = arg_text_len;
    _ = &text_len;
    var space = arg_space;
    _ = &space;
    var glyphs = arg_glyphs;
    _ = &glyphs;
    var text_width = arg_text_width;
    _ = &text_width;
    var sep_list = arg_sep_list;
    _ = &sep_list;
    var sep_count = arg_sep_count;
    _ = &sep_count;
    var i: c_int = 0;
    _ = &i;
    var glyph_len: c_int = 0;
    _ = &glyph_len;
    var last_width: f32 = 0;
    _ = &last_width;
    var unicode: nk_rune = 0;
    _ = &unicode;
    var width: f32 = 0;
    _ = &width;
    var len: c_int = 0;
    _ = &len;
    var g: c_int = 0;
    _ = &g;
    var s: f32 = undefined;
    _ = &s;
    var sep_len: c_int = 0;
    _ = &sep_len;
    var sep_g: c_int = 0;
    _ = &sep_g;
    var sep_width: f32 = 0;
    _ = &sep_width;
    sep_count = if (sep_count < @as(c_int, 0)) @as(c_int, 0) else sep_count;
    glyph_len = nk_utf_decode(text, &unicode, text_len);
    while (((glyph_len != 0) and (width < space)) and (len < text_len)) {
        len += glyph_len;
        s = font.*.width.?(font.*.userdata, font.*.height, text, len);
        {
            i = 0;
            while (i < sep_count) : (i += 1) {
                if (unicode != (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk sep_list + @as(usize, @intCast(tmp)) else break :blk sep_list - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).*) continue;
                sep_width = blk: {
                    const tmp = width;
                    last_width = tmp;
                    break :blk tmp;
                };
                sep_g = g + @as(c_int, 1);
                sep_len = len;
                break;
            }
        }
        if (i == sep_count) {
            last_width = blk: {
                const tmp = width;
                sep_width = tmp;
                break :blk tmp;
            };
            sep_g = g + @as(c_int, 1);
        }
        width = s;
        glyph_len = nk_utf_decode(&(blk: {
            const tmp = len;
            if (tmp >= 0) break :blk text + @as(usize, @intCast(tmp)) else break :blk text - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*, &unicode, text_len - len);
        g += 1;
    }
    if (len >= text_len) {
        glyphs.* = g;
        text_width.* = last_width;
        return len;
    } else {
        glyphs.* = sep_g;
        text_width.* = sep_width;
        return if (!(sep_len != 0)) len else sep_len;
    }
    return 0;
}
pub fn nk_text_calculate_text_bounds(arg_font: [*c]const struct_nk_user_font, arg_begin: [*c]const u8, arg_byte_len: c_int, arg_row_height: f32, arg_remaining: [*c][*c]const u8, arg_out_offset: [*c]struct_nk_vec2, arg_glyphs: [*c]c_int, arg_op: c_int) callconv(.c) struct_nk_vec2 {
    var font = arg_font;
    _ = &font;
    var begin = arg_begin;
    _ = &begin;
    var byte_len = arg_byte_len;
    _ = &byte_len;
    var row_height = arg_row_height;
    _ = &row_height;
    var remaining = arg_remaining;
    _ = &remaining;
    var out_offset = arg_out_offset;
    _ = &out_offset;
    var glyphs = arg_glyphs;
    _ = &glyphs;
    var op = arg_op;
    _ = &op;
    var line_height: f32 = row_height;
    _ = &line_height;
    var text_size: struct_nk_vec2 = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    _ = &text_size;
    var line_width: f32 = 0.0;
    _ = &line_width;
    var glyph_width: f32 = undefined;
    _ = &glyph_width;
    var glyph_len: c_int = 0;
    _ = &glyph_len;
    var unicode: nk_rune = 0;
    _ = &unicode;
    var text_len: c_int = 0;
    _ = &text_len;
    if ((!(begin != null) or (byte_len <= @as(c_int, 0))) or !(font != null)) return nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), row_height);
    glyph_len = nk_utf_decode(begin, &unicode, byte_len);
    if (!(glyph_len != 0)) return text_size;
    glyph_width = font.*.width.?(font.*.userdata, font.*.height, begin, glyph_len);
    glyphs.* = 0;
    while ((text_len < byte_len) and (glyph_len != 0)) {
        if (unicode == @as(nk_rune, @bitCast(@as(c_int, '\n')))) {
            text_size.x = if (text_size.x < line_width) line_width else text_size.x;
            text_size.y += line_height;
            line_width = 0;
            glyphs.* += @as(c_int, 1);
            if (op == NK_STOP_ON_NEW_LINE) break;
            text_len += 1;
            glyph_len = nk_utf_decode(begin + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), &unicode, byte_len - text_len);
            continue;
        }
        if (unicode == @as(nk_rune, @bitCast(@as(c_int, '\r')))) {
            text_len += 1;
            glyphs.* += @as(c_int, 1);
            glyph_len = nk_utf_decode(begin + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), &unicode, byte_len - text_len);
            continue;
        }
        glyphs.* = glyphs.* + @as(c_int, 1);
        text_len += glyph_len;
        line_width += glyph_width;
        glyph_len = nk_utf_decode(begin + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), &unicode, byte_len - text_len);
        glyph_width = font.*.width.?(font.*.userdata, font.*.height, begin + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), glyph_len);
        continue;
    }
    if (text_size.x < line_width) {
        text_size.x = line_width;
    }
    if (out_offset != null) {
        out_offset.* = nk_vec2(line_width, text_size.y + line_height);
    }
    if ((line_width > @as(f32, @floatFromInt(@as(c_int, 0)))) or (text_size.y == 0.0)) {
        text_size.y += line_height;
    }
    if (remaining != null) {
        remaining.* = begin + @as(usize, @bitCast(@as(isize, @intCast(text_len))));
    }
    return text_size;
}
pub fn nk_buffer_align(arg_unaligned: ?*anyopaque, arg_align: nk_size, arg_alignment: [*c]nk_size, arg_type: enum_nk_buffer_allocation_type) callconv(.c) ?*anyopaque {
    var unaligned = arg_unaligned;
    _ = &unaligned;
    var @"align" = arg_align;
    _ = &@"align";
    var alignment = arg_alignment;
    _ = &alignment;
    var @"type" = arg_type;
    _ = &@"type";
    var memory: ?*anyopaque = null;
    _ = &memory;
    while (true) {
        switch (@"type") {
            else => {
                if (@"align" != 0) {
                    memory = @as(?*anyopaque, @ptrFromInt(@as(c_long, @bitCast(@as(nk_size, @bitCast(@as(c_long, @intCast(@intFromPtr(@as([*c]nk_byte, @ptrCast(@alignCast(unaligned))) + (@"align" -% @as(nk_size, @bitCast(@as(c_long, @as(c_int, 1)))))))))) & ~(@"align" -% @as(nk_size, @bitCast(@as(c_long, @as(c_int, 1)))))))));
                    alignment.* = @as(nk_size, @bitCast(@divExact(@as(c_long, @bitCast(@intFromPtr(@as([*c]nk_byte, @ptrCast(@alignCast(memory)))) -% @intFromPtr(@as([*c]nk_byte, @ptrCast(@alignCast(unaligned)))))), @sizeOf(nk_byte))));
                } else {
                    memory = unaligned;
                    alignment.* = 0;
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                if (@"align" != 0) {
                    memory = @as(?*anyopaque, @ptrFromInt(@as(c_long, @bitCast(@as(nk_size, @bitCast(@as(c_long, @intCast(@intFromPtr(@as([*c]nk_byte, @ptrCast(@alignCast(unaligned)))))))) & ~(@"align" -% @as(nk_size, @bitCast(@as(c_long, @as(c_int, 1)))))))));
                    alignment.* = @as(nk_size, @bitCast(@divExact(@as(c_long, @bitCast(@intFromPtr(@as([*c]nk_byte, @ptrCast(@alignCast(unaligned)))) -% @intFromPtr(@as([*c]nk_byte, @ptrCast(@alignCast(memory)))))), @sizeOf(nk_byte))));
                } else {
                    memory = unaligned;
                    alignment.* = 0;
                }
                break;
            },
        }
        break;
    }
    return memory;
}
pub fn nk_buffer_alloc(arg_b: [*c]struct_nk_buffer, arg_type: enum_nk_buffer_allocation_type, arg_size: nk_size, arg_align: nk_size) callconv(.c) ?*anyopaque {
    var b = arg_b;
    _ = &b;
    var @"type" = arg_type;
    _ = &@"type";
    var size = arg_size;
    _ = &size;
    var @"align" = arg_align;
    _ = &@"align";
    var full: c_int = undefined;
    _ = &full;
    var alignment: nk_size = undefined;
    _ = &alignment;
    var unaligned: ?*anyopaque = undefined;
    _ = &unaligned;
    var memory: ?*anyopaque = undefined;
    _ = &memory;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8623))), "void *nk_buffer_alloc(struct nk_buffer *, enum nk_buffer_allocation_type, nk_size, nk_size)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (size != 0) {} else {
                __assert_fail("size", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8624))), "void *nk_buffer_alloc(struct nk_buffer *, enum nk_buffer_allocation_type, nk_size, nk_size)");
            };
        };
    };
    if (!(b != null) or !(size != 0)) return null;
    b.*.needed +%= size;
    if (@"type" == @as(c_uint, @bitCast(NK_BUFFER_FRONT))) {
        unaligned = @as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(b.*.memory.ptr))) + b.*.allocated));
    } else {
        unaligned = @as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(b.*.memory.ptr))) + (b.*.size -% size)));
    }
    memory = nk_buffer_align(unaligned, @"align", &alignment, @"type");
    if (@"type" == @as(c_uint, @bitCast(NK_BUFFER_FRONT))) {
        full = @intFromBool(((b.*.allocated +% size) +% alignment) > b.*.size);
    } else {
        full = @intFromBool((b.*.size -% (if (b.*.size < (size +% alignment)) b.*.size else size +% alignment)) <= b.*.allocated);
    }
    if (full != 0) {
        var capacity: nk_size = undefined;
        _ = &capacity;
        if (b.*.type != @as(c_uint, @bitCast(NK_BUFFER_DYNAMIC))) return null;
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if ((b.*.pool.alloc != null) and (b.*.pool.free != null)) {} else {
                    __assert_fail("b->pool.alloc && b->pool.free", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8643))), "void *nk_buffer_alloc(struct nk_buffer *, enum nk_buffer_allocation_type, nk_size, nk_size)");
                };
            };
        };
        if (((b.*.type != @as(c_uint, @bitCast(NK_BUFFER_DYNAMIC))) or !(b.*.pool.alloc != null)) or !(b.*.pool.free != null)) return null;
        capacity = @as(nk_size, @intFromFloat(@as(f32, @floatFromInt(b.*.memory.size)) * b.*.grow_factor));
        capacity = if (capacity < @as(nk_size, @bitCast(@as(c_ulong, nk_round_up_pow2(@as(nk_uint, @bitCast(@as(c_uint, @truncate(b.*.allocated +% size))))))))) @as(nk_size, @bitCast(@as(c_ulong, nk_round_up_pow2(@as(nk_uint, @bitCast(@as(c_uint, @truncate(b.*.allocated +% size)))))))) else capacity;
        b.*.memory.ptr = nk_buffer_realloc(b, capacity, &b.*.memory.size);
        if (!(b.*.memory.ptr != null)) return null;
        if (@"type" == @as(c_uint, @bitCast(NK_BUFFER_FRONT))) {
            unaligned = @as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(b.*.memory.ptr))) + b.*.allocated));
        } else {
            unaligned = @as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(b.*.memory.ptr))) + (b.*.size -% size)));
        }
        memory = nk_buffer_align(unaligned, @"align", &alignment, @"type");
    }
    if (@"type" == @as(c_uint, @bitCast(NK_BUFFER_FRONT))) {
        b.*.allocated +%= size +% alignment;
    } else {
        b.*.size -%= size +% alignment;
    }
    b.*.needed +%= alignment;
    b.*.calls +%= 1;
    return memory;
}
pub fn nk_buffer_realloc(arg_b: [*c]struct_nk_buffer, arg_capacity: nk_size, arg_size: [*c]nk_size) callconv(.c) ?*anyopaque {
    var b = arg_b;
    _ = &b;
    var capacity = arg_capacity;
    _ = &capacity;
    var size = arg_size;
    _ = &size;
    var temp: ?*anyopaque = undefined;
    _ = &temp;
    var buffer_size: nk_size = undefined;
    _ = &buffer_size;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8582))), "void *nk_buffer_realloc(struct nk_buffer *, nk_size, nk_size *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (size != null) {} else {
                __assert_fail("size", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8583))), "void *nk_buffer_realloc(struct nk_buffer *, nk_size, nk_size *)");
            };
        };
    };
    if (((!(b != null) or !(size != null)) or !(b.*.pool.alloc != null)) or !(b.*.pool.free != null)) return null;
    buffer_size = b.*.memory.size;
    temp = b.*.pool.alloc.?(b.*.pool.userdata, b.*.memory.ptr, capacity);
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (temp != null) {} else {
                __assert_fail("temp", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8589))), "void *nk_buffer_realloc(struct nk_buffer *, nk_size, nk_size *)");
            };
        };
    };
    if (!(temp != null)) return null;
    size.* = capacity;
    if (temp != b.*.memory.ptr) {
        _ = nk_memcopy(temp, b.*.memory.ptr, buffer_size);
        b.*.pool.free.?(b.*.pool.userdata, b.*.memory.ptr);
    }
    if (b.*.size == buffer_size) {
        b.*.size = capacity;
        return temp;
    } else {
        var dst: ?*anyopaque = undefined;
        _ = &dst;
        var src: ?*anyopaque = undefined;
        _ = &src;
        var back_size: nk_size = undefined;
        _ = &back_size;
        back_size = buffer_size -% b.*.size;
        dst = @as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(temp))) + (capacity -% back_size)));
        src = @as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(temp))) + b.*.size));
        _ = nk_memcopy(dst, src, back_size);
        b.*.size = capacity -% back_size;
    }
    return temp;
}
pub fn nk_command_buffer_init(arg_cb: [*c]struct_nk_command_buffer, arg_b: [*c]struct_nk_buffer, arg_clip: enum_nk_command_clipping) callconv(.c) void {
    var cb = arg_cb;
    _ = &cb;
    var b = arg_b;
    _ = &b;
    var clip = arg_clip;
    _ = &clip;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (cb != null) {} else {
                __assert_fail("cb", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9220))), "void nk_command_buffer_init(struct nk_command_buffer *, struct nk_buffer *, enum nk_command_clipping)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9221))), "void nk_command_buffer_init(struct nk_command_buffer *, struct nk_buffer *, enum nk_command_clipping)");
            };
        };
    };
    if (!(cb != null) or !(b != null)) return;
    cb.*.base = b;
    cb.*.use_clipping = @as(c_int, @bitCast(clip));
    cb.*.begin = b.*.allocated;
    cb.*.end = b.*.allocated;
    cb.*.last = b.*.allocated;
}
pub fn nk_command_buffer_reset(arg_b: [*c]struct_nk_command_buffer) callconv(.c) void {
    var b = arg_b;
    _ = &b;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (b != null) {} else {
                __assert_fail("b", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 9232))), "void nk_command_buffer_reset(struct nk_command_buffer *)");
            };
        };
    };
    if (!(b != null)) return;
    b.*.begin = 0;
    b.*.end = 0;
    b.*.last = 0;
    b.*.clip = nk_null_rect;
}
// libs/nuklear/nuklear.h:6022:28: warning: failed to translate simple OffsetOfExpr

// libs/nuklear/nuklear.h:9243:1: warning: unable to translate function, demoted to extern
pub extern fn nk_command_buffer_push(arg_b: [*c]struct_nk_command_buffer, arg_t: enum_nk_command_type, arg_size: nk_size) callconv(.c) ?*anyopaque;
pub fn nk_draw_symbol(arg_out: [*c]struct_nk_command_buffer, arg_type: enum_nk_symbol_type, arg_content: struct_nk_rect, arg_background: struct_nk_color, arg_foreground: struct_nk_color, arg_border_width: f32, arg_font: [*c]const struct_nk_user_font) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var @"type" = arg_type;
    _ = &@"type";
    var content = arg_content;
    _ = &content;
    var background = arg_background;
    _ = &background;
    var foreground = arg_foreground;
    _ = &foreground;
    var border_width = arg_border_width;
    _ = &border_width;
    var font = arg_font;
    _ = &font;
    while (true) {
        switch (@"type") {
            @as(c_uint, @bitCast(@as(c_int, 1))), @as(c_uint, @bitCast(@as(c_int, 2))), @as(c_uint, @bitCast(@as(c_int, 11))), @as(c_uint, @bitCast(@as(c_int, 12))) => {
                {
                    var X: [*c]const u8 = if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_X))) "x" else if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_UNDERSCORE))) "_" else if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_PLUS))) "+" else "-";
                    _ = &X;
                    var text: struct_nk_text = undefined;
                    _ = &text;
                    text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
                    text.background = background;
                    text.text = foreground;
                    nk_widget_text(out, content, X, @as(c_int, 1), &text, @as(nk_flags, @bitCast(NK_TEXT_CENTERED)), font);
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 3))), @as(c_uint, @bitCast(@as(c_int, 4))), @as(c_uint, @bitCast(@as(c_int, 5))), @as(c_uint, @bitCast(@as(c_int, 6))) => {
                {
                    if ((@"type" == @as(c_uint, @bitCast(NK_SYMBOL_RECT_SOLID))) or (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_RECT_OUTLINE)))) {
                        nk_fill_rect(out, content, @as(f32, @floatFromInt(@as(c_int, 0))), foreground);
                        if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_RECT_OUTLINE))) {
                            nk_fill_rect(out, nk_shrink_rect(content, border_width), @as(f32, @floatFromInt(@as(c_int, 0))), background);
                        }
                    } else {
                        nk_fill_circle(out, content, foreground);
                        if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_CIRCLE_OUTLINE))) {
                            nk_fill_circle(out, nk_shrink_rect(content, @as(f32, @floatFromInt(@as(c_int, 1)))), background);
                        }
                    }
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 7))), @as(c_uint, @bitCast(@as(c_int, 8))), @as(c_uint, @bitCast(@as(c_int, 9))), @as(c_uint, @bitCast(@as(c_int, 10))) => {
                {
                    var heading: enum_nk_heading = undefined;
                    _ = &heading;
                    var points: [3]struct_nk_vec2 = undefined;
                    _ = &points;
                    heading = @as(c_uint, @bitCast(if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_RIGHT))) NK_RIGHT else if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_LEFT))) NK_LEFT else if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_UP))) NK_UP else NK_DOWN));
                    nk_triangle_from_direction(@as([*c]struct_nk_vec2, @ptrCast(@alignCast(&points))), content, @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), heading);
                    nk_fill_triangle(out, points[@as(c_uint, @intCast(@as(c_int, 0)))].x, points[@as(c_uint, @intCast(@as(c_int, 0)))].y, points[@as(c_uint, @intCast(@as(c_int, 1)))].x, points[@as(c_uint, @intCast(@as(c_int, 1)))].y, points[@as(c_uint, @intCast(@as(c_int, 2)))].x, points[@as(c_uint, @intCast(@as(c_int, 2)))].y, foreground);
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 13))), @as(c_uint, @bitCast(@as(c_int, 14))), @as(c_uint, @bitCast(@as(c_int, 15))), @as(c_uint, @bitCast(@as(c_int, 16))) => {
                {
                    var heading: enum_nk_heading = undefined;
                    _ = &heading;
                    var points: [3]struct_nk_vec2 = undefined;
                    _ = &points;
                    heading = @as(c_uint, @bitCast(if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_RIGHT_OUTLINE))) NK_RIGHT else if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_LEFT_OUTLINE))) NK_LEFT else if (@"type" == @as(c_uint, @bitCast(NK_SYMBOL_TRIANGLE_UP_OUTLINE))) NK_UP else NK_DOWN));
                    nk_triangle_from_direction(@as([*c]struct_nk_vec2, @ptrCast(@alignCast(&points))), content, @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), heading);
                    nk_stroke_triangle(out, points[@as(c_uint, @intCast(@as(c_int, 0)))].x, points[@as(c_uint, @intCast(@as(c_int, 0)))].y, points[@as(c_uint, @intCast(@as(c_int, 1)))].x, points[@as(c_uint, @intCast(@as(c_int, 1)))].y, points[@as(c_uint, @intCast(@as(c_int, 2)))].x, points[@as(c_uint, @intCast(@as(c_int, 2)))].y, border_width, foreground);
                }
                break;
            },
            else => break,
        }
        break;
    }
}
pub fn nk_start_buffer(arg_ctx: [*c]struct_nk_context, arg_buffer: [*c]struct_nk_command_buffer) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var buffer = arg_buffer;
    _ = &buffer;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19508))), "void nk_start_buffer(struct nk_context *, struct nk_command_buffer *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (buffer != null) {} else {
                __assert_fail("buffer", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19509))), "void nk_start_buffer(struct nk_context *, struct nk_command_buffer *)");
            };
        };
    };
    if (!(ctx != null) or !(buffer != null)) return;
    buffer.*.begin = ctx.*.memory.allocated;
    buffer.*.end = buffer.*.begin;
    buffer.*.last = buffer.*.begin;
    buffer.*.clip = nk_null_rect;
}
pub fn nk_start(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19519))), "void nk_start(struct nk_context *, struct nk_window *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (win != null) {} else {
                __assert_fail("win", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19520))), "void nk_start(struct nk_context *, struct nk_window *)");
            };
        };
    };
    nk_start_buffer(ctx, &win.*.buffer);
}
pub fn nk_start_popup(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var buf: [*c]struct_nk_popup_buffer = undefined;
    _ = &buf;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19527))), "void nk_start_popup(struct nk_context *, struct nk_window *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (win != null) {} else {
                __assert_fail("win", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19528))), "void nk_start_popup(struct nk_context *, struct nk_window *)");
            };
        };
    };
    if (!(ctx != null) or !(win != null)) return;
    buf = &win.*.popup.buf;
    buf.*.begin = win.*.buffer.end;
    buf.*.end = win.*.buffer.end;
    buf.*.parent = win.*.buffer.last;
    buf.*.last = buf.*.begin;
    buf.*.active = nk_true;
}
pub fn nk_finish_popup(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var buf: [*c]struct_nk_popup_buffer = undefined;
    _ = &buf;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19543))), "void nk_finish_popup(struct nk_context *, struct nk_window *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (win != null) {} else {
                __assert_fail("win", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19544))), "void nk_finish_popup(struct nk_context *, struct nk_window *)");
            };
        };
    };
    if (!(ctx != null) or !(win != null)) return;
    buf = &win.*.popup.buf;
    buf.*.last = win.*.buffer.last;
    buf.*.end = win.*.buffer.end;
}
pub fn nk_finish_buffer(arg_ctx: [*c]struct_nk_context, arg_buffer: [*c]struct_nk_command_buffer) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var buffer = arg_buffer;
    _ = &buffer;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19554))), "void nk_finish_buffer(struct nk_context *, struct nk_command_buffer *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (buffer != null) {} else {
                __assert_fail("buffer", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19555))), "void nk_finish_buffer(struct nk_context *, struct nk_command_buffer *)");
            };
        };
    };
    if (!(ctx != null) or !(buffer != null)) return;
    buffer.*.end = ctx.*.memory.allocated;
}
pub fn nk_finish(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var buf: [*c]struct_nk_popup_buffer = undefined;
    _ = &buf;
    var parent_last: [*c]struct_nk_command = undefined;
    _ = &parent_last;
    var memory: ?*anyopaque = undefined;
    _ = &memory;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19566))), "void nk_finish(struct nk_context *, struct nk_window *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (win != null) {} else {
                __assert_fail("win", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19567))), "void nk_finish(struct nk_context *, struct nk_window *)");
            };
        };
    };
    if (!(ctx != null) or !(win != null)) return;
    nk_finish_buffer(ctx, &win.*.buffer);
    if (!(win.*.popup.buf.active != 0)) return;
    buf = &win.*.popup.buf;
    memory = ctx.*.memory.memory.ptr;
    parent_last = @as([*c]struct_nk_command, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(memory))) + buf.*.parent)))));
    parent_last.*.next = buf.*.end;
}
// libs/nuklear/nuklear.h:19608:13: warning: TODO implement translation of stmt class GotoStmtClass

// libs/nuklear/nuklear.h:19578:1: warning: unable to translate function, demoted to extern
pub extern fn nk_build(arg_ctx: [*c]struct_nk_context) callconv(.c) void;
pub fn nk_textedit_clear_state(arg_state: [*c]struct_nk_text_edit, arg_type: enum_nk_text_edit_type, arg_filter: nk_plugin_filter) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var @"type" = arg_type;
    _ = &@"type";
    var filter = arg_filter;
    _ = &filter;
    state.*.undo.undo_point = 0;
    state.*.undo.undo_char_point = 0;
    state.*.undo.redo_point = 99;
    state.*.undo.redo_char_point = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, 999)))));
    state.*.select_end = blk: {
        const tmp = @as(c_int, 0);
        state.*.select_start = tmp;
        break :blk tmp;
    };
    state.*.cursor = 0;
    state.*.has_preferred_x = 0;
    state.*.preferred_x = 0;
    state.*.cursor_at_end_of_line = 0;
    state.*.initialized = 1;
    state.*.single_line = @as(u8, @intFromBool(@"type" == @as(c_uint, @bitCast(NK_TEXT_EDIT_SINGLE_LINE))));
    state.*.mode = @as(u8, @bitCast(@as(i8, @truncate(NK_TEXT_EDIT_MODE_VIEW))));
    state.*.filter = filter;
    state.*.scrollbar = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
}
pub fn nk_textedit_click(arg_state: [*c]struct_nk_text_edit, arg_x: f32, arg_y: f32, arg_font: [*c]const struct_nk_user_font, arg_row_height: f32) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var font = arg_font;
    _ = &font;
    var row_height = arg_row_height;
    _ = &row_height;
    state.*.cursor = nk_textedit_locate_coord(state, x, y, font, row_height);
    state.*.select_start = state.*.cursor;
    state.*.select_end = state.*.cursor;
    state.*.has_preferred_x = 0;
}
pub fn nk_textedit_drag(arg_state: [*c]struct_nk_text_edit, arg_x: f32, arg_y: f32, arg_font: [*c]const struct_nk_user_font, arg_row_height: f32) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var font = arg_font;
    _ = &font;
    var row_height = arg_row_height;
    _ = &row_height;
    var p: c_int = nk_textedit_locate_coord(state, x, y, font, row_height);
    _ = &p;
    if (state.*.select_start == state.*.select_end) {
        state.*.select_start = state.*.cursor;
    }
    state.*.cursor = blk: {
        const tmp = p;
        state.*.select_end = tmp;
        break :blk tmp;
    };
}
// libs/nuklear/nuklear.h:27198:1: warning: TODO implement translation of stmt class LabelStmtClass

// libs/nuklear/nuklear.h:27195:1: warning: unable to translate function, demoted to extern
pub extern fn nk_textedit_key(arg_state: [*c]struct_nk_text_edit, arg_key: enum_nk_keys, arg_shift_mod: c_int, arg_font: [*c]const struct_nk_user_font, arg_row_height: f32) callconv(.c) void;
pub const NK_INSERT_BACK: c_int = 0;
pub const NK_INSERT_FRONT: c_int = 1;
pub const enum_nk_window_insert_location = c_uint;
pub fn nk_create_window(arg_ctx: [*c]struct_nk_context) callconv(.c) ?*anyopaque {
    var ctx = arg_ctx;
    _ = &ctx;
    var elem: [*c]struct_nk_page_element = undefined;
    _ = &elem;
    elem = nk_create_page_element(ctx);
    if (!(elem != null)) return null;
    elem.*.data.win.seq = ctx.*.seq;
    return @as(?*anyopaque, @ptrCast(&elem.*.data.win));
}
pub fn nk_remove_window(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    if ((win == ctx.*.begin) or (win == ctx.*.end)) {
        if (win == ctx.*.begin) {
            ctx.*.begin = win.*.next;
            if (win.*.next != null) {
                win.*.next.*.prev = null;
            }
        }
        if (win == ctx.*.end) {
            ctx.*.end = win.*.prev;
            if (win.*.prev != null) {
                win.*.prev.*.next = null;
            }
        }
    } else {
        if (win.*.next != null) {
            win.*.next.*.prev = win.*.prev;
        }
        if (win.*.prev != null) {
            win.*.prev.*.next = win.*.next;
        }
    }
    if ((win == ctx.*.active) or !(ctx.*.active != null)) {
        ctx.*.active = ctx.*.end;
        if (ctx.*.end != null) {
            ctx.*.end.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_ROM));
        }
    }
    win.*.next = null;
    win.*.prev = null;
    ctx.*.count -%= 1;
}
pub fn nk_free_window(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var it: [*c]struct_nk_table = win.*.tables;
    _ = &it;
    if (win.*.popup.win != null) {
        nk_free_window(ctx, win.*.popup.win);
        win.*.popup.win = null;
    }
    win.*.next = null;
    win.*.prev = null;
    while (it != null) {
        var n: [*c]struct_nk_table = it.*.next;
        _ = &n;
        nk_remove_table(win, it);
        nk_free_table(ctx, it);
        if (it == win.*.tables) {
            win.*.tables = n;
        }
        it = n;
    }
    {
        var pd: [*c]union_nk_page_data = @as([*c]union_nk_page_data, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(if (true) win else &@as([*c]union_nk_page_data, @ptrFromInt(@as(c_int, 0))).*.win))) - @offsetOf(union_nk_page_data, "win"))))));
        _ = &pd;
        var pe: [*c]struct_nk_page_element = @as([*c]struct_nk_page_element, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(if (true) pd else &@as([*c]struct_nk_page_element, @ptrFromInt(@as(c_int, 0))).*.data))) - @offsetOf(struct_nk_page_element, "data"))))));
        _ = &pe;
        nk_free_page_element(ctx, pe);
    }
}
pub fn nk_find_window(arg_ctx: [*c]const struct_nk_context, arg_hash: nk_hash, arg_name: [*c]const u8) callconv(.c) [*c]struct_nk_window {
    var ctx = arg_ctx;
    _ = &ctx;
    var hash = arg_hash;
    _ = &hash;
    var name = arg_name;
    _ = &name;
    var iter: [*c]struct_nk_window = undefined;
    _ = &iter;
    iter = ctx.*.begin;
    while (iter != null) {
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (iter != iter.*.next) {} else {
                    __assert_fail("iter != iter->next", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20568))), "struct nk_window *nk_find_window(const struct nk_context *, nk_hash, const char *)");
                };
            };
        };
        if (iter.*.name == hash) {
            var max_len: c_int = nk_strlen(@as([*c]u8, @ptrCast(@alignCast(&iter.*.name_string))));
            _ = &max_len;
            if (!(nk_stricmpn(@as([*c]u8, @ptrCast(@alignCast(&iter.*.name_string))), name, max_len) != 0)) return iter;
        }
        iter = iter.*.next;
    }
    return null;
}
pub fn nk_insert_window(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window, arg_loc: enum_nk_window_insert_location) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var loc = arg_loc;
    _ = &loc;
    var iter: [*c]const struct_nk_window = undefined;
    _ = &iter;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20583))), "void nk_insert_window(struct nk_context *, struct nk_window *, enum nk_window_insert_location)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (win != null) {} else {
                __assert_fail("win", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20584))), "void nk_insert_window(struct nk_context *, struct nk_window *, enum nk_window_insert_location)");
            };
        };
    };
    if (!(win != null) or !(ctx != null)) return;
    iter = ctx.*.begin;
    while (iter != null) {
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (iter != @as([*c]const struct_nk_window, @ptrCast(@alignCast(iter.*.next)))) {} else {
                    __assert_fail("iter != iter->next", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20589))), "void nk_insert_window(struct nk_context *, struct nk_window *, enum nk_window_insert_location)");
                };
            };
        };
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (iter != @as([*c]const struct_nk_window, @ptrCast(@alignCast(win)))) {} else {
                    __assert_fail("iter != win", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20590))), "void nk_insert_window(struct nk_context *, struct nk_window *, enum nk_window_insert_location)");
                };
            };
        };
        if (iter == @as([*c]const struct_nk_window, @ptrCast(@alignCast(win)))) return;
        iter = iter.*.next;
    }
    if (!(ctx.*.begin != null)) {
        win.*.next = null;
        win.*.prev = null;
        ctx.*.begin = win;
        ctx.*.end = win;
        ctx.*.count = 1;
        return;
    }
    if (loc == @as(c_uint, @bitCast(NK_INSERT_BACK))) {
        var end: [*c]struct_nk_window = undefined;
        _ = &end;
        end = ctx.*.end;
        end.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_ROM));
        end.*.next = win;
        win.*.prev = ctx.*.end;
        win.*.next = null;
        ctx.*.end = win;
        ctx.*.active = ctx.*.end;
        ctx.*.end.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_ROM));
    } else {
        ctx.*.begin.*.prev = win;
        win.*.next = ctx.*.begin;
        win.*.prev = null;
        ctx.*.begin = win;
        ctx.*.begin.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_ROM));
    }
    ctx.*.count +%= 1;
}
pub fn nk_pool_init(arg_pool: [*c]struct_nk_pool, arg_alloc: [*c]const struct_nk_allocator, arg_capacity: c_uint) callconv(.c) void {
    var pool = arg_pool;
    _ = &pool;
    var alloc = arg_alloc;
    _ = &alloc;
    var capacity = arg_capacity;
    _ = &capacity;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (capacity >= @as(c_uint, @bitCast(@as(c_int, 1)))) {} else {
                __assert_fail("capacity >= 1", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19688))), "void nk_pool_init(struct nk_pool *, const struct nk_allocator *, unsigned int)");
            };
        };
    };
    nk_zero(@as(?*anyopaque, @ptrCast(pool)), @sizeOf(struct_nk_pool));
    pool.*.alloc = alloc.*;
    pool.*.capacity = capacity;
    pool.*.type = @as(c_uint, @bitCast(NK_BUFFER_DYNAMIC));
    pool.*.pages = null;
}
pub fn nk_pool_free(arg_pool: [*c]struct_nk_pool) callconv(.c) void {
    var pool = arg_pool;
    _ = &pool;
    var iter: [*c]struct_nk_page = undefined;
    _ = &iter;
    if (!(pool != null)) return;
    iter = pool.*.pages;
    if (pool.*.type == @as(c_uint, @bitCast(NK_BUFFER_FIXED))) return;
    while (iter != null) {
        var next: [*c]struct_nk_page = iter.*.next;
        _ = &next;
        pool.*.alloc.free.?(pool.*.alloc.userdata, @as(?*anyopaque, @ptrCast(iter)));
        iter = next;
    }
}
pub fn nk_pool_init_fixed(arg_pool: [*c]struct_nk_pool, arg_memory: ?*anyopaque, arg_size: nk_size) callconv(.c) void {
    var pool = arg_pool;
    _ = &pool;
    var memory = arg_memory;
    _ = &memory;
    var size = arg_size;
    _ = &size;
    nk_zero(@as(?*anyopaque, @ptrCast(pool)), @sizeOf(struct_nk_pool));
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (size >= @sizeOf(struct_nk_page)) {} else {
                __assert_fail("size >= sizeof(struct nk_page)", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19712))), "void nk_pool_init_fixed(struct nk_pool *, void *, nk_size)");
            };
        };
    };
    if (size < @sizeOf(struct_nk_page)) return;
    pool.*.capacity = @as(c_uint, @bitCast(@as(c_uint, @truncate(@as(c_ulong, @bitCast(@as(c_long, @as(c_int, 1)))) +% ((size -% @sizeOf(struct_nk_page)) / @sizeOf(struct_nk_page_element))))));
    pool.*.pages = @as([*c]struct_nk_page, @ptrCast(@alignCast(memory)));
    pool.*.type = @as(c_uint, @bitCast(NK_BUFFER_FIXED));
    pool.*.size = size;
}
pub fn nk_pool_alloc(arg_pool: [*c]struct_nk_pool) callconv(.c) [*c]struct_nk_page_element {
    var pool = arg_pool;
    _ = &pool;
    if (!(pool.*.pages != null) or (pool.*.pages.*.size >= pool.*.capacity)) {
        var page: [*c]struct_nk_page = undefined;
        _ = &page;
        if (pool.*.type == @as(c_uint, @bitCast(NK_BUFFER_FIXED))) {
            _ = blk: {
                _ = @sizeOf(c_int);
                break :blk blk_1: {
                    break :blk_1 if (pool.*.pages != null) {} else {
                        __assert_fail("pool->pages", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19727))), "struct nk_page_element *nk_pool_alloc(struct nk_pool *)");
                    };
                };
            };
            if (!(pool.*.pages != null)) return null;
            _ = blk: {
                _ = @sizeOf(c_int);
                break :blk blk_1: {
                    break :blk_1 if (pool.*.pages.*.size < pool.*.capacity) {} else {
                        __assert_fail("pool->pages->size < pool->capacity", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19729))), "struct nk_page_element *nk_pool_alloc(struct nk_pool *)");
                    };
                };
            };
            return null;
        } else {
            var size: nk_size = @sizeOf(struct_nk_page);
            _ = &size;
            size +%= @as(nk_size, @bitCast(@as(c_ulong, @bitCast(@as(c_ulong, pool.*.capacity -% @as(c_uint, @bitCast(@as(c_int, 1)))))) *% @sizeOf(struct_nk_page_element)));
            page = @as([*c]struct_nk_page, @ptrCast(@alignCast(pool.*.alloc.alloc.?(pool.*.alloc.userdata, null, size))));
            page.*.next = pool.*.pages;
            pool.*.pages = page;
            page.*.size = 0;
        }
    }
    return &pool.*.pages.*.win[blk: {
        const ref = &pool.*.pages.*.size;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }];
}
// libs/nuklear/nuklear.h:6022:28: warning: failed to translate simple OffsetOfExpr

// libs/nuklear/nuklear.h:19752:1: warning: unable to translate function, demoted to extern
pub extern fn nk_create_page_element(arg_ctx: [*c]struct_nk_context) callconv(.c) [*c]struct_nk_page_element;
pub fn nk_link_page_element_into_freelist(arg_ctx: [*c]struct_nk_context, arg_elem: [*c]struct_nk_page_element) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var elem = arg_elem;
    _ = &elem;
    if (!(ctx.*.freelist != null)) {
        ctx.*.freelist = elem;
    } else {
        elem.*.next = ctx.*.freelist;
        ctx.*.freelist = elem;
    }
}
pub fn nk_free_page_element(arg_ctx: [*c]struct_nk_context, arg_elem: [*c]struct_nk_page_element) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var elem = arg_elem;
    _ = &elem;
    if (ctx.*.use_pool != 0) {
        nk_link_page_element_into_freelist(ctx, elem);
        return;
    }
    {
        var elem_end: ?*anyopaque = @as(?*anyopaque, @ptrCast(elem + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1)))))));
        _ = &elem_end;
        var buffer_end: ?*anyopaque = @as(?*anyopaque, @ptrCast(@as([*c]nk_byte, @ptrCast(@alignCast(ctx.*.memory.memory.ptr))) + ctx.*.memory.size));
        _ = &buffer_end;
        if (elem_end == buffer_end) {
            ctx.*.memory.size -%= @as(nk_size, @bitCast(@sizeOf(struct_nk_page_element)));
        } else {
            nk_link_page_element_into_freelist(ctx, elem);
        }
    }
}
pub fn nk_create_table(arg_ctx: [*c]struct_nk_context) callconv(.c) [*c]struct_nk_table {
    var ctx = arg_ctx;
    _ = &ctx;
    var elem: [*c]struct_nk_page_element = undefined;
    _ = &elem;
    elem = nk_create_page_element(ctx);
    if (!(elem != null)) return null;
    nk_zero(@as(?*anyopaque, @ptrCast(&elem.*)), @sizeOf(struct_nk_page_element));
    return &elem.*.data.tbl;
}
pub fn nk_remove_table(arg_win: [*c]struct_nk_window, arg_tbl: [*c]struct_nk_table) callconv(.c) void {
    var win = arg_win;
    _ = &win;
    var tbl = arg_tbl;
    _ = &tbl;
    if (win.*.tables == tbl) {
        win.*.tables = tbl.*.next;
    }
    if (tbl.*.next != null) {
        tbl.*.next.*.prev = tbl.*.prev;
    }
    if (tbl.*.prev != null) {
        tbl.*.prev.*.next = tbl.*.next;
    }
    tbl.*.next = null;
    tbl.*.prev = null;
}
pub fn nk_free_table(arg_ctx: [*c]struct_nk_context, arg_tbl: [*c]struct_nk_table) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var tbl = arg_tbl;
    _ = &tbl;
    var pd: [*c]union_nk_page_data = @as([*c]union_nk_page_data, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(if (true) tbl else &@as([*c]union_nk_page_data, @ptrFromInt(@as(c_int, 0))).*.tbl))) - @offsetOf(union_nk_page_data, "tbl"))))));
    _ = &pd;
    var pe: [*c]struct_nk_page_element = @as([*c]struct_nk_page_element, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(if (true) pd else &@as([*c]struct_nk_page_element, @ptrFromInt(@as(c_int, 0))).*.data))) - @offsetOf(struct_nk_page_element, "data"))))));
    _ = &pe;
    nk_free_page_element(ctx, pe);
}
pub fn nk_push_table(arg_win: [*c]struct_nk_window, arg_tbl: [*c]struct_nk_table) callconv(.c) void {
    var win = arg_win;
    _ = &win;
    var tbl = arg_tbl;
    _ = &tbl;
    if (!(win.*.tables != null)) {
        win.*.tables = tbl;
        tbl.*.next = null;
        tbl.*.prev = null;
        tbl.*.size = 0;
        win.*.table_count = 1;
        return;
    }
    win.*.tables.*.prev = tbl;
    tbl.*.next = win.*.tables;
    tbl.*.prev = null;
    tbl.*.size = 0;
    win.*.tables = tbl;
    win.*.table_count +%= 1;
}
pub fn nk_add_value(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window, arg_name: nk_hash, arg_value: nk_uint) callconv(.c) [*c]nk_uint {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var name = arg_name;
    _ = &name;
    var value = arg_value;
    _ = &value;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19864))), "nk_uint *nk_add_value(struct nk_context *, struct nk_window *, nk_hash, nk_uint)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (win != null) {} else {
                __assert_fail("win", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19865))), "nk_uint *nk_add_value(struct nk_context *, struct nk_window *, nk_hash, nk_uint)");
            };
        };
    };
    if (!(win != null) or !(ctx != null)) return null;
    if (!(win.*.tables != null) or (@as(c_ulong, @bitCast(@as(c_ulong, win.*.tables.*.size))) >= (((if (@sizeOf(struct_nk_window) < @sizeOf(struct_nk_panel)) @sizeOf(struct_nk_panel) else @sizeOf(struct_nk_window)) / @sizeOf(nk_uint)) / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))))) {
        var tbl: [*c]struct_nk_table = nk_create_table(ctx);
        _ = &tbl;
        _ = blk: {
            _ = @sizeOf(c_int);
            break :blk blk_1: {
                break :blk_1 if (tbl != null) {} else {
                    __assert_fail("tbl", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19869))), "nk_uint *nk_add_value(struct nk_context *, struct nk_window *, nk_hash, nk_uint)");
                };
            };
        };
        if (!(tbl != null)) return null;
        nk_push_table(win, tbl);
    }
    win.*.tables.*.seq = win.*.seq;
    win.*.tables.*.keys[win.*.tables.*.size] = name;
    win.*.tables.*.values[win.*.tables.*.size] = value;
    return &win.*.tables.*.values[blk: {
        const ref = &win.*.tables.*.size;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    }];
}
pub fn nk_find_value(arg_win: [*c]const struct_nk_window, arg_name: nk_hash) callconv(.c) [*c]nk_uint {
    var win = arg_win;
    _ = &win;
    var name = arg_name;
    _ = &name;
    var iter: [*c]struct_nk_table = win.*.tables;
    _ = &iter;
    while (iter != null) {
        var i: c_uint = 0;
        _ = &i;
        var size: c_uint = iter.*.size;
        _ = &size;
        {
            i = 0;
            while (i < size) : (i +%= 1) {
                if (iter.*.keys[i] == name) {
                    iter.*.seq = win.*.seq;
                    return &iter.*.values[i];
                }
            }
        }
        size = @as(c_uint, @bitCast(@as(c_uint, @truncate(((if (@sizeOf(struct_nk_window) < @sizeOf(struct_nk_panel)) @sizeOf(struct_nk_panel) else @sizeOf(struct_nk_window)) / @sizeOf(nk_uint)) / @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 2))))))));
        iter = iter.*.next;
    }
    return null;
}
pub fn nk_create_panel(arg_ctx: [*c]struct_nk_context) callconv(.c) ?*anyopaque {
    var ctx = arg_ctx;
    _ = &ctx;
    var elem: [*c]struct_nk_page_element = undefined;
    _ = &elem;
    elem = nk_create_page_element(ctx);
    if (!(elem != null)) return null;
    nk_zero(@as(?*anyopaque, @ptrCast(&elem.*)), @sizeOf(struct_nk_page_element));
    return @as(?*anyopaque, @ptrCast(&elem.*.data.pan));
}
pub fn nk_free_panel(arg_ctx: [*c]struct_nk_context, arg_pan: [*c]struct_nk_panel) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var pan = arg_pan;
    _ = &pan;
    var pd: [*c]union_nk_page_data = @as([*c]union_nk_page_data, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(if (true) pan else &@as([*c]union_nk_page_data, @ptrFromInt(@as(c_int, 0))).*.pan))) - @offsetOf(union_nk_page_data, "pan"))))));
    _ = &pd;
    var pe: [*c]struct_nk_page_element = @as([*c]struct_nk_page_element, @ptrCast(@alignCast(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(if (true) pd else &@as([*c]struct_nk_page_element, @ptrFromInt(@as(c_int, 0))).*.data))) - @offsetOf(struct_nk_page_element, "data"))))));
    _ = &pe;
    nk_free_page_element(ctx, pe);
}
pub fn nk_panel_has_header(arg_flags: nk_flags, arg_title: [*c]const u8) callconv(.c) nk_bool {
    var flags = arg_flags;
    _ = &flags;
    var title = arg_title;
    _ = &title;
    var active: nk_bool = 0;
    _ = &active;
    active = @as(nk_bool, @bitCast(flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSABLE | NK_WINDOW_MINIMIZABLE))));
    active = @intFromBool((active != 0) or ((flags & @as(nk_flags, @bitCast(NK_WINDOW_TITLE))) != 0));
    active = @intFromBool(((active != 0) and !((flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) and (title != null));
    return active;
}
pub fn nk_panel_get_padding(arg_style: [*c]const struct_nk_style, arg_type: enum_nk_panel_type) callconv(.c) struct_nk_vec2 {
    var style = arg_style;
    _ = &style;
    var @"type" = arg_type;
    _ = &@"type";
    while (true) {
        switch (@"type") {
            else => return style.*.window.padding,
            @as(c_uint, @bitCast(@as(c_int, 2))) => return style.*.window.group_padding,
            @as(c_uint, @bitCast(@as(c_int, 4))) => return style.*.window.popup_padding,
            @as(c_uint, @bitCast(@as(c_int, 16))) => return style.*.window.contextual_padding,
            @as(c_uint, @bitCast(@as(c_int, 32))) => return style.*.window.combo_padding,
            @as(c_uint, @bitCast(@as(c_int, 64))) => return style.*.window.menu_padding,
            @as(c_uint, @bitCast(@as(c_int, 128))) => return style.*.window.menu_padding,
        }
        break;
    }
    return @import("std").mem.zeroes(struct_nk_vec2);
}
pub fn nk_panel_get_border(arg_style: [*c]const struct_nk_style, arg_flags: nk_flags, arg_type: enum_nk_panel_type) callconv(.c) f32 {
    var style = arg_style;
    _ = &style;
    var flags = arg_flags;
    _ = &flags;
    var @"type" = arg_type;
    _ = &@"type";
    if ((flags & @as(nk_flags, @bitCast(NK_WINDOW_BORDER))) != 0) {
        while (true) {
            switch (@"type") {
                else => return style.*.window.border,
                @as(c_uint, @bitCast(@as(c_int, 2))) => return style.*.window.group_border,
                @as(c_uint, @bitCast(@as(c_int, 4))) => return style.*.window.popup_border,
                @as(c_uint, @bitCast(@as(c_int, 16))) => return style.*.window.contextual_border,
                @as(c_uint, @bitCast(@as(c_int, 32))) => return style.*.window.combo_border,
                @as(c_uint, @bitCast(@as(c_int, 64))) => return style.*.window.menu_border,
                @as(c_uint, @bitCast(@as(c_int, 128))) => return style.*.window.menu_border,
            }
            break;
        }
    } else return 0;
    return 0;
}
pub fn nk_panel_get_border_color(arg_style: [*c]const struct_nk_style, arg_type: enum_nk_panel_type) callconv(.c) struct_nk_color {
    var style = arg_style;
    _ = &style;
    var @"type" = arg_type;
    _ = &@"type";
    while (true) {
        switch (@"type") {
            else => return style.*.window.border_color,
            @as(c_uint, @bitCast(@as(c_int, 2))) => return style.*.window.group_border_color,
            @as(c_uint, @bitCast(@as(c_int, 4))) => return style.*.window.popup_border_color,
            @as(c_uint, @bitCast(@as(c_int, 16))) => return style.*.window.contextual_border_color,
            @as(c_uint, @bitCast(@as(c_int, 32))) => return style.*.window.combo_border_color,
            @as(c_uint, @bitCast(@as(c_int, 64))) => return style.*.window.menu_border_color,
            @as(c_uint, @bitCast(@as(c_int, 128))) => return style.*.window.menu_border_color,
        }
        break;
    }
    return @import("std").mem.zeroes(struct_nk_color);
}
pub fn nk_panel_is_sub(arg_type: enum_nk_panel_type) callconv(.c) nk_bool {
    var @"type" = arg_type;
    _ = &@"type";
    return if ((@as(c_int, @bitCast(@"type")) & NK_PANEL_SET_SUB) != 0) @as(c_int, 1) else @as(c_int, 0);
}
pub fn nk_panel_is_nonblock(arg_type: enum_nk_panel_type) callconv(.c) nk_bool {
    var @"type" = arg_type;
    _ = &@"type";
    return if ((@as(c_int, @bitCast(@"type")) & NK_PANEL_SET_NONBLOCK) != 0) @as(c_int, 1) else @as(c_int, 0);
}
pub fn nk_panel_begin(arg_ctx: [*c]struct_nk_context, arg_title: [*c]const u8, arg_panel_type: enum_nk_panel_type) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var title = arg_title;
    _ = &title;
    var panel_type = arg_panel_type;
    _ = &panel_type;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var out: [*c]struct_nk_command_buffer = undefined;
    _ = &out;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var font: [*c]const struct_nk_user_font = undefined;
    _ = &font;
    var scrollbar_size: struct_nk_vec2 = undefined;
    _ = &scrollbar_size;
    var panel_padding: struct_nk_vec2 = undefined;
    _ = &panel_padding;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19994))), "nk_bool nk_panel_begin(struct nk_context *, const char *, enum nk_panel_type)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19995))), "nk_bool nk_panel_begin(struct nk_context *, const char *, enum nk_panel_type)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19996))), "nk_bool nk_panel_begin(struct nk_context *, const char *, enum nk_panel_type)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    nk_zero(@as(?*anyopaque, @ptrCast(ctx.*.current.*.layout)), @sizeOf(struct_nk_panel));
    if (((ctx.*.current.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) or ((ctx.*.current.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSED))) != 0)) {
        nk_zero(@as(?*anyopaque, @ptrCast(ctx.*.current.*.layout)), @sizeOf(struct_nk_panel));
        ctx.*.current.*.layout.*.type = panel_type;
        return 0;
    }
    style = &ctx.*.style;
    font = style.*.font;
    win = ctx.*.current;
    layout = win.*.layout;
    out = &win.*.buffer;
    in = if ((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_NO_INPUT))) != 0) null else &ctx.*.input;
    scrollbar_size = style.*.window.scrollbar_size;
    panel_padding = nk_panel_get_padding(style, panel_type);
    if (((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MOVABLE))) != 0) and !((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) {
        var left_mouse_down: nk_bool = undefined;
        _ = &left_mouse_down;
        var left_mouse_clicked: c_uint = undefined;
        _ = &left_mouse_clicked;
        var left_mouse_click_in_cursor: c_int = undefined;
        _ = &left_mouse_click_in_cursor;
        var header: struct_nk_rect = undefined;
        _ = &header;
        header.x = win.*.bounds.x;
        header.y = win.*.bounds.y;
        header.w = win.*.bounds.w;
        if (nk_panel_has_header(win.*.flags, title) != 0) {
            header.h = font.*.height + (2.0 * style.*.window.header.padding.y);
            header.h += 2.0 * style.*.window.header.label_padding.y;
        } else {
            header.h = panel_padding.y;
        }
        left_mouse_down = in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down;
        left_mouse_clicked = in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked;
        left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), header, nk_true);
        if (((left_mouse_down != 0) and (left_mouse_click_in_cursor != 0)) and !(left_mouse_clicked != 0)) {
            win.*.bounds.x = win.*.bounds.x + in.*.mouse.delta.x;
            win.*.bounds.y = win.*.bounds.y + in.*.mouse.delta.y;
            in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked_pos.x += in.*.mouse.delta.x;
            in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked_pos.y += in.*.mouse.delta.y;
            ctx.*.style.cursor_active = ctx.*.style.cursors[@as(c_uint, @intCast(NK_CURSOR_MOVE))];
        }
    }
    layout.*.type = panel_type;
    layout.*.flags = win.*.flags;
    layout.*.bounds = win.*.bounds;
    layout.*.bounds.x += panel_padding.x;
    layout.*.bounds.w -= @as(f32, @floatFromInt(@as(c_int, 2))) * panel_padding.x;
    if ((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_BORDER))) != 0) {
        layout.*.border = nk_panel_get_border(style, win.*.flags, panel_type);
        layout.*.bounds = nk_shrink_rect(layout.*.bounds, layout.*.border);
    } else {
        layout.*.border = 0;
    }
    layout.*.at_y = layout.*.bounds.y;
    layout.*.at_x = layout.*.bounds.x;
    layout.*.max_x = 0;
    layout.*.header_height = 0;
    layout.*.footer_height = 0;
    nk_layout_reset_min_row_height(ctx);
    layout.*.row.index = 0;
    layout.*.row.columns = 0;
    layout.*.row.ratio = null;
    layout.*.row.item_width = 0;
    layout.*.row.tree_depth = 0;
    layout.*.row.height = panel_padding.y;
    layout.*.has_scrolling = @as(c_uint, @bitCast(nk_true));
    if (!((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_NO_SCROLLBAR))) != 0)) {
        layout.*.bounds.w -= scrollbar_size.x;
    }
    if (!(nk_panel_is_nonblock(panel_type) != 0)) {
        layout.*.footer_height = 0;
        if (!((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_NO_SCROLLBAR))) != 0) or ((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_SCALABLE))) != 0)) {
            layout.*.footer_height = scrollbar_size.y;
        }
        layout.*.bounds.h -= layout.*.footer_height;
    }
    if (nk_panel_has_header(win.*.flags, title) != 0) {
        var text: struct_nk_text = undefined;
        _ = &text;
        var header: struct_nk_rect = undefined;
        _ = &header;
        var background: [*c]const struct_nk_style_item = null;
        _ = &background;
        header.x = win.*.bounds.x;
        header.y = win.*.bounds.y;
        header.w = win.*.bounds.w;
        header.h = font.*.height + (2.0 * style.*.window.header.padding.y);
        header.h += 2.0 * style.*.window.header.label_padding.y;
        layout.*.header_height = header.h;
        layout.*.bounds.y += header.h;
        layout.*.bounds.h -= header.h;
        layout.*.at_y += header.h;
        if (ctx.*.active == win) {
            background = &style.*.window.header.active;
            text.text = style.*.window.header.label_active;
        } else if (nk_input_is_mouse_hovering_rect(&ctx.*.input, header) != 0) {
            background = &style.*.window.header.hover;
            text.text = style.*.window.header.label_hover;
        } else {
            background = &style.*.window.header.normal;
            text.text = style.*.window.header.label_normal;
        }
        header.h += 1.0;
        while (true) {
            switch (background.*.type) {
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                    nk_draw_image(&win.*.buffer, header, &background.*.data.image, nk_white);
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                    nk_draw_nine_slice(&win.*.buffer, header, &background.*.data.slice, nk_white);
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 0))) => {
                    text.background = background.*.data.color;
                    nk_fill_rect(out, header, @as(f32, @floatFromInt(@as(c_int, 0))), background.*.data.color);
                    break;
                },
                else => {},
            }
            break;
        }
        {
            var button: struct_nk_rect = undefined;
            _ = &button;
            button.y = header.y + style.*.window.header.padding.y;
            button.h = header.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.window.header.padding.y);
            button.w = button.h;
            if ((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSABLE))) != 0) {
                var ws: nk_flags = 0;
                _ = &ws;
                if (style.*.window.header.@"align" == @as(c_uint, @bitCast(NK_HEADER_RIGHT))) {
                    button.x = (header.w + header.x) - (button.w + style.*.window.header.padding.x);
                    header.w -= (button.w + style.*.window.header.spacing.x) + style.*.window.header.padding.x;
                } else {
                    button.x = header.x + style.*.window.header.padding.x;
                    header.x += (button.w + style.*.window.header.spacing.x) + style.*.window.header.padding.x;
                }
                if ((nk_do_button_symbol(&ws, &win.*.buffer, button, style.*.window.header.close_symbol, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &style.*.window.header.close_button, in, style.*.font) != 0) and !((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) {
                    layout.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN));
                    layout.*.flags &= @as(nk_flags, @bitCast(~NK_WINDOW_MINIMIZED));
                }
            }
            if ((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZABLE))) != 0) {
                var ws: nk_flags = 0;
                _ = &ws;
                if (style.*.window.header.@"align" == @as(c_uint, @bitCast(NK_HEADER_RIGHT))) {
                    button.x = (header.w + header.x) - button.w;
                    if (!((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSABLE))) != 0)) {
                        button.x -= style.*.window.header.padding.x;
                        header.w -= style.*.window.header.padding.x;
                    }
                    header.w -= button.w + style.*.window.header.spacing.x;
                } else {
                    button.x = header.x;
                    header.x += (button.w + style.*.window.header.spacing.x) + style.*.window.header.padding.x;
                }
                if ((nk_do_button_symbol(&ws, &win.*.buffer, button, if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0) style.*.window.header.maximize_symbol else style.*.window.header.minimize_symbol, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &style.*.window.header.minimize_button, in, style.*.font) != 0) and !((win.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) {
                    layout.*.flags = if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0) layout.*.flags & @as(nk_flags, @bitCast(~NK_WINDOW_MINIMIZED)) else layout.*.flags | @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED));
                }
            }
        }
        {
            var text_len: c_int = nk_strlen(title);
            _ = &text_len;
            var label: struct_nk_rect = struct_nk_rect{
                .x = @as(f32, @floatFromInt(@as(c_int, 0))),
                .y = @as(f32, @floatFromInt(@as(c_int, 0))),
                .w = @as(f32, @floatFromInt(@as(c_int, 0))),
                .h = @as(f32, @floatFromInt(@as(c_int, 0))),
            };
            _ = &label;
            var t: f32 = font.*.width.?(font.*.userdata, font.*.height, title, text_len);
            _ = &t;
            text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
            label.x = header.x + style.*.window.header.padding.x;
            label.x += style.*.window.header.label_padding.x;
            label.y = header.y + style.*.window.header.label_padding.y;
            label.h = font.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.window.header.label_padding.y);
            label.w = t + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.window.header.spacing.x);
            label.w = if ((if (label.w < ((header.x + header.w) - label.x)) label.w else (header.x + header.w) - label.x) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else if (label.w < ((header.x + header.w) - label.x)) label.w else (header.x + header.w) - label.x;
            nk_widget_text(out, label, title, text_len, &text, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), font);
        }
    }
    if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0) and !((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_DYNAMIC))) != 0)) {
        var body: struct_nk_rect = undefined;
        _ = &body;
        body.x = win.*.bounds.x;
        body.w = win.*.bounds.w;
        body.y = win.*.bounds.y + layout.*.header_height;
        body.h = win.*.bounds.h - layout.*.header_height;
        while (true) {
            switch (style.*.window.fixed_background.type) {
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    nk_draw_image(out, body, &style.*.window.fixed_background.data.image, nk_white);
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    nk_draw_nine_slice(out, body, &style.*.window.fixed_background.data.slice, nk_white);
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 0))) => {
                    nk_fill_rect(out, body, style.*.window.rounding, style.*.window.fixed_background.data.color);
                    break;
                },
                else => {},
            }
            break;
        }
    }
    {
        var clip: struct_nk_rect = undefined;
        _ = &clip;
        layout.*.clip = layout.*.bounds;
        nk_unify(&clip, &win.*.buffer.clip, layout.*.clip.x, layout.*.clip.y, layout.*.clip.x + layout.*.clip.w, layout.*.clip.y + layout.*.clip.h);
        nk_push_scissor(out, clip);
        layout.*.clip = clip;
    }
    return @intFromBool(!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) and !((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0));
}
pub fn nk_panel_end(arg_ctx: [*c]struct_nk_context) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    var window: [*c]struct_nk_window = undefined;
    _ = &window;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var out: [*c]struct_nk_command_buffer = undefined;
    _ = &out;
    var scrollbar_size: struct_nk_vec2 = undefined;
    _ = &scrollbar_size;
    var panel_padding: struct_nk_vec2 = undefined;
    _ = &panel_padding;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20233))), "void nk_panel_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20234))), "void nk_panel_end(struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20235))), "void nk_panel_end(struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    window = ctx.*.current;
    layout = window.*.layout;
    style = &ctx.*.style;
    out = &window.*.buffer;
    in = if (((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_NO_INPUT))) != 0)) null else &ctx.*.input;
    if (!(nk_panel_is_sub(layout.*.type) != 0)) {
        nk_push_scissor(out, nk_null_rect);
    }
    scrollbar_size = style.*.window.scrollbar_size;
    panel_padding = nk_panel_get_padding(style, layout.*.type);
    layout.*.at_y += layout.*.row.height;
    if (((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_DYNAMIC))) != 0) and !((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) {
        var empty_space: struct_nk_rect = undefined;
        _ = &empty_space;
        if (layout.*.at_y < (layout.*.bounds.y + layout.*.bounds.h)) {
            layout.*.bounds.h = layout.*.at_y - layout.*.bounds.y;
        }
        empty_space.x = window.*.bounds.x;
        empty_space.y = layout.*.bounds.y;
        empty_space.h = panel_padding.y;
        empty_space.w = window.*.bounds.w;
        nk_fill_rect(out, empty_space, @as(f32, @floatFromInt(@as(c_int, 0))), style.*.window.background);
        empty_space.x = window.*.bounds.x;
        empty_space.y = layout.*.bounds.y;
        empty_space.w = panel_padding.x + layout.*.border;
        empty_space.h = layout.*.bounds.h;
        nk_fill_rect(out, empty_space, @as(f32, @floatFromInt(@as(c_int, 0))), style.*.window.background);
        empty_space.x = layout.*.bounds.x + layout.*.bounds.w;
        empty_space.y = layout.*.bounds.y;
        empty_space.w = panel_padding.x + layout.*.border;
        empty_space.h = layout.*.bounds.h;
        if ((layout.*.offset_y.* == @as(nk_uint, @bitCast(@as(c_int, 0)))) and !((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_NO_SCROLLBAR))) != 0)) {
            empty_space.w += scrollbar_size.x;
        }
        nk_fill_rect(out, empty_space, @as(f32, @floatFromInt(@as(c_int, 0))), style.*.window.background);
        if (layout.*.footer_height > @as(f32, @floatFromInt(@as(c_int, 0)))) {
            empty_space.x = window.*.bounds.x;
            empty_space.y = layout.*.bounds.y + layout.*.bounds.h;
            empty_space.w = window.*.bounds.w;
            empty_space.h = layout.*.footer_height;
            nk_fill_rect(out, empty_space, @as(f32, @floatFromInt(@as(c_int, 0))), style.*.window.background);
        }
    }
    if ((!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_NO_SCROLLBAR))) != 0) and !((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) and (window.*.scrollbar_hiding_timer < 4.0)) {
        var scroll: struct_nk_rect = undefined;
        _ = &scroll;
        var scroll_has_scrolling: c_int = undefined;
        _ = &scroll_has_scrolling;
        var scroll_target: f32 = undefined;
        _ = &scroll_target;
        var scroll_offset: f32 = undefined;
        _ = &scroll_offset;
        var scroll_step: f32 = undefined;
        _ = &scroll_step;
        var scroll_inc: f32 = undefined;
        _ = &scroll_inc;
        if (nk_panel_is_sub(layout.*.type) != 0) {
            var root_window: [*c]struct_nk_window = window;
            _ = &root_window;
            var root_panel: [*c]struct_nk_panel = window.*.layout;
            _ = &root_panel;
            while (root_panel.*.parent != null) {
                root_panel = root_panel.*.parent;
            }
            while (root_window.*.parent != null) {
                root_window = root_window.*.parent;
            }
            scroll_has_scrolling = nk_false;
            if ((root_window == ctx.*.active) and (layout.*.has_scrolling != 0)) {
                if ((nk_input_is_mouse_hovering_rect(in, layout.*.bounds) != 0) and ((((root_panel.*.clip.x < (layout.*.bounds.x + layout.*.bounds.w)) and (layout.*.bounds.x < (root_panel.*.clip.x + root_panel.*.clip.w))) and (root_panel.*.clip.y < (layout.*.bounds.y + layout.*.bounds.h))) and (layout.*.bounds.y < (root_panel.*.clip.y + root_panel.*.clip.h)))) {
                    root_panel = window.*.layout;
                    while (root_panel.*.parent != null) {
                        root_panel.*.has_scrolling = @as(c_uint, @bitCast(nk_false));
                        root_panel = root_panel.*.parent;
                    }
                    root_panel.*.has_scrolling = @as(c_uint, @bitCast(nk_false));
                    scroll_has_scrolling = nk_true;
                }
            }
        } else {
            scroll_has_scrolling = @intFromBool((window == ctx.*.active) and (layout.*.has_scrolling != 0));
            if (((in != null) and ((in.*.mouse.scroll_delta.y > @as(f32, @floatFromInt(@as(c_int, 0)))) or (in.*.mouse.scroll_delta.x > @as(f32, @floatFromInt(@as(c_int, 0)))))) and (scroll_has_scrolling != 0)) {
                window.*.scrolled = @as(c_uint, @bitCast(nk_true));
            } else {
                window.*.scrolled = @as(c_uint, @bitCast(nk_false));
            }
        }
        {
            var state: nk_flags = 0;
            _ = &state;
            scroll.x = (layout.*.bounds.x + layout.*.bounds.w) + panel_padding.x;
            scroll.y = layout.*.bounds.y;
            scroll.w = scrollbar_size.x;
            scroll.h = layout.*.bounds.h;
            scroll_offset = @as(f32, @floatFromInt(layout.*.offset_y.*));
            scroll_step = scroll.h * 0.10000000149011612;
            scroll_inc = scroll.h * 0.009999999776482582;
            scroll_target = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(layout.*.at_y - scroll.y))));
            scroll_offset = nk_do_scrollbarv(&state, out, scroll, scroll_has_scrolling, scroll_offset, scroll_target, scroll_step, scroll_inc, &ctx.*.style.scrollv, in, style.*.font);
            layout.*.offset_y.* = @as(nk_uint, @intFromFloat(scroll_offset));
            if ((in != null) and (scroll_has_scrolling != 0)) {
                in.*.mouse.scroll_delta.y = 0;
            }
        }
        {
            var state: nk_flags = 0;
            _ = &state;
            scroll.x = layout.*.bounds.x;
            scroll.y = layout.*.bounds.y + layout.*.bounds.h;
            scroll.w = layout.*.bounds.w;
            scroll.h = scrollbar_size.y;
            scroll_offset = @as(f32, @floatFromInt(layout.*.offset_x.*));
            scroll_target = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(layout.*.max_x - scroll.x))));
            scroll_step = layout.*.max_x * 0.05000000074505806;
            scroll_inc = layout.*.max_x * 0.004999999888241291;
            scroll_offset = nk_do_scrollbarh(&state, out, scroll, scroll_has_scrolling, scroll_offset, scroll_target, scroll_step, scroll_inc, &ctx.*.style.scrollh, in, style.*.font);
            layout.*.offset_x.* = @as(nk_uint, @intFromFloat(scroll_offset));
        }
    }
    if ((window.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_SCROLL_AUTO_HIDE))) != 0) {
        var has_input: c_int = @intFromBool(((ctx.*.input.mouse.delta.x != @as(f32, @floatFromInt(@as(c_int, 0)))) or (ctx.*.input.mouse.delta.y != @as(f32, @floatFromInt(@as(c_int, 0))))) or (ctx.*.input.mouse.scroll_delta.y != @as(f32, @floatFromInt(@as(c_int, 0)))));
        _ = &has_input;
        var is_window_hovered: c_int = nk_window_is_hovered(ctx);
        _ = &is_window_hovered;
        var any_item_active: c_int = @as(c_int, @bitCast(ctx.*.last_widget_state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))));
        _ = &any_item_active;
        if ((!(has_input != 0) and (is_window_hovered != 0)) or (!(is_window_hovered != 0) and !(any_item_active != 0))) {
            window.*.scrollbar_hiding_timer += ctx.*.delta_time_seconds;
        } else {
            window.*.scrollbar_hiding_timer = 0;
        }
    } else {
        window.*.scrollbar_hiding_timer = 0;
    }
    if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_BORDER))) != 0) {
        var border_color: struct_nk_color = nk_panel_get_border_color(style, layout.*.type);
        _ = &border_color;
        const padding_y: f32 = if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0) (style.*.window.border + window.*.bounds.y) + layout.*.header_height else if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_DYNAMIC))) != 0) (layout.*.bounds.y + layout.*.bounds.h) + layout.*.footer_height else window.*.bounds.y + window.*.bounds.h;
        _ = &padding_y;
        var b: struct_nk_rect = window.*.bounds;
        _ = &b;
        b.h = padding_y - window.*.bounds.y;
        nk_stroke_rect(out, b, style.*.window.rounding, layout.*.border, border_color);
    }
    if ((((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_SCALABLE))) != 0) and (in != null)) and !((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) {
        var scaler: struct_nk_rect = undefined;
        _ = &scaler;
        scaler.w = scrollbar_size.x;
        scaler.h = scrollbar_size.y;
        scaler.y = layout.*.bounds.y + layout.*.bounds.h;
        if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_SCALE_LEFT))) != 0) {
            scaler.x = layout.*.bounds.x - (panel_padding.x * 0.5);
        } else {
            scaler.x = (layout.*.bounds.x + layout.*.bounds.w) + panel_padding.x;
        }
        if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_NO_SCROLLBAR))) != 0) {
            scaler.x -= scaler.w;
        }
        {
            var item: [*c]const struct_nk_style_item = &style.*.window.scaler;
            _ = &item;
            if (item.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_IMAGE))) {
                nk_draw_image(out, scaler, &item.*.data.image, nk_white);
            } else {
                if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_SCALE_LEFT))) != 0) {
                    nk_fill_triangle(out, scaler.x, scaler.y, scaler.x, scaler.y + scaler.h, scaler.x + scaler.w, scaler.y + scaler.h, item.*.data.color);
                } else {
                    nk_fill_triangle(out, scaler.x + scaler.w, scaler.y, scaler.x + scaler.w, scaler.y + scaler.h, scaler.x, scaler.y + scaler.h, item.*.data.color);
                }
            }
        }
        if (!((window.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) {
            var window_size: struct_nk_vec2 = style.*.window.min_size;
            _ = &window_size;
            var left_mouse_down: c_int = in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down;
            _ = &left_mouse_down;
            var left_mouse_click_in_scaler: c_int = nk_input_has_mouse_click_down_in_rect(in, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), scaler, nk_true);
            _ = &left_mouse_click_in_scaler;
            if ((left_mouse_down != 0) and (left_mouse_click_in_scaler != 0)) {
                var delta_x: f32 = in.*.mouse.delta.x;
                _ = &delta_x;
                if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_SCALE_LEFT))) != 0) {
                    delta_x = -delta_x;
                    window.*.bounds.x += in.*.mouse.delta.x;
                }
                if ((window.*.bounds.w + delta_x) >= window_size.x) {
                    if ((delta_x < @as(f32, @floatFromInt(@as(c_int, 0)))) or ((delta_x > @as(f32, @floatFromInt(@as(c_int, 0)))) and (in.*.mouse.pos.x >= scaler.x))) {
                        window.*.bounds.w = window.*.bounds.w + delta_x;
                        scaler.x += in.*.mouse.delta.x;
                    }
                }
                if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_DYNAMIC))) != 0)) {
                    if (window_size.y < (window.*.bounds.h + in.*.mouse.delta.y)) {
                        if ((in.*.mouse.delta.y < @as(f32, @floatFromInt(@as(c_int, 0)))) or ((in.*.mouse.delta.y > @as(f32, @floatFromInt(@as(c_int, 0)))) and (in.*.mouse.pos.y >= scaler.y))) {
                            window.*.bounds.h = window.*.bounds.h + in.*.mouse.delta.y;
                            scaler.y += in.*.mouse.delta.y;
                        }
                    }
                }
                ctx.*.style.cursor_active = ctx.*.style.cursors[@as(c_uint, @intCast(NK_CURSOR_RESIZE_TOP_RIGHT_DOWN_LEFT))];
                in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked_pos.x = scaler.x + (scaler.w / 2.0);
                in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked_pos.y = scaler.y + (scaler.h / 2.0);
            }
        }
    }
    if (!(nk_panel_is_sub(layout.*.type) != 0)) {
        if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0) {
            nk_command_buffer_reset(&window.*.buffer);
        } else {
            nk_finish(ctx, window);
        }
    }
    if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_REMOVE_ROM))) != 0) {
        layout.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_ROM));
        layout.*.flags &= ~@as(nk_flags, @bitCast(NK_WINDOW_REMOVE_ROM));
    }
    window.*.flags = layout.*.flags;
    if (((window.*.property.active != 0) and (window.*.property.old != window.*.property.seq)) and (window.*.property.active == window.*.property.prev)) {
        nk_zero(@as(?*anyopaque, @ptrCast(&window.*.property)), @sizeOf(struct_nk_property_state));
    } else {
        window.*.property.old = window.*.property.seq;
        window.*.property.prev = window.*.property.active;
        window.*.property.seq = 0;
    }
    if (((window.*.edit.active != 0) and (window.*.edit.old != window.*.edit.seq)) and (window.*.edit.active == window.*.edit.prev)) {
        nk_zero(@as(?*anyopaque, @ptrCast(&window.*.edit)), @sizeOf(struct_nk_edit_state));
    } else {
        window.*.edit.old = window.*.edit.seq;
        window.*.edit.prev = window.*.edit.active;
        window.*.edit.seq = 0;
    }
    if ((window.*.popup.active_con != 0) and (window.*.popup.con_old != window.*.popup.con_count)) {
        window.*.popup.con_count = 0;
        window.*.popup.con_old = 0;
        window.*.popup.active_con = 0;
    } else {
        window.*.popup.con_old = window.*.popup.con_count;
        window.*.popup.con_count = 0;
    }
    window.*.popup.combo_count = 0;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!(layout.*.row.tree_depth != 0)) {} else {
                __assert_fail("!layout->row.tree_depth", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 20514))), "void nk_panel_end(struct nk_context *)");
            };
        };
    };
}
pub fn nk_layout_row_calculate_usable_space(arg_style: [*c]const struct_nk_style, arg_type: enum_nk_panel_type, arg_total_space: f32, arg_columns: c_int) callconv(.c) f32 {
    var style = arg_style;
    _ = &style;
    var @"type" = arg_type;
    _ = &@"type";
    var total_space = arg_total_space;
    _ = &total_space;
    var columns = arg_columns;
    _ = &columns;
    var panel_spacing: f32 = undefined;
    _ = &panel_spacing;
    var panel_space: f32 = undefined;
    _ = &panel_space;
    var spacing: struct_nk_vec2 = undefined;
    _ = &spacing;
    _ = &@"type";
    spacing = style.*.window.spacing;
    panel_spacing = @as(f32, @floatFromInt(if ((columns - @as(c_int, 1)) < @as(c_int, 0)) @as(c_int, 0) else columns - @as(c_int, 1))) * spacing.x;
    panel_space = total_space - panel_spacing;
    return panel_space;
}
pub fn nk_panel_layout(arg_ctx: [*c]const struct_nk_context, arg_win: [*c]struct_nk_window, arg_height: f32, arg_cols: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var height = arg_height;
    _ = &height;
    var cols = arg_cols;
    _ = &cols;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var out: [*c]struct_nk_command_buffer = undefined;
    _ = &out;
    var item_spacing: struct_nk_vec2 = undefined;
    _ = &item_spacing;
    var color: struct_nk_color = undefined;
    _ = &color;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22059))), "void nk_panel_layout(const struct nk_context *, struct nk_window *, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22060))), "void nk_panel_layout(const struct nk_context *, struct nk_window *, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22061))), "void nk_panel_layout(const struct nk_context *, struct nk_window *, float, int)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    layout = win.*.layout;
    style = &ctx.*.style;
    out = &win.*.buffer;
    color = style.*.window.background;
    item_spacing = style.*.window.spacing;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_MINIMIZED))) != 0)) {} else {
                __assert_fail("!(layout->flags & NK_WINDOW_MINIMIZED)", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22077))), "void nk_panel_layout(const struct nk_context *, struct nk_window *, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_HIDDEN))) != 0)) {} else {
                __assert_fail("!(layout->flags & NK_WINDOW_HIDDEN)", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22078))), "void nk_panel_layout(const struct nk_context *, struct nk_window *, float, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_CLOSED))) != 0)) {} else {
                __assert_fail("!(layout->flags & NK_WINDOW_CLOSED)", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22079))), "void nk_panel_layout(const struct nk_context *, struct nk_window *, float, int)");
            };
        };
    };
    layout.*.row.index = 0;
    layout.*.at_y += layout.*.row.height;
    layout.*.row.columns = cols;
    if (height == 0.0) {
        layout.*.row.height = (if (height < layout.*.row.min_height) layout.*.row.min_height else height) + item_spacing.y;
    } else {
        layout.*.row.height = height + item_spacing.y;
    }
    layout.*.row.item_offset = 0;
    if ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_DYNAMIC))) != 0) {
        var background: struct_nk_rect = undefined;
        _ = &background;
        background.x = win.*.bounds.x;
        background.w = win.*.bounds.w;
        background.y = layout.*.at_y - 1.0;
        background.h = layout.*.row.height + 1.0;
        nk_fill_rect(out, background, @as(f32, @floatFromInt(@as(c_int, 0))), color);
    }
}
pub fn nk_row_layout(arg_ctx: [*c]struct_nk_context, arg_fmt: enum_nk_layout_format, arg_height: f32, arg_cols: c_int, arg_width: c_int) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var fmt = arg_fmt;
    _ = &fmt;
    var height = arg_height;
    _ = &height;
    var cols = arg_cols;
    _ = &cols;
    var width = arg_width;
    _ = &width;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22106))), "void nk_row_layout(struct nk_context *, enum nk_layout_format, float, int, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22107))), "void nk_row_layout(struct nk_context *, enum nk_layout_format, float, int, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22108))), "void nk_row_layout(struct nk_context *, enum nk_layout_format, float, int, int)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    nk_panel_layout(ctx, win, height, cols);
    if (fmt == @as(c_uint, @bitCast(NK_DYNAMIC))) {
        win.*.layout.*.row.type = @as(c_uint, @bitCast(NK_LAYOUT_DYNAMIC_FIXED));
    } else {
        win.*.layout.*.row.type = @as(c_uint, @bitCast(NK_LAYOUT_STATIC_FIXED));
    }
    win.*.layout.*.row.ratio = null;
    win.*.layout.*.row.filled = 0;
    win.*.layout.*.row.item_offset = 0;
    win.*.layout.*.row.item_width = @as(f32, @floatFromInt(width));
}
pub fn nk_panel_alloc_row(arg_ctx: [*c]const struct_nk_context, arg_win: [*c]struct_nk_window) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var layout: [*c]struct_nk_panel = win.*.layout;
    _ = &layout;
    var spacing: struct_nk_vec2 = ctx.*.style.window.spacing;
    _ = &spacing;
    const row_height: f32 = layout.*.row.height - spacing.y;
    _ = &row_height;
    nk_panel_layout(ctx, win, row_height, layout.*.row.columns);
}
pub fn nk_layout_widget_space(arg_bounds: [*c]struct_nk_rect, arg_ctx: [*c]const struct_nk_context, arg_win: [*c]struct_nk_window, arg_modify: c_int) callconv(.c) void {
    var bounds = arg_bounds;
    _ = &bounds;
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var modify = arg_modify;
    _ = &modify;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var spacing: struct_nk_vec2 = undefined;
    _ = &spacing;
    var item_offset: f32 = 0;
    _ = &item_offset;
    var item_width: f32 = 0;
    _ = &item_width;
    var item_spacing: f32 = 0;
    _ = &item_spacing;
    var panel_space: f32 = 0;
    _ = &panel_space;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22576))), "void nk_layout_widget_space(struct nk_rect *, const struct nk_context *, struct nk_window *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22577))), "void nk_layout_widget_space(struct nk_rect *, const struct nk_context *, struct nk_window *, int)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22578))), "void nk_layout_widget_space(struct nk_rect *, const struct nk_context *, struct nk_window *, int)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    style = &ctx.*.style;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (bounds != null) {} else {
                __assert_fail("bounds", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22585))), "void nk_layout_widget_space(struct nk_rect *, const struct nk_context *, struct nk_window *, int)");
            };
        };
    };
    spacing = style.*.window.spacing;
    panel_space = nk_layout_row_calculate_usable_space(&ctx.*.style, layout.*.type, layout.*.bounds.w, layout.*.row.columns);
    while (true) {
        switch (layout.*.row.type) {
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                {
                    var w: f32 = (if (1.0 < panel_space) panel_space else 1.0) / @as(f32, @floatFromInt(layout.*.row.columns));
                    _ = &w;
                    item_offset = @as(f32, @floatFromInt(layout.*.row.index)) * w;
                    item_width = w + (item_offset - @as(f32, @floatFromInt(@as(c_int, @intFromFloat(nk_roundf(item_offset))))));
                    item_spacing = @as(f32, @floatFromInt(layout.*.row.index)) * spacing.x;
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                {
                    var w: f32 = layout.*.row.item_width * panel_space;
                    _ = &w;
                    item_offset = layout.*.row.item_offset;
                    item_width = w + (item_offset - @as(f32, @floatFromInt(@as(c_int, @intFromFloat(nk_roundf(item_offset))))));
                    item_spacing = 0;
                    if (modify != 0) {
                        layout.*.row.item_offset += w + spacing.x;
                        layout.*.row.filled += layout.*.row.item_width;
                        layout.*.row.index = 0;
                    }
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                {
                    bounds.*.x = layout.*.at_x + (layout.*.bounds.w * layout.*.row.item.x);
                    bounds.*.x -= @as(f32, @floatFromInt(layout.*.offset_x.*));
                    bounds.*.y = layout.*.at_y + (layout.*.row.height * layout.*.row.item.y);
                    bounds.*.y -= @as(f32, @floatFromInt(layout.*.offset_y.*));
                    bounds.*.w = (layout.*.bounds.w * layout.*.row.item.w) + (bounds.*.x - @as(f32, @floatFromInt(@as(c_int, @intFromFloat(nk_roundf(bounds.*.x))))));
                    bounds.*.h = (layout.*.row.height * layout.*.row.item.h) + (bounds.*.y - @as(f32, @floatFromInt(@as(c_int, @intFromFloat(nk_roundf(bounds.*.y))))));
                    return;
                }
            },
            @as(c_uint, @bitCast(@as(c_int, 3))) => {
                {
                    var ratio: f32 = undefined;
                    _ = &ratio;
                    var w: f32 = undefined;
                    _ = &w;
                    _ = blk: {
                        _ = @sizeOf(c_int);
                        break :blk blk_1: {
                            break :blk_1 if (layout.*.row.ratio != null) {} else {
                                __assert_fail("layout->row.ratio", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22627))), "void nk_layout_widget_space(struct nk_rect *, const struct nk_context *, struct nk_window *, int)");
                            };
                        };
                    };
                    ratio = if ((blk: {
                        const tmp = layout.*.row.index;
                        if (tmp >= 0) break :blk layout.*.row.ratio + @as(usize, @intCast(tmp)) else break :blk layout.*.row.ratio - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).* < @as(f32, @floatFromInt(@as(c_int, 0)))) layout.*.row.item_width else (blk: {
                        const tmp = layout.*.row.index;
                        if (tmp >= 0) break :blk layout.*.row.ratio + @as(usize, @intCast(tmp)) else break :blk layout.*.row.ratio - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*;
                    w = ratio * panel_space;
                    item_spacing = @as(f32, @floatFromInt(layout.*.row.index)) * spacing.x;
                    item_offset = layout.*.row.item_offset;
                    item_width = w + (item_offset - @as(f32, @floatFromInt(@as(c_int, @intFromFloat(nk_roundf(item_offset))))));
                    if (modify != 0) {
                        layout.*.row.item_offset += w;
                        layout.*.row.filled += ratio;
                    }
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 4))) => {
                {
                    item_width = layout.*.row.item_width;
                    item_offset = @as(f32, @floatFromInt(layout.*.row.index)) * item_width;
                    item_spacing = @as(f32, @floatFromInt(layout.*.row.index)) * spacing.x;
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 5))) => {
                {
                    item_width = layout.*.row.item_width;
                    item_offset = layout.*.row.item_offset;
                    item_spacing = @as(f32, @floatFromInt(layout.*.row.index)) * spacing.x;
                    if (modify != 0) {
                        layout.*.row.item_offset += item_width;
                    }
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 6))) => {
                {
                    bounds.*.x = layout.*.at_x + layout.*.row.item.x;
                    bounds.*.w = layout.*.row.item.w;
                    if (((bounds.*.x + bounds.*.w) > layout.*.max_x) and (modify != 0)) {
                        layout.*.max_x = bounds.*.x + bounds.*.w;
                    }
                    bounds.*.x -= @as(f32, @floatFromInt(layout.*.offset_x.*));
                    bounds.*.y = layout.*.at_y + layout.*.row.item.y;
                    bounds.*.y -= @as(f32, @floatFromInt(layout.*.offset_y.*));
                    bounds.*.h = layout.*.row.item.h;
                    return;
                }
            },
            @as(c_uint, @bitCast(@as(c_int, 7))) => {
                {
                    item_spacing = @as(f32, @floatFromInt(layout.*.row.index)) * spacing.x;
                    item_width = (blk: {
                        const tmp = layout.*.row.index;
                        if (tmp >= 0) break :blk layout.*.row.ratio + @as(usize, @intCast(tmp)) else break :blk layout.*.row.ratio - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                    }).*;
                    item_offset = layout.*.row.item_offset;
                    if (modify != 0) {
                        layout.*.row.item_offset += item_width;
                    }
                }
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 8))) => {
                {
                    var w: f32 = undefined;
                    _ = &w;
                    _ = blk: {
                        _ = @sizeOf(c_int);
                        break :blk blk_1: {
                            break :blk_1 if (layout.*.row.index < layout.*.row.columns) {} else {
                                __assert_fail("layout->row.index < layout->row.columns", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22676))), "void nk_layout_widget_space(struct nk_rect *, const struct nk_context *, struct nk_window *, int)");
                            };
                        };
                    };
                    _ = blk: {
                        _ = @sizeOf(c_int);
                        break :blk blk_1: {
                            break :blk_1 if (layout.*.row.index < @as(c_int, 16)) {} else {
                                __assert_fail("layout->row.index < 16", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22677))), "void nk_layout_widget_space(struct nk_rect *, const struct nk_context *, struct nk_window *, int)");
                            };
                        };
                    };
                    w = layout.*.row.templates[@as(c_uint, @intCast(layout.*.row.index))];
                    item_offset = layout.*.row.item_offset;
                    item_width = w + (item_offset - @as(f32, @floatFromInt(@as(c_int, @intFromFloat(nk_roundf(item_offset))))));
                    item_spacing = @as(f32, @floatFromInt(layout.*.row.index)) * spacing.x;
                    if (modify != 0) {
                        layout.*.row.item_offset += w;
                    }
                }
                break;
            },
            else => {
                _ = blk: {
                    _ = @sizeOf(c_int);
                    break :blk blk_1: {
                        break :blk_1 if (false) {} else {
                            __assert_fail("0", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22685))), "void nk_layout_widget_space(struct nk_rect *, const struct nk_context *, struct nk_window *, int)");
                        };
                    };
                };
                break;
            },
        }
        break;
    }
    bounds.*.w = item_width;
    bounds.*.h = layout.*.row.height - spacing.y;
    bounds.*.y = layout.*.at_y - @as(f32, @floatFromInt(layout.*.offset_y.*));
    bounds.*.x = (layout.*.at_x + item_offset) + item_spacing;
    if (((bounds.*.x + bounds.*.w) > layout.*.max_x) and (modify != 0)) {
        layout.*.max_x = bounds.*.x + bounds.*.w;
    }
    bounds.*.x -= @as(f32, @floatFromInt(layout.*.offset_x.*));
}
pub fn nk_panel_alloc_space(arg_bounds: [*c]struct_nk_rect, arg_ctx: [*c]const struct_nk_context) callconv(.c) void {
    var bounds = arg_bounds;
    _ = &bounds;
    var ctx = arg_ctx;
    _ = &ctx;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22703))), "void nk_panel_alloc_space(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22704))), "void nk_panel_alloc_space(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22705))), "void nk_panel_alloc_space(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    if (layout.*.row.index >= layout.*.row.columns) {
        nk_panel_alloc_row(ctx, win);
    }
    nk_layout_widget_space(bounds, ctx, win, nk_true);
    layout.*.row.index += 1;
}
pub fn nk_layout_peek(arg_bounds: [*c]struct_nk_rect, arg_ctx: [*c]const struct_nk_context) callconv(.c) void {
    var bounds = arg_bounds;
    _ = &bounds;
    var ctx = arg_ctx;
    _ = &ctx;
    var y: f32 = undefined;
    _ = &y;
    var index: c_int = undefined;
    _ = &index;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22727))), "void nk_layout_peek(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22728))), "void nk_layout_peek(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22729))), "void nk_layout_peek(struct nk_rect *, const struct nk_context *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) {
        bounds.* = nk_rect(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
        return;
    }
    win = ctx.*.current;
    layout = win.*.layout;
    y = layout.*.at_y;
    index = layout.*.row.index;
    if (layout.*.row.index >= layout.*.row.columns) {
        layout.*.at_y += layout.*.row.height;
        layout.*.row.index = 0;
    }
    nk_layout_widget_space(bounds, ctx, win, nk_false);
    if (!(layout.*.row.index != 0)) {
        bounds.*.x -= layout.*.row.item_offset;
    }
    layout.*.at_y = y;
    layout.*.row.index = index;
}
pub fn nk_nonblock_begin(arg_ctx: [*c]struct_nk_context, arg_flags: nk_flags, arg_body: struct_nk_rect, arg_header: struct_nk_rect, arg_panel_type: enum_nk_panel_type) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var flags = arg_flags;
    _ = &flags;
    var body = arg_body;
    _ = &body;
    var header = arg_header;
    _ = &header;
    var panel_type = arg_panel_type;
    _ = &panel_type;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var panel: [*c]struct_nk_panel = undefined;
    _ = &panel;
    var is_active: c_int = nk_true;
    _ = &is_active;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21313))), "nk_bool nk_nonblock_begin(struct nk_context *, nk_flags, struct nk_rect, struct nk_rect, enum nk_panel_type)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21314))), "nk_bool nk_nonblock_begin(struct nk_context *, nk_flags, struct nk_rect, struct nk_rect, enum nk_panel_type)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21315))), "nk_bool nk_nonblock_begin(struct nk_context *, nk_flags, struct nk_rect, struct nk_rect, enum nk_panel_type)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    panel = win.*.layout;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (!((@as(c_int, @bitCast(panel.*.type)) & NK_PANEL_SET_POPUP) != 0)) {} else {
                __assert_fail("!((int)panel->type & (int)NK_PANEL_SET_POPUP)", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21322))), "nk_bool nk_nonblock_begin(struct nk_context *, nk_flags, struct nk_rect, struct nk_rect, enum nk_panel_type)");
            };
        };
    };
    _ = &panel;
    popup = win.*.popup.win;
    if (!(popup != null)) {
        popup = @as([*c]struct_nk_window, @ptrCast(@alignCast(nk_create_window(ctx))));
        popup.*.parent = win;
        win.*.popup.win = popup;
        win.*.popup.type = panel_type;
        nk_command_buffer_init(&popup.*.buffer, &ctx.*.memory, @as(c_uint, @bitCast(NK_CLIPPING_ON)));
    } else {
        var pressed: c_int = undefined;
        _ = &pressed;
        var in_body: c_int = undefined;
        _ = &in_body;
        var in_header: c_int = undefined;
        _ = &in_header;
        pressed = nk_input_is_mouse_pressed(&ctx.*.input, @as(c_uint, @bitCast(NK_BUTTON_LEFT)));
        in_body = nk_input_is_mouse_hovering_rect(&ctx.*.input, body);
        in_header = nk_input_is_mouse_hovering_rect(&ctx.*.input, header);
        if ((pressed != 0) and (!(in_body != 0) or (in_header != 0))) {
            is_active = nk_false;
        }
    }
    win.*.popup.header = header;
    if (!(is_active != 0)) {
        var root: [*c]struct_nk_panel = win.*.layout;
        _ = &root;
        while (root != null) {
            root.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_REMOVE_ROM));
            root = root.*.parent;
        }
        return is_active;
    }
    popup.*.bounds = body;
    popup.*.parent = win;
    popup.*.layout = @as([*c]struct_nk_panel, @ptrCast(@alignCast(nk_create_panel(ctx))));
    popup.*.flags = flags;
    popup.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_BORDER));
    popup.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_DYNAMIC));
    popup.*.seq = ctx.*.seq;
    win.*.popup.active = 1;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (popup.*.layout != null) {} else {
                __assert_fail("popup->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21364))), "nk_bool nk_nonblock_begin(struct nk_context *, nk_flags, struct nk_rect, struct nk_rect, enum nk_panel_type)");
            };
        };
    };
    nk_start_popup(ctx, win);
    popup.*.buffer = win.*.buffer;
    nk_push_scissor(&popup.*.buffer, nk_null_rect);
    ctx.*.current = popup;
    _ = nk_panel_begin(ctx, null, panel_type);
    win.*.buffer = popup.*.buffer;
    popup.*.layout.*.parent = win.*.layout;
    popup.*.layout.*.offset_x = &popup.*.scrollbar.x;
    popup.*.layout.*.offset_y = &popup.*.scrollbar.y;
    {
        var root: [*c]struct_nk_panel = undefined;
        _ = &root;
        root = win.*.layout;
        while (root != null) {
            root.*.flags |= @as(nk_flags, @bitCast(NK_WINDOW_ROM));
            root = root.*.parent;
        }
    }
    return is_active;
}
pub fn nk_widget_text(arg_o: [*c]struct_nk_command_buffer, arg_b: struct_nk_rect, arg_string: [*c]const u8, arg_len: c_int, arg_t: [*c]const struct_nk_text, arg_a: nk_flags, arg_f: [*c]const struct_nk_user_font) callconv(.c) void {
    var o = arg_o;
    _ = &o;
    var b = arg_b;
    _ = &b;
    var string = arg_string;
    _ = &string;
    var len = arg_len;
    _ = &len;
    var t = arg_t;
    _ = &t;
    var a = arg_a;
    _ = &a;
    var f = arg_f;
    _ = &f;
    var label: struct_nk_rect = undefined;
    _ = &label;
    var text_width: f32 = undefined;
    _ = &text_width;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (o != null) {} else {
                __assert_fail("o", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23803))), "void nk_widget_text(struct nk_command_buffer *, struct nk_rect, const char *, int, const struct nk_text *, nk_flags, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (t != null) {} else {
                __assert_fail("t", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23804))), "void nk_widget_text(struct nk_command_buffer *, struct nk_rect, const char *, int, const struct nk_text *, nk_flags, const struct nk_user_font *)");
            };
        };
    };
    if (!(o != null) or !(t != null)) return;
    b.h = if (b.h < (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.y)) @as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.y else b.h;
    label.x = 0;
    label.w = 0;
    label.y = b.y + t.*.padding.y;
    label.h = if (f.*.height < (b.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.y))) f.*.height else b.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.y);
    text_width = f.*.width.?(f.*.userdata, f.*.height, string, len);
    text_width += 2.0 * t.*.padding.x;
    if ((a & @as(nk_flags, @bitCast(NK_TEXT_ALIGN_LEFT))) != 0) {
        label.x = b.x + t.*.padding.x;
        label.w = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (b.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x))) b.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x) else @as(f32, @floatFromInt(@as(c_int, 0)));
    } else if ((a & @as(nk_flags, @bitCast(NK_TEXT_ALIGN_CENTERED))) != 0) {
        label.w = if (@as(f32, @floatFromInt(@as(c_int, 1))) < ((@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x) + text_width)) (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x) + text_width else @as(f32, @floatFromInt(@as(c_int, 1)));
        label.x = (b.x + t.*.padding.x) + (((b.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x)) - label.w) / @as(f32, @floatFromInt(@as(c_int, 2))));
        label.x = if ((b.x + t.*.padding.x) < label.x) label.x else b.x + t.*.padding.x;
        label.w = if ((b.x + b.w) < (label.x + label.w)) b.x + b.w else label.x + label.w;
        if (label.w >= label.x) {
            label.w -= label.x;
        }
    } else if ((a & @as(nk_flags, @bitCast(NK_TEXT_ALIGN_RIGHT))) != 0) {
        label.x = if ((b.x + t.*.padding.x) < ((b.x + b.w) - ((@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x) + text_width))) (b.x + b.w) - ((@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x) + text_width) else b.x + t.*.padding.x;
        label.w = text_width + (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x);
    } else return;
    if ((a & @as(nk_flags, @bitCast(NK_TEXT_ALIGN_MIDDLE))) != 0) {
        label.y = (b.y + (b.h / 2.0)) - (f.*.height / 2.0);
        label.h = if ((b.h / 2.0) < (b.h - ((b.h / 2.0) + (f.*.height / 2.0)))) b.h - ((b.h / 2.0) + (f.*.height / 2.0)) else b.h / 2.0;
    } else if ((a & @as(nk_flags, @bitCast(NK_TEXT_ALIGN_BOTTOM))) != 0) {
        label.y = (b.y + b.h) - f.*.height;
        label.h = f.*.height;
    }
    nk_draw_text(o, label, string, len, f, t.*.background, t.*.text);
}
pub fn nk_widget_text_wrap(arg_o: [*c]struct_nk_command_buffer, arg_b: struct_nk_rect, arg_string: [*c]const u8, arg_len: c_int, arg_t: [*c]const struct_nk_text, arg_f: [*c]const struct_nk_user_font) callconv(.c) void {
    var o = arg_o;
    _ = &o;
    var b = arg_b;
    _ = &b;
    var string = arg_string;
    _ = &string;
    var len = arg_len;
    _ = &len;
    var t = arg_t;
    _ = &t;
    var f = arg_f;
    _ = &f;
    var width: f32 = undefined;
    _ = &width;
    var glyphs: c_int = 0;
    _ = &glyphs;
    var fitting: c_int = 0;
    _ = &fitting;
    var done: c_int = 0;
    _ = &done;
    var line: struct_nk_rect = undefined;
    _ = &line;
    var text: struct_nk_text = undefined;
    _ = &text;
    const seperator = struct {
        var static: [1]nk_rune = [1]nk_rune{
            ' ',
        };
    };
    _ = &seperator;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (o != null) {} else {
                __assert_fail("o", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23853))), "void nk_widget_text_wrap(struct nk_command_buffer *, struct nk_rect, const char *, int, const struct nk_text *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (t != null) {} else {
                __assert_fail("t", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 23854))), "void nk_widget_text_wrap(struct nk_command_buffer *, struct nk_rect, const char *, int, const struct nk_text *, const struct nk_user_font *)");
            };
        };
    };
    if (!(o != null) or !(t != null)) return;
    text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    text.background = t.*.background;
    text.text = t.*.text;
    b.w = if (b.w < (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x)) @as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x else b.w;
    b.h = if (b.h < (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.y)) @as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.y else b.h;
    b.h = b.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.y);
    line.x = b.x + t.*.padding.x;
    line.y = b.y + t.*.padding.y;
    line.w = b.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.x);
    line.h = (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.y) + f.*.height;
    fitting = nk_text_clamp(f, string, len, line.w, &glyphs, &width, @as([*c]nk_rune, @ptrCast(@alignCast(&seperator.static))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([1]nk_rune) / @sizeOf(nk_rune))))));
    while (done < len) {
        if (!(fitting != 0) or ((line.y + line.h) >= (b.y + b.h))) break;
        nk_widget_text(o, line, &(blk: {
            const tmp = done;
            if (tmp >= 0) break :blk string + @as(usize, @intCast(tmp)) else break :blk string - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*, fitting, &text, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), f);
        done += fitting;
        line.y += f.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * t.*.padding.y);
        fitting = nk_text_clamp(f, &(blk: {
            const tmp = done;
            if (tmp >= 0) break :blk string + @as(usize, @intCast(tmp)) else break :blk string - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*, len - done, line.w, &glyphs, &width, @as([*c]nk_rune, @ptrCast(@alignCast(&seperator.static))), @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([1]nk_rune) / @sizeOf(nk_rune))))));
    }
}
pub fn nk_button_behavior(arg_state: [*c]nk_flags, arg_r: struct_nk_rect, arg_i: [*c]const struct_nk_input, arg_behavior: enum_nk_button_behavior) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var r = arg_r;
    _ = &r;
    var i = arg_i;
    _ = &i;
    var behavior = arg_behavior;
    _ = &behavior;
    var ret: c_int = 0;
    _ = &ret;
    if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    if (!(i != null)) return 0;
    if (nk_input_is_mouse_hovering_rect(i, r) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVERED));
        if (nk_input_is_mouse_down(i, @as(c_uint, @bitCast(NK_BUTTON_LEFT))) != 0) {
            state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
        }
        if (nk_input_has_mouse_click_in_button_rect(i, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), r) != 0) {
            ret = if (behavior != @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) nk_input_is_mouse_down(i, @as(c_uint, @bitCast(NK_BUTTON_LEFT))) else nk_input_is_mouse_pressed(i, @as(c_uint, @bitCast(NK_BUTTON_LEFT)));
        }
    }
    if (((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) and !(nk_input_is_mouse_prev_hovering_rect(i, r) != 0)) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_ENTERED));
    } else if (nk_input_is_mouse_prev_hovering_rect(i, r) != 0) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_LEFT));
    }
    return ret;
}
pub fn nk_draw_button(arg_out: [*c]struct_nk_command_buffer, arg_bounds: [*c]const struct_nk_rect, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_button) callconv(.c) [*c]const struct_nk_style_item {
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.hover;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.active;
    } else {
        background = &style.*.normal;
    }
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(out, bounds.*, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor_background));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(out, bounds.*, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.color_factor_background));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(out, bounds.*, style.*.rounding, nk_rgb_factor(background.*.data.color, style.*.color_factor_background));
                nk_stroke_rect(out, bounds.*, style.*.rounding, style.*.border, nk_rgb_factor(style.*.border_color, style.*.color_factor_background));
                break;
            },
            else => {},
        }
        break;
    }
    return background;
}
pub fn nk_do_button(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_r: struct_nk_rect, arg_style: [*c]const struct_nk_style_button, arg_in: [*c]const struct_nk_input, arg_behavior: enum_nk_button_behavior, arg_content: [*c]struct_nk_rect) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var r = arg_r;
    _ = &r;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var behavior = arg_behavior;
    _ = &behavior;
    var content = arg_content;
    _ = &content;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24460))), "nk_bool nk_do_button(nk_flags *, struct nk_command_buffer *, struct nk_rect, const struct nk_style_button *, const struct nk_input *, enum nk_button_behavior, struct nk_rect *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24461))), "nk_bool nk_do_button(nk_flags *, struct nk_command_buffer *, struct nk_rect, const struct nk_style_button *, const struct nk_input *, enum nk_button_behavior, struct nk_rect *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24462))), "nk_bool nk_do_button(nk_flags *, struct nk_command_buffer *, struct nk_rect, const struct nk_style_button *, const struct nk_input *, enum nk_button_behavior, struct nk_rect *)");
            };
        };
    };
    if (!(out != null) or !(style != null)) return nk_false;
    content.*.x = ((r.x + style.*.padding.x) + style.*.border) + style.*.rounding;
    content.*.y = ((r.y + style.*.padding.y) + style.*.border) + style.*.rounding;
    content.*.w = r.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * ((style.*.padding.x + style.*.border) + style.*.rounding));
    content.*.h = r.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * ((style.*.padding.y + style.*.border) + style.*.rounding));
    bounds.x = r.x - style.*.touch_padding.x;
    bounds.y = r.y - style.*.touch_padding.y;
    bounds.w = r.w + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.touch_padding.x);
    bounds.h = r.h + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.touch_padding.y);
    return nk_button_behavior(state, bounds, in, behavior);
}
pub fn nk_draw_button_text(arg_out: [*c]struct_nk_command_buffer, arg_bounds: [*c]const struct_nk_rect, arg_content: [*c]const struct_nk_rect, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_button, arg_txt: [*c]const u8, arg_len: c_int, arg_text_alignment: nk_flags, arg_font: [*c]const struct_nk_user_font) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var content = arg_content;
    _ = &content;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var txt = arg_txt;
    _ = &txt;
    var len = arg_len;
    _ = &len;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    var font = arg_font;
    _ = &font;
    var text: struct_nk_text = undefined;
    _ = &text;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    background = nk_draw_button(out, bounds, state, style);
    if (background.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_COLOR))) {
        text.background = background.*.data.color;
    } else {
        text.background = style.*.text_background;
    }
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        text.text = style.*.text_hover;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        text.text = style.*.text_active;
    } else {
        text.text = style.*.text_normal;
    }
    text.text = nk_rgb_factor(text.text, style.*.color_factor_text);
    text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    nk_widget_text(out, content.*, txt, len, &text, text_alignment, font);
}
pub fn nk_do_button_text(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_string: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_behavior: enum_nk_button_behavior, arg_style: [*c]const struct_nk_style_button, arg_in: [*c]const struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var string = arg_string;
    _ = &string;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var behavior = arg_behavior;
    _ = &behavior;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var content: struct_nk_rect = undefined;
    _ = &content;
    var ret: c_int = nk_false;
    _ = &ret;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24514))), "nk_bool nk_do_button_text(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24515))), "nk_bool nk_do_button_text(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24516))), "nk_bool nk_do_button_text(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (string != null) {} else {
                __assert_fail("string", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24517))), "nk_bool nk_do_button_text(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24518))), "nk_bool nk_do_button_text(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if (((!(out != null) or !(style != null)) or !(font != null)) or !(string != null)) return nk_false;
    ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_button_text(out, &bounds, &content, state.*, style, string, len, @"align", font);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return ret;
}
pub fn nk_draw_button_symbol(arg_out: [*c]struct_nk_command_buffer, arg_bounds: [*c]const struct_nk_rect, arg_content: [*c]const struct_nk_rect, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_button, arg_type: enum_nk_symbol_type, arg_font: [*c]const struct_nk_user_font) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var content = arg_content;
    _ = &content;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var @"type" = arg_type;
    _ = &@"type";
    var font = arg_font;
    _ = &font;
    var sym: struct_nk_color = undefined;
    _ = &sym;
    var bg: struct_nk_color = undefined;
    _ = &bg;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    background = nk_draw_button(out, bounds, state, style);
    if (background.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_COLOR))) {
        bg = background.*.data.color;
    } else {
        bg = style.*.text_background;
    }
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        sym = style.*.text_hover;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        sym = style.*.text_active;
    } else {
        sym = style.*.text_normal;
    }
    sym = nk_rgb_factor(sym, style.*.color_factor_text);
    nk_draw_symbol(out, @"type", content.*, bg, sym, @as(f32, @floatFromInt(@as(c_int, 1))), font);
}
pub fn nk_do_button_symbol(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_symbol: enum_nk_symbol_type, arg_behavior: enum_nk_button_behavior, arg_style: [*c]const struct_nk_style_button, arg_in: [*c]const struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var symbol = arg_symbol;
    _ = &symbol;
    var behavior = arg_behavior;
    _ = &behavior;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var ret: c_int = undefined;
    _ = &ret;
    var content: struct_nk_rect = undefined;
    _ = &content;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24562))), "nk_bool nk_do_button_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, enum nk_symbol_type, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24563))), "nk_bool nk_do_button_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, enum nk_symbol_type, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24564))), "nk_bool nk_do_button_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, enum nk_symbol_type, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24565))), "nk_bool nk_do_button_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, enum nk_symbol_type, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if (((!(out != null) or !(style != null)) or !(font != null)) or !(state != null)) return nk_false;
    ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_button_symbol(out, &bounds, &content, state.*, style, symbol, font);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return ret;
}
pub fn nk_draw_button_image(arg_out: [*c]struct_nk_command_buffer, arg_bounds: [*c]const struct_nk_rect, arg_content: [*c]const struct_nk_rect, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_button, arg_img: [*c]const struct_nk_image) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var content = arg_content;
    _ = &content;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var img = arg_img;
    _ = &img;
    _ = nk_draw_button(out, bounds, state, style);
    nk_draw_image(out, content.*, img, nk_rgb_factor(nk_white, style.*.color_factor_background));
}
pub fn nk_do_button_image(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_img: struct_nk_image, arg_b: enum_nk_button_behavior, arg_style: [*c]const struct_nk_style_button, arg_in: [*c]const struct_nk_input) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var img = arg_img;
    _ = &img;
    var b = arg_b;
    _ = &b;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var ret: c_int = undefined;
    _ = &ret;
    var content: struct_nk_rect = undefined;
    _ = &content;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24592))), "nk_bool nk_do_button_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, struct nk_image, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24593))), "nk_bool nk_do_button_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, struct nk_image, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24594))), "nk_bool nk_do_button_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, struct nk_image, enum nk_button_behavior, const struct nk_style_button *, const struct nk_input *)");
            };
        };
    };
    if ((!(out != null) or !(style != null)) or !(state != null)) return nk_false;
    ret = nk_do_button(state, out, bounds, style, in, b, &content);
    content.x += style.*.image_padding.x;
    content.y += style.*.image_padding.y;
    content.w -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.image_padding.x;
    content.h -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.image_padding.y;
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_button_image(out, &bounds, &content, state.*, style, &img);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return ret;
}
pub fn nk_draw_button_text_symbol(arg_out: [*c]struct_nk_command_buffer, arg_bounds: [*c]const struct_nk_rect, arg_label: [*c]const struct_nk_rect, arg_symbol: [*c]const struct_nk_rect, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_button, arg_str: [*c]const u8, arg_len: c_int, arg_type: enum_nk_symbol_type, arg_font: [*c]const struct_nk_user_font) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var label = arg_label;
    _ = &label;
    var symbol = arg_symbol;
    _ = &symbol;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"type" = arg_type;
    _ = &@"type";
    var font = arg_font;
    _ = &font;
    var sym: struct_nk_color = undefined;
    _ = &sym;
    var text: struct_nk_text = undefined;
    _ = &text;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    background = nk_draw_button(out, bounds, state, style);
    if (background.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_COLOR))) {
        text.background = background.*.data.color;
    } else {
        text.background = style.*.text_background;
    }
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        sym = style.*.text_hover;
        text.text = style.*.text_hover;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        sym = style.*.text_active;
        text.text = style.*.text_active;
    } else {
        sym = style.*.text_normal;
        text.text = style.*.text_normal;
    }
    sym = nk_rgb_factor(sym, style.*.color_factor_text);
    text.text = nk_rgb_factor(text.text, style.*.color_factor_text);
    text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    nk_draw_symbol(out, @"type", symbol.*, style.*.text_background, sym, @as(f32, @floatFromInt(@as(c_int, 0))), font);
    nk_widget_text(out, label.*, str, len, &text, @as(nk_flags, @bitCast(NK_TEXT_CENTERED)), font);
}
pub fn nk_do_button_text_symbol(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_symbol: enum_nk_symbol_type, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_behavior: enum_nk_button_behavior, arg_style: [*c]const struct_nk_style_button, arg_font: [*c]const struct_nk_user_font, arg_in: [*c]const struct_nk_input) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var symbol = arg_symbol;
    _ = &symbol;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var behavior = arg_behavior;
    _ = &behavior;
    var style = arg_style;
    _ = &style;
    var font = arg_font;
    _ = &font;
    var in = arg_in;
    _ = &in;
    var ret: c_int = undefined;
    _ = &ret;
    var tri: struct_nk_rect = struct_nk_rect{
        .x = @as(f32, @floatFromInt(@as(c_int, 0))),
        .y = @as(f32, @floatFromInt(@as(c_int, 0))),
        .w = @as(f32, @floatFromInt(@as(c_int, 0))),
        .h = @as(f32, @floatFromInt(@as(c_int, 0))),
    };
    _ = &tri;
    var content: struct_nk_rect = undefined;
    _ = &content;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24655))), "nk_bool nk_do_button_text_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, enum nk_symbol_type, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_user_font *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24656))), "nk_bool nk_do_button_text_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, enum nk_symbol_type, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_user_font *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24657))), "nk_bool nk_do_button_text_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, enum nk_symbol_type, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_user_font *, const struct nk_input *)");
            };
        };
    };
    if ((!(out != null) or !(style != null)) or !(font != null)) return nk_false;
    ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
    tri.y = (content.y + (content.h / @as(f32, @floatFromInt(@as(c_int, 2))))) - (font.*.height / @as(f32, @floatFromInt(@as(c_int, 2))));
    tri.w = font.*.height;
    tri.h = font.*.height;
    if ((@"align" & @as(nk_flags, @bitCast(NK_TEXT_ALIGN_LEFT))) != 0) {
        tri.x = (content.x + content.w) - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) + tri.w);
        tri.x = if (tri.x < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else tri.x;
    } else {
        tri.x = content.x + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x);
    }
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_button_text_symbol(out, &bounds, &content, &tri, state.*, style, str, len, symbol, font);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return ret;
}
pub fn nk_draw_button_text_image(arg_out: [*c]struct_nk_command_buffer, arg_bounds: [*c]const struct_nk_rect, arg_label: [*c]const struct_nk_rect, arg_image: [*c]const struct_nk_rect, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_button, arg_str: [*c]const u8, arg_len: c_int, arg_font: [*c]const struct_nk_user_font, arg_img: [*c]const struct_nk_image) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var label = arg_label;
    _ = &label;
    var image = arg_image;
    _ = &image;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var font = arg_font;
    _ = &font;
    var img = arg_img;
    _ = &img;
    var text: struct_nk_text = undefined;
    _ = &text;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    background = nk_draw_button(out, bounds, state, style);
    if (background.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_COLOR))) {
        text.background = background.*.data.color;
    } else {
        text.background = style.*.text_background;
    }
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        text.text = style.*.text_hover;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        text.text = style.*.text_active;
    } else {
        text.text = style.*.text_normal;
    }
    text.text = nk_rgb_factor(text.text, style.*.color_factor_text);
    text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    nk_widget_text(out, label.*, str, len, &text, @as(nk_flags, @bitCast(NK_TEXT_CENTERED)), font);
    nk_draw_image(out, image.*, img, nk_rgb_factor(nk_white, style.*.color_factor_background));
}
pub fn nk_do_button_text_image(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_img: struct_nk_image, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_behavior: enum_nk_button_behavior, arg_style: [*c]const struct_nk_style_button, arg_font: [*c]const struct_nk_user_font, arg_in: [*c]const struct_nk_input) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var img = arg_img;
    _ = &img;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var behavior = arg_behavior;
    _ = &behavior;
    var style = arg_style;
    _ = &style;
    var font = arg_font;
    _ = &font;
    var in = arg_in;
    _ = &in;
    var ret: c_int = undefined;
    _ = &ret;
    var icon: struct_nk_rect = undefined;
    _ = &icon;
    var content: struct_nk_rect = undefined;
    _ = &content;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24713))), "nk_bool nk_do_button_text_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, struct nk_image, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_user_font *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24714))), "nk_bool nk_do_button_text_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, struct nk_image, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_user_font *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24715))), "nk_bool nk_do_button_text_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, struct nk_image, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_user_font *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 24716))), "nk_bool nk_do_button_text_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, struct nk_image, const char *, int, nk_flags, enum nk_button_behavior, const struct nk_style_button *, const struct nk_user_font *, const struct nk_input *)");
            };
        };
    };
    if (((!(out != null) or !(font != null)) or !(style != null)) or !(str != null)) return nk_false;
    ret = nk_do_button(state, out, bounds, style, in, behavior, &content);
    icon.y = bounds.y + style.*.padding.y;
    icon.w = blk: {
        const tmp = bounds.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y);
        icon.h = tmp;
        break :blk tmp;
    };
    if ((@"align" & @as(nk_flags, @bitCast(NK_TEXT_ALIGN_LEFT))) != 0) {
        icon.x = (bounds.x + bounds.w) - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) + icon.w);
        icon.x = if (icon.x < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else icon.x;
    } else {
        icon.x = bounds.x + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x);
    }
    icon.x += style.*.image_padding.x;
    icon.y += style.*.image_padding.y;
    icon.w -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.image_padding.x;
    icon.h -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.image_padding.y;
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_button_text_image(out, &bounds, &content, &icon, state.*, style, str, len, font, &img);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return ret;
}
pub const NK_TOGGLE_CHECK: c_int = 0;
pub const NK_TOGGLE_OPTION: c_int = 1;
pub const enum_nk_toggle_type = c_uint;
pub fn nk_toggle_behavior(arg_in: [*c]const struct_nk_input, arg_select: struct_nk_rect, arg_state: [*c]nk_flags, arg_active: nk_bool) callconv(.c) nk_bool {
    var in = arg_in;
    _ = &in;
    var select = arg_select;
    _ = &select;
    var state = arg_state;
    _ = &state;
    var active = arg_active;
    _ = &active;
    if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    if (nk_button_behavior(state, select, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
        active = @intFromBool(!(active != 0));
    }
    if (((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) and !(nk_input_is_mouse_prev_hovering_rect(in, select) != 0)) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_ENTERED));
    } else if (nk_input_is_mouse_prev_hovering_rect(in, select) != 0) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_LEFT));
    }
    return active;
}
pub fn nk_draw_checkbox(arg_out: [*c]struct_nk_command_buffer, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_toggle, arg_active: nk_bool, arg_label: [*c]const struct_nk_rect, arg_selector: [*c]const struct_nk_rect, arg_cursors: [*c]const struct_nk_rect, arg_string: [*c]const u8, arg_len: c_int, arg_font: [*c]const struct_nk_user_font, arg_text_alignment: nk_flags) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var active = arg_active;
    _ = &active;
    var label = arg_label;
    _ = &label;
    var selector = arg_selector;
    _ = &selector;
    var cursors = arg_cursors;
    _ = &cursors;
    var string = arg_string;
    _ = &string;
    var len = arg_len;
    _ = &len;
    var font = arg_font;
    _ = &font;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var cursor: [*c]const struct_nk_style_item = undefined;
    _ = &cursor;
    var text: struct_nk_text = undefined;
    _ = &text;
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.hover;
        cursor = &style.*.cursor_hover;
        text.text = style.*.text_hover;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.hover;
        cursor = &style.*.cursor_hover;
        text.text = style.*.text_active;
    } else {
        background = &style.*.normal;
        cursor = &style.*.cursor_normal;
        text.text = style.*.text_normal;
    }
    text.text = nk_rgb_factor(text.text, style.*.color_factor);
    text.padding.x = 0;
    text.padding.y = 0;
    text.background = style.*.text_background;
    nk_widget_text(out, label.*, string, len, &text, text_alignment, font);
    if (background.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_COLOR))) {
        nk_fill_rect(out, selector.*, @as(f32, @floatFromInt(@as(c_int, 0))), nk_rgb_factor(style.*.border_color, style.*.color_factor));
        nk_fill_rect(out, nk_shrink_rect(selector.*, style.*.border), @as(f32, @floatFromInt(@as(c_int, 0))), nk_rgb_factor(background.*.data.color, style.*.color_factor));
    } else {
        nk_draw_image(out, selector.*, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
    }
    if (active != 0) {
        if (cursor.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_IMAGE))) {
            nk_draw_image(out, cursors.*, &cursor.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
        } else {
            nk_fill_rect(out, cursors.*, @as(f32, @floatFromInt(@as(c_int, 0))), cursor.*.data.color);
        }
    }
}
pub fn nk_draw_option(arg_out: [*c]struct_nk_command_buffer, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_toggle, arg_active: nk_bool, arg_label: [*c]const struct_nk_rect, arg_selector: [*c]const struct_nk_rect, arg_cursors: [*c]const struct_nk_rect, arg_string: [*c]const u8, arg_len: c_int, arg_font: [*c]const struct_nk_user_font, arg_text_alignment: nk_flags) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var active = arg_active;
    _ = &active;
    var label = arg_label;
    _ = &label;
    var selector = arg_selector;
    _ = &selector;
    var cursors = arg_cursors;
    _ = &cursors;
    var string = arg_string;
    _ = &string;
    var len = arg_len;
    _ = &len;
    var font = arg_font;
    _ = &font;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var cursor: [*c]const struct_nk_style_item = undefined;
    _ = &cursor;
    var text: struct_nk_text = undefined;
    _ = &text;
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.hover;
        cursor = &style.*.cursor_hover;
        text.text = style.*.text_hover;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.hover;
        cursor = &style.*.cursor_hover;
        text.text = style.*.text_active;
    } else {
        background = &style.*.normal;
        cursor = &style.*.cursor_normal;
        text.text = style.*.text_normal;
    }
    text.text = nk_rgb_factor(text.text, style.*.color_factor);
    text.padding.x = 0;
    text.padding.y = 0;
    text.background = style.*.text_background;
    nk_widget_text(out, label.*, string, len, &text, text_alignment, font);
    if (background.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_COLOR))) {
        nk_fill_circle(out, selector.*, nk_rgb_factor(style.*.border_color, style.*.color_factor));
        nk_fill_circle(out, nk_shrink_rect(selector.*, style.*.border), nk_rgb_factor(background.*.data.color, style.*.color_factor));
    } else {
        nk_draw_image(out, selector.*, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
    }
    if (active != 0) {
        if (cursor.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_IMAGE))) {
            nk_draw_image(out, cursors.*, &cursor.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
        } else {
            nk_fill_circle(out, cursors.*, cursor.*.data.color);
        }
    }
}
pub fn nk_do_toggle(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_r: struct_nk_rect, arg_active: [*c]nk_bool, arg_str: [*c]const u8, arg_len: c_int, arg_type: enum_nk_toggle_type, arg_style: [*c]const struct_nk_style_toggle, arg_in: [*c]const struct_nk_input, arg_font: [*c]const struct_nk_user_font, arg_widget_alignment: nk_flags, arg_text_alignment: nk_flags) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var r = arg_r;
    _ = &r;
    var active = arg_active;
    _ = &active;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"type" = arg_type;
    _ = &@"type";
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var widget_alignment = arg_widget_alignment;
    _ = &widget_alignment;
    var text_alignment = arg_text_alignment;
    _ = &text_alignment;
    var was_active: c_int = undefined;
    _ = &was_active;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var select: struct_nk_rect = undefined;
    _ = &select;
    var cursor: struct_nk_rect = undefined;
    _ = &cursor;
    var label: struct_nk_rect = undefined;
    _ = &label;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25142))), "nk_bool nk_do_toggle(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_bool *, const char *, int, enum nk_toggle_type, const struct nk_style_toggle *, const struct nk_input *, const struct nk_user_font *, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25143))), "nk_bool nk_do_toggle(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_bool *, const char *, int, enum nk_toggle_type, const struct nk_style_toggle *, const struct nk_input *, const struct nk_user_font *, nk_flags, nk_flags)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25144))), "nk_bool nk_do_toggle(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_bool *, const char *, int, enum nk_toggle_type, const struct nk_style_toggle *, const struct nk_input *, const struct nk_user_font *, nk_flags, nk_flags)");
            };
        };
    };
    if (((!(out != null) or !(style != null)) or !(font != null)) or !(active != null)) return 0;
    r.w = if (r.w < (font.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x))) font.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) else r.w;
    r.h = if (r.h < (font.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y))) font.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y) else r.h;
    bounds.x = r.x - style.*.touch_padding.x;
    bounds.y = r.y - style.*.touch_padding.y;
    bounds.w = r.w + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.touch_padding.x);
    bounds.h = r.h + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.touch_padding.y);
    select.w = font.*.height;
    select.h = select.w;
    if ((widget_alignment & @as(nk_flags, @bitCast(NK_WIDGET_ALIGN_RIGHT))) != 0) {
        select.x = (r.x + r.w) - font.*.height;
        label.x = r.x;
        label.w = (r.w - select.w) - (style.*.spacing * @as(f32, @floatFromInt(@as(c_int, 2))));
    } else if ((widget_alignment & @as(nk_flags, @bitCast(NK_WIDGET_ALIGN_CENTERED))) != 0) {
        select.x = r.x + ((r.w - select.w) / @as(f32, @floatFromInt(@as(c_int, 2))));
        label.x = r.x;
        label.w = ((r.w - select.w) - (style.*.spacing * @as(f32, @floatFromInt(@as(c_int, 2))))) / @as(f32, @floatFromInt(@as(c_int, 2)));
    } else {
        select.x = r.x;
        label.x = (select.x + select.w) + style.*.spacing;
        label.w = (if ((r.x + r.w) < label.x) label.x else r.x + r.w) - label.x;
    }
    if ((widget_alignment & @as(nk_flags, @bitCast(NK_WIDGET_ALIGN_TOP))) != 0) {
        select.y = r.y;
    } else if ((widget_alignment & @as(nk_flags, @bitCast(NK_WIDGET_ALIGN_BOTTOM))) != 0) {
        select.y = ((r.y + r.h) - select.h) - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y);
    } else {
        select.y = (r.y + (r.h / 2.0)) - (select.h / 2.0);
    }
    label.y = select.y;
    label.h = select.w;
    cursor.x = (select.x + style.*.padding.x) + style.*.border;
    cursor.y = (select.y + style.*.padding.y) + style.*.border;
    cursor.w = select.w - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border));
    cursor.h = select.h - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border));
    was_active = active.*;
    active.* = nk_toggle_behavior(in, bounds, state, active.*);
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    if (@"type" == @as(c_uint, @bitCast(NK_TOGGLE_CHECK))) {
        nk_draw_checkbox(out, state.*, style, active.*, &label, &select, &cursor, str, len, font, text_alignment);
    } else {
        nk_draw_option(out, state.*, style, active.*, &label, &select, &cursor, str, len, font, text_alignment);
    }
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return @intFromBool(was_active != active.*);
}
pub fn nk_progress_behavior(arg_state: [*c]nk_flags, arg_in: [*c]struct_nk_input, arg_r: struct_nk_rect, arg_cursor: struct_nk_rect, arg_max: nk_size, arg_value: nk_size, arg_modifiable: nk_bool) callconv(.c) nk_size {
    var state = arg_state;
    _ = &state;
    var in = arg_in;
    _ = &in;
    var r = arg_r;
    _ = &r;
    var cursor = arg_cursor;
    _ = &cursor;
    var max = arg_max;
    _ = &max;
    var value = arg_value;
    _ = &value;
    var modifiable = arg_modifiable;
    _ = &modifiable;
    var left_mouse_down: c_int = 0;
    _ = &left_mouse_down;
    var left_mouse_click_in_cursor: c_int = 0;
    _ = &left_mouse_click_in_cursor;
    if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    if (!(in != null) or !(modifiable != 0)) return value;
    left_mouse_down = @intFromBool((in != null) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0));
    left_mouse_click_in_cursor = @intFromBool((in != null) and (nk_input_has_mouse_click_down_in_rect(in, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), cursor, nk_true) != 0));
    if (nk_input_is_mouse_hovering_rect(in, r) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVERED));
    }
    if (((in != null) and (left_mouse_down != 0)) and (left_mouse_click_in_cursor != 0)) {
        if ((left_mouse_down != 0) and (left_mouse_click_in_cursor != 0)) {
            var ratio: f32 = (if (@as(f32, @floatFromInt(@as(c_int, 0))) < (in.*.mouse.pos.x - cursor.x)) in.*.mouse.pos.x - cursor.x else @as(f32, @floatFromInt(@as(c_int, 0)))) / cursor.w;
            _ = &ratio;
            value = @as(nk_size, @intFromFloat(if ((if ((@as(f32, @floatFromInt(max)) * ratio) < @as(f32, @floatFromInt(max))) @as(f32, @floatFromInt(max)) * ratio else @as(f32, @floatFromInt(max))) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else if ((@as(f32, @floatFromInt(max)) * ratio) < @as(f32, @floatFromInt(max))) @as(f32, @floatFromInt(max)) * ratio else @as(f32, @floatFromInt(max))));
            in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked_pos.x = cursor.x + (cursor.w / 2.0);
            state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
        }
    }
    if (((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) and !(nk_input_is_mouse_prev_hovering_rect(in, r) != 0)) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_ENTERED));
    } else if (nk_input_is_mouse_prev_hovering_rect(in, r) != 0) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_LEFT));
    }
    return value;
}
pub fn nk_draw_progress(arg_out: [*c]struct_nk_command_buffer, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_progress, arg_bounds: [*c]const struct_nk_rect, arg_scursor: [*c]const struct_nk_rect, arg_value: nk_size, arg_max: nk_size) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var bounds = arg_bounds;
    _ = &bounds;
    var scursor = arg_scursor;
    _ = &scursor;
    var value = arg_value;
    _ = &value;
    var max = arg_max;
    _ = &max;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var cursor: [*c]const struct_nk_style_item = undefined;
    _ = &cursor;
    _ = &max;
    _ = &value;
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.active;
        cursor = &style.*.cursor_active;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.hover;
        cursor = &style.*.cursor_hover;
    } else {
        background = &style.*.normal;
        cursor = &style.*.cursor_normal;
    }
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(out, bounds.*, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(out, bounds.*, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(out, bounds.*, style.*.rounding, nk_rgb_factor(background.*.data.color, style.*.color_factor));
                nk_stroke_rect(out, bounds.*, style.*.rounding, style.*.border, nk_rgb_factor(style.*.border_color, style.*.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    while (true) {
        switch (cursor.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(out, scursor.*, &cursor.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(out, scursor.*, &cursor.*.data.slice, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(out, scursor.*, style.*.rounding, nk_rgb_factor(cursor.*.data.color, style.*.color_factor));
                nk_stroke_rect(out, scursor.*, style.*.rounding, style.*.border, nk_rgb_factor(style.*.border_color, style.*.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
}
pub fn nk_do_progress(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_value: nk_size, arg_max: nk_size, arg_modifiable: nk_bool, arg_style: [*c]const struct_nk_style_progress, arg_in: [*c]struct_nk_input) callconv(.c) nk_size {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var value = arg_value;
    _ = &value;
    var max = arg_max;
    _ = &max;
    var modifiable = arg_modifiable;
    _ = &modifiable;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var prog_scale: f32 = undefined;
    _ = &prog_scale;
    var prog_value: nk_size = undefined;
    _ = &prog_value;
    var cursor: struct_nk_rect = undefined;
    _ = &cursor;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26408))), "nk_size nk_do_progress(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_size, nk_size, nk_bool, const struct nk_style_progress *, struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26409))), "nk_size nk_do_progress(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_size, nk_size, nk_bool, const struct nk_style_progress *, struct nk_input *)");
            };
        };
    };
    if (!(out != null) or !(style != null)) return 0;
    cursor.w = if (bounds.w < ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border))) (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border) else bounds.w;
    cursor.h = if (bounds.h < ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border))) (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border) else bounds.h;
    cursor = nk_pad_rect(bounds, nk_vec2(style.*.padding.x + style.*.border, style.*.padding.y + style.*.border));
    prog_scale = @as(f32, @floatFromInt(value)) / @as(f32, @floatFromInt(max));
    prog_value = if (value < max) value else max;
    prog_value = nk_progress_behavior(state, in, bounds, cursor, max, prog_value, modifiable);
    cursor.w = cursor.w * prog_scale;
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_progress(out, state.*, style, &bounds, &cursor, value, max);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return prog_value;
}
pub fn nk_slider_behavior(arg_state: [*c]nk_flags, arg_logical_cursor: [*c]struct_nk_rect, arg_visual_cursor: [*c]struct_nk_rect, arg_in: [*c]struct_nk_input, arg_bounds: struct_nk_rect, arg_slider_min: f32, arg_slider_max: f32, arg_slider_value: f32, arg_slider_step: f32, arg_slider_steps: f32) callconv(.c) f32 {
    var state = arg_state;
    _ = &state;
    var logical_cursor = arg_logical_cursor;
    _ = &logical_cursor;
    var visual_cursor = arg_visual_cursor;
    _ = &visual_cursor;
    var in = arg_in;
    _ = &in;
    var bounds = arg_bounds;
    _ = &bounds;
    var slider_min = arg_slider_min;
    _ = &slider_min;
    var slider_max = arg_slider_max;
    _ = &slider_max;
    var slider_value = arg_slider_value;
    _ = &slider_value;
    var slider_step = arg_slider_step;
    _ = &slider_step;
    var slider_steps = arg_slider_steps;
    _ = &slider_steps;
    var left_mouse_down: c_int = undefined;
    _ = &left_mouse_down;
    var left_mouse_click_in_cursor: c_int = undefined;
    _ = &left_mouse_click_in_cursor;
    if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    left_mouse_down = @intFromBool((in != null) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0));
    left_mouse_click_in_cursor = @intFromBool((in != null) and (nk_input_has_mouse_click_down_in_rect(in, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), visual_cursor.*, nk_true) != 0));
    if ((left_mouse_down != 0) and (left_mouse_click_in_cursor != 0)) {
        var ratio: f32 = 0;
        _ = &ratio;
        const d: f32 = in.*.mouse.pos.x - (visual_cursor.*.x + (visual_cursor.*.w * 0.5));
        _ = &d;
        const pxstep: f32 = bounds.w / slider_steps;
        _ = &pxstep;
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
        if ((if (d < @as(f32, @floatFromInt(@as(c_int, 0)))) -d else d) >= pxstep) {
            const steps: f32 = @as(f32, @floatFromInt(@as(c_int, @intFromFloat((if (d < @as(f32, @floatFromInt(@as(c_int, 0)))) -d else d) / pxstep))));
            _ = &steps;
            slider_value += if (d > @as(f32, @floatFromInt(@as(c_int, 0)))) slider_step * steps else -(slider_step * steps);
            slider_value = if ((if (slider_value < slider_max) slider_value else slider_max) < slider_min) slider_min else if (slider_value < slider_max) slider_value else slider_max;
            ratio = (slider_value - slider_min) / slider_step;
            logical_cursor.*.x = bounds.x + (logical_cursor.*.w * ratio);
            in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked_pos.x = logical_cursor.*.x;
        }
    }
    if (nk_input_is_mouse_hovering_rect(in, bounds) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVERED));
    }
    if (((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) and !(nk_input_is_mouse_prev_hovering_rect(in, bounds) != 0)) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_ENTERED));
    } else if (nk_input_is_mouse_prev_hovering_rect(in, bounds) != 0) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_LEFT));
    }
    return slider_value;
}
pub fn nk_draw_slider(arg_out: [*c]struct_nk_command_buffer, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_slider, arg_bounds: [*c]const struct_nk_rect, arg_visual_cursor: [*c]const struct_nk_rect, arg_min: f32, arg_value: f32, arg_max: f32) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var bounds = arg_bounds;
    _ = &bounds;
    var visual_cursor = arg_visual_cursor;
    _ = &visual_cursor;
    var min = arg_min;
    _ = &min;
    var value = arg_value;
    _ = &value;
    var max = arg_max;
    _ = &max;
    var fill: struct_nk_rect = undefined;
    _ = &fill;
    var bar: struct_nk_rect = undefined;
    _ = &bar;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var bar_color: struct_nk_color = undefined;
    _ = &bar_color;
    var cursor: [*c]const struct_nk_style_item = undefined;
    _ = &cursor;
    _ = &min;
    _ = &max;
    _ = &value;
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.active;
        bar_color = style.*.bar_active;
        cursor = &style.*.cursor_active;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.hover;
        bar_color = style.*.bar_hover;
        cursor = &style.*.cursor_hover;
    } else {
        background = &style.*.normal;
        bar_color = style.*.bar_normal;
        cursor = &style.*.cursor_normal;
    }
    bar.x = bounds.*.x;
    bar.y = (visual_cursor.*.y + (visual_cursor.*.h / @as(f32, @floatFromInt(@as(c_int, 2))))) - (bounds.*.h / @as(f32, @floatFromInt(@as(c_int, 12))));
    bar.w = bounds.*.w;
    bar.h = bounds.*.h / @as(f32, @floatFromInt(@as(c_int, 6)));
    fill.w = (visual_cursor.*.x + (visual_cursor.*.w / 2.0)) - bar.x;
    fill.x = bar.x;
    fill.y = bar.y;
    fill.h = bar.h;
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(out, bounds.*, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(out, bounds.*, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(out, bounds.*, style.*.rounding, nk_rgb_factor(background.*.data.color, style.*.color_factor));
                nk_stroke_rect(out, bounds.*, style.*.rounding, style.*.border, nk_rgb_factor(style.*.border_color, style.*.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    nk_fill_rect(out, bar, style.*.rounding, nk_rgb_factor(bar_color, style.*.color_factor));
    nk_fill_rect(out, fill, style.*.rounding, nk_rgb_factor(style.*.bar_filled, style.*.color_factor));
    if (cursor.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_IMAGE))) {
        nk_draw_image(out, visual_cursor.*, &cursor.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
    } else {
        nk_fill_circle(out, visual_cursor.*, nk_rgb_factor(cursor.*.data.color, style.*.color_factor));
    }
}
pub fn nk_do_slider(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_min: f32, arg_val: f32, arg_max: f32, arg_step: f32, arg_style: [*c]const struct_nk_style_slider, arg_in: [*c]struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) f32 {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var slider_range: f32 = undefined;
    _ = &slider_range;
    var slider_min: f32 = undefined;
    _ = &slider_min;
    var slider_max: f32 = undefined;
    _ = &slider_max;
    var slider_value: f32 = undefined;
    _ = &slider_value;
    var slider_steps: f32 = undefined;
    _ = &slider_steps;
    var cursor_offset: f32 = undefined;
    _ = &cursor_offset;
    var visual_cursor: struct_nk_rect = undefined;
    _ = &visual_cursor;
    var logical_cursor: struct_nk_rect = undefined;
    _ = &logical_cursor;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25927))), "float nk_do_slider(nk_flags *, struct nk_command_buffer *, struct nk_rect, float, float, float, float, const struct nk_style_slider *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25928))), "float nk_do_slider(nk_flags *, struct nk_command_buffer *, struct nk_rect, float, float, float, float, const struct nk_style_slider *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if (!(out != null) or !(style != null)) return 0;
    bounds.x = bounds.x + style.*.padding.x;
    bounds.y = bounds.y + style.*.padding.y;
    bounds.h = if (bounds.h < (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y)) @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y else bounds.h;
    bounds.w = if (bounds.w < ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) + style.*.cursor_size.x)) (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) + style.*.cursor_size.x else bounds.w;
    bounds.w -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x;
    bounds.h -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y;
    if (style.*.show_buttons != 0) {
        var ws: nk_flags = undefined;
        _ = &ws;
        var button: struct_nk_rect = undefined;
        _ = &button;
        button.y = bounds.y;
        button.w = bounds.h;
        button.h = bounds.h;
        button.x = bounds.x;
        if (nk_do_button_symbol(&ws, out, button, style.*.dec_symbol, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &style.*.dec_button, in, font) != 0) {
            val -= step;
        }
        button.x = (bounds.x + bounds.w) - button.w;
        if (nk_do_button_symbol(&ws, out, button, style.*.inc_symbol, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), &style.*.inc_button, in, font) != 0) {
            val += step;
        }
        bounds.x = (bounds.x + button.w) + style.*.spacing.x;
        bounds.w = bounds.w - ((@as(f32, @floatFromInt(@as(c_int, 2))) * button.w) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.spacing.x));
    }
    bounds.x += style.*.cursor_size.x * 0.5;
    bounds.w -= style.*.cursor_size.x;
    slider_max = if (min < max) max else min;
    slider_min = if (min < max) min else max;
    slider_value = if ((if (val < slider_max) val else slider_max) < slider_min) slider_min else if (val < slider_max) val else slider_max;
    slider_range = slider_max - slider_min;
    slider_steps = slider_range / step;
    cursor_offset = (slider_value - slider_min) / step;
    logical_cursor.h = bounds.h;
    logical_cursor.w = bounds.w / slider_steps;
    logical_cursor.x = bounds.x + (logical_cursor.w * cursor_offset);
    logical_cursor.y = bounds.y;
    visual_cursor.h = style.*.cursor_size.y;
    visual_cursor.w = style.*.cursor_size.x;
    visual_cursor.y = (bounds.y + (bounds.h * 0.5)) - (visual_cursor.h * 0.5);
    visual_cursor.x = logical_cursor.x - (visual_cursor.w * 0.5);
    slider_value = nk_slider_behavior(state, &logical_cursor, &visual_cursor, in, bounds, slider_min, slider_max, slider_value, step, slider_steps);
    visual_cursor.x = logical_cursor.x - (visual_cursor.w * 0.5);
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_slider(out, state.*, style, &bounds, &visual_cursor, slider_min, slider_value, slider_max);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return slider_value;
}
pub fn nk_scrollbar_behavior(arg_state: [*c]nk_flags, arg_in: [*c]struct_nk_input, arg_has_scrolling: c_int, arg_scroll: [*c]const struct_nk_rect, arg_cursor: [*c]const struct_nk_rect, arg_empty0: [*c]const struct_nk_rect, arg_empty1: [*c]const struct_nk_rect, arg_scroll_offset: f32, arg_target: f32, arg_scroll_step: f32, arg_o: enum_nk_orientation) callconv(.c) f32 {
    var state = arg_state;
    _ = &state;
    var in = arg_in;
    _ = &in;
    var has_scrolling = arg_has_scrolling;
    _ = &has_scrolling;
    var scroll = arg_scroll;
    _ = &scroll;
    var cursor = arg_cursor;
    _ = &cursor;
    var empty0 = arg_empty0;
    _ = &empty0;
    var empty1 = arg_empty1;
    _ = &empty1;
    var scroll_offset = arg_scroll_offset;
    _ = &scroll_offset;
    var target = arg_target;
    _ = &target;
    var scroll_step = arg_scroll_step;
    _ = &scroll_step;
    var o = arg_o;
    _ = &o;
    var ws: nk_flags = 0;
    _ = &ws;
    var left_mouse_down: c_int = undefined;
    _ = &left_mouse_down;
    var left_mouse_clicked: c_uint = undefined;
    _ = &left_mouse_clicked;
    var left_mouse_click_in_cursor: c_int = undefined;
    _ = &left_mouse_click_in_cursor;
    var scroll_delta: f32 = undefined;
    _ = &scroll_delta;
    if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    if (!(in != null)) return scroll_offset;
    left_mouse_down = in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down;
    left_mouse_clicked = in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked;
    left_mouse_click_in_cursor = nk_input_has_mouse_click_down_in_rect(in, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), cursor.*, nk_true);
    if (nk_input_is_mouse_hovering_rect(in, scroll.*) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVERED));
    }
    scroll_delta = if (o == @as(c_uint, @bitCast(NK_VERTICAL))) in.*.mouse.scroll_delta.y else in.*.mouse.scroll_delta.x;
    if (((left_mouse_down != 0) and (left_mouse_click_in_cursor != 0)) and !(left_mouse_clicked != 0)) {
        var pixel: f32 = undefined;
        _ = &pixel;
        var delta: f32 = undefined;
        _ = &delta;
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
        if (o == @as(c_uint, @bitCast(NK_VERTICAL))) {
            var cursor_y: f32 = undefined;
            _ = &cursor_y;
            pixel = in.*.mouse.delta.y;
            delta = (pixel / scroll.*.h) * target;
            scroll_offset = if ((if ((scroll_offset + delta) < (target - scroll.*.h)) scroll_offset + delta else target - scroll.*.h) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else if ((scroll_offset + delta) < (target - scroll.*.h)) scroll_offset + delta else target - scroll.*.h;
            cursor_y = scroll.*.y + ((scroll_offset / target) * scroll.*.h);
            in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked_pos.y = cursor_y + (cursor.*.h / 2.0);
        } else {
            var cursor_x: f32 = undefined;
            _ = &cursor_x;
            pixel = in.*.mouse.delta.x;
            delta = (pixel / scroll.*.w) * target;
            scroll_offset = if ((if ((scroll_offset + delta) < (target - scroll.*.w)) scroll_offset + delta else target - scroll.*.w) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else if ((scroll_offset + delta) < (target - scroll.*.w)) scroll_offset + delta else target - scroll.*.w;
            cursor_x = scroll.*.x + ((scroll_offset / target) * scroll.*.w);
            in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked_pos.x = cursor_x + (cursor.*.w / 2.0);
        }
    } else if ((((nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_SCROLL_UP))) != 0) and (o == @as(c_uint, @bitCast(NK_VERTICAL)))) and (has_scrolling != 0)) or (nk_button_behavior(&ws, empty0.*, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0)) {
        if (o == @as(c_uint, @bitCast(NK_VERTICAL))) {
            scroll_offset = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (scroll_offset - scroll.*.h)) scroll_offset - scroll.*.h else @as(f32, @floatFromInt(@as(c_int, 0)));
        } else {
            scroll_offset = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (scroll_offset - scroll.*.w)) scroll_offset - scroll.*.w else @as(f32, @floatFromInt(@as(c_int, 0)));
        }
    } else if ((((nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_SCROLL_DOWN))) != 0) and (o == @as(c_uint, @bitCast(NK_VERTICAL)))) and (has_scrolling != 0)) or (nk_button_behavior(&ws, empty1.*, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0)) {
        if (o == @as(c_uint, @bitCast(NK_VERTICAL))) {
            scroll_offset = if ((scroll_offset + scroll.*.h) < (target - scroll.*.h)) scroll_offset + scroll.*.h else target - scroll.*.h;
        } else {
            scroll_offset = if ((scroll_offset + scroll.*.w) < (target - scroll.*.w)) scroll_offset + scroll.*.w else target - scroll.*.w;
        }
    } else if (has_scrolling != 0) {
        if ((scroll_delta < @as(f32, @floatFromInt(@as(c_int, 0)))) or (scroll_delta > @as(f32, @floatFromInt(@as(c_int, 0))))) {
            scroll_offset = scroll_offset + (scroll_step * -scroll_delta);
            if (o == @as(c_uint, @bitCast(NK_VERTICAL))) {
                scroll_offset = if ((if (scroll_offset < (target - scroll.*.h)) scroll_offset else target - scroll.*.h) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else if (scroll_offset < (target - scroll.*.h)) scroll_offset else target - scroll.*.h;
            } else {
                scroll_offset = if ((if (scroll_offset < (target - scroll.*.w)) scroll_offset else target - scroll.*.w) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else if (scroll_offset < (target - scroll.*.w)) scroll_offset else target - scroll.*.w;
            }
        } else if (nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_SCROLL_START))) != 0) {
            if (o == @as(c_uint, @bitCast(NK_VERTICAL))) {
                scroll_offset = 0;
            }
        } else if (nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_SCROLL_END))) != 0) {
            if (o == @as(c_uint, @bitCast(NK_VERTICAL))) {
                scroll_offset = target - scroll.*.h;
            }
        }
    }
    if (((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) and !(nk_input_is_mouse_prev_hovering_rect(in, scroll.*) != 0)) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_ENTERED));
    } else if (nk_input_is_mouse_prev_hovering_rect(in, scroll.*) != 0) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_LEFT));
    }
    return scroll_offset;
}
pub fn nk_draw_scrollbar(arg_out: [*c]struct_nk_command_buffer, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_scrollbar, arg_bounds: [*c]const struct_nk_rect, arg_scroll: [*c]const struct_nk_rect) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var bounds = arg_bounds;
    _ = &bounds;
    var scroll = arg_scroll;
    _ = &scroll;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var cursor: [*c]const struct_nk_style_item = undefined;
    _ = &cursor;
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.active;
        cursor = &style.*.cursor_active;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.hover;
        cursor = &style.*.cursor_hover;
    } else {
        background = &style.*.normal;
        cursor = &style.*.cursor_normal;
    }
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(out, bounds.*, &background.*.data.image, nk_white);
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(out, bounds.*, &background.*.data.slice, nk_white);
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(out, bounds.*, style.*.rounding, background.*.data.color);
                nk_stroke_rect(out, bounds.*, style.*.rounding, style.*.border, style.*.border_color);
                break;
            },
            else => {},
        }
        break;
    }
    while (true) {
        switch (cursor.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(out, scroll.*, &cursor.*.data.image, nk_white);
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(out, scroll.*, &cursor.*.data.slice, nk_white);
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(out, scroll.*, style.*.rounding_cursor, cursor.*.data.color);
                nk_stroke_rect(out, scroll.*, style.*.rounding_cursor, style.*.border_cursor, style.*.cursor_border_color);
                break;
            },
            else => {},
        }
        break;
    }
}
pub fn nk_do_scrollbarv(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_scroll: struct_nk_rect, arg_has_scrolling: c_int, arg_offset: f32, arg_target: f32, arg_step: f32, arg_button_pixel_inc: f32, arg_style: [*c]const struct_nk_style_scrollbar, arg_in: [*c]struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) f32 {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var scroll = arg_scroll;
    _ = &scroll;
    var has_scrolling = arg_has_scrolling;
    _ = &has_scrolling;
    var offset = arg_offset;
    _ = &offset;
    var target = arg_target;
    _ = &target;
    var step = arg_step;
    _ = &step;
    var button_pixel_inc = arg_button_pixel_inc;
    _ = &button_pixel_inc;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var empty_north: struct_nk_rect = undefined;
    _ = &empty_north;
    var empty_south: struct_nk_rect = undefined;
    _ = &empty_south;
    var cursor: struct_nk_rect = undefined;
    _ = &cursor;
    var scroll_step: f32 = undefined;
    _ = &scroll_step;
    var scroll_offset: f32 = undefined;
    _ = &scroll_offset;
    var scroll_off: f32 = undefined;
    _ = &scroll_off;
    var scroll_ratio: f32 = undefined;
    _ = &scroll_ratio;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26616))), "float nk_do_scrollbarv(nk_flags *, struct nk_command_buffer *, struct nk_rect, int, float, float, float, float, const struct nk_style_scrollbar *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26617))), "float nk_do_scrollbarv(nk_flags *, struct nk_command_buffer *, struct nk_rect, int, float, float, float, float, const struct nk_style_scrollbar *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26618))), "float nk_do_scrollbarv(nk_flags *, struct nk_command_buffer *, struct nk_rect, int, float, float, float, float, const struct nk_style_scrollbar *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if (!(out != null) or !(style != null)) return 0;
    scroll.w = if (scroll.w < @as(f32, @floatFromInt(@as(c_int, 1)))) @as(f32, @floatFromInt(@as(c_int, 1))) else scroll.w;
    scroll.h = if (scroll.h < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else scroll.h;
    if (target <= scroll.h) return 0;
    if (style.*.show_buttons != 0) {
        var ws: nk_flags = undefined;
        _ = &ws;
        var scroll_h: f32 = undefined;
        _ = &scroll_h;
        var button: struct_nk_rect = undefined;
        _ = &button;
        button.x = scroll.x;
        button.w = scroll.w;
        button.h = scroll.w;
        scroll_h = if ((scroll.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * button.h)) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else scroll.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * button.h);
        scroll_step = if (step < button_pixel_inc) step else button_pixel_inc;
        button.y = scroll.y;
        if (nk_do_button_symbol(&ws, out, button, style.*.dec_symbol, @as(c_uint, @bitCast(NK_BUTTON_REPEATER)), &style.*.dec_button, in, font) != 0) {
            offset = offset - scroll_step;
        }
        button.y = (scroll.y + scroll.h) - button.h;
        if (nk_do_button_symbol(&ws, out, button, style.*.inc_symbol, @as(c_uint, @bitCast(NK_BUTTON_REPEATER)), &style.*.inc_button, in, font) != 0) {
            offset = offset + scroll_step;
        }
        scroll.y = scroll.y + button.h;
        scroll.h = scroll_h;
    }
    scroll_step = if (step < scroll.h) step else scroll.h;
    scroll_offset = if ((if (offset < (target - scroll.h)) offset else target - scroll.h) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else if (offset < (target - scroll.h)) offset else target - scroll.h;
    scroll_ratio = scroll.h / target;
    scroll_off = scroll_offset / target;
    cursor.h = if (((scroll_ratio * scroll.h) - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y))) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else (scroll_ratio * scroll.h) - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y));
    cursor.y = ((scroll.y + (scroll_off * scroll.h)) + style.*.border) + style.*.padding.y;
    cursor.w = scroll.w - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x));
    cursor.x = (scroll.x + style.*.border) + style.*.padding.x;
    empty_north.x = scroll.x;
    empty_north.y = scroll.y;
    empty_north.w = scroll.w;
    empty_north.h = if ((cursor.y - scroll.y) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else cursor.y - scroll.y;
    empty_south.x = scroll.x;
    empty_south.y = cursor.y + cursor.h;
    empty_south.w = scroll.w;
    empty_south.h = if (((scroll.y + scroll.h) - (cursor.y + cursor.h)) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else (scroll.y + scroll.h) - (cursor.y + cursor.h);
    scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, &scroll, &cursor, &empty_north, &empty_south, scroll_offset, target, scroll_step, @as(c_uint, @bitCast(NK_VERTICAL)));
    scroll_off = scroll_offset / target;
    cursor.y = ((scroll.y + (scroll_off * scroll.h)) + style.*.border_cursor) + style.*.padding.y;
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_scrollbar(out, state.*, style, &scroll, &cursor);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return scroll_offset;
}
pub fn nk_do_scrollbarh(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_scroll: struct_nk_rect, arg_has_scrolling: c_int, arg_offset: f32, arg_target: f32, arg_step: f32, arg_button_pixel_inc: f32, arg_style: [*c]const struct_nk_style_scrollbar, arg_in: [*c]struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) f32 {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var scroll = arg_scroll;
    _ = &scroll;
    var has_scrolling = arg_has_scrolling;
    _ = &has_scrolling;
    var offset = arg_offset;
    _ = &offset;
    var target = arg_target;
    _ = &target;
    var step = arg_step;
    _ = &step;
    var button_pixel_inc = arg_button_pixel_inc;
    _ = &button_pixel_inc;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var cursor: struct_nk_rect = undefined;
    _ = &cursor;
    var empty_west: struct_nk_rect = undefined;
    _ = &empty_west;
    var empty_east: struct_nk_rect = undefined;
    _ = &empty_east;
    var scroll_step: f32 = undefined;
    _ = &scroll_step;
    var scroll_offset: f32 = undefined;
    _ = &scroll_offset;
    var scroll_off: f32 = undefined;
    _ = &scroll_off;
    var scroll_ratio: f32 = undefined;
    _ = &scroll_ratio;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26705))), "float nk_do_scrollbarh(nk_flags *, struct nk_command_buffer *, struct nk_rect, int, float, float, float, float, const struct nk_style_scrollbar *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26706))), "float nk_do_scrollbarh(nk_flags *, struct nk_command_buffer *, struct nk_rect, int, float, float, float, float, const struct nk_style_scrollbar *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if (!(out != null) or !(style != null)) return 0;
    scroll.h = if (scroll.h < @as(f32, @floatFromInt(@as(c_int, 1)))) @as(f32, @floatFromInt(@as(c_int, 1))) else scroll.h;
    scroll.w = if (scroll.w < (@as(f32, @floatFromInt(@as(c_int, 2))) * scroll.h)) @as(f32, @floatFromInt(@as(c_int, 2))) * scroll.h else scroll.w;
    if (target <= scroll.w) return 0;
    if (style.*.show_buttons != 0) {
        var ws: nk_flags = undefined;
        _ = &ws;
        var scroll_w: f32 = undefined;
        _ = &scroll_w;
        var button: struct_nk_rect = undefined;
        _ = &button;
        button.y = scroll.y;
        button.w = scroll.h;
        button.h = scroll.h;
        scroll_w = scroll.w - (@as(f32, @floatFromInt(@as(c_int, 2))) * button.w);
        scroll_step = if (step < button_pixel_inc) step else button_pixel_inc;
        button.x = scroll.x;
        if (nk_do_button_symbol(&ws, out, button, style.*.dec_symbol, @as(c_uint, @bitCast(NK_BUTTON_REPEATER)), &style.*.dec_button, in, font) != 0) {
            offset = offset - scroll_step;
        }
        button.x = (scroll.x + scroll.w) - button.w;
        if (nk_do_button_symbol(&ws, out, button, style.*.inc_symbol, @as(c_uint, @bitCast(NK_BUTTON_REPEATER)), &style.*.inc_button, in, font) != 0) {
            offset = offset + scroll_step;
        }
        scroll.x = scroll.x + button.w;
        scroll.w = scroll_w;
    }
    scroll_step = if (step < scroll.w) step else scroll.w;
    scroll_offset = if ((if (offset < (target - scroll.w)) offset else target - scroll.w) < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else if (offset < (target - scroll.w)) offset else target - scroll.w;
    scroll_ratio = scroll.w / target;
    scroll_off = scroll_offset / target;
    cursor.w = (scroll_ratio * scroll.w) - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x));
    cursor.x = ((scroll.x + (scroll_off * scroll.w)) + style.*.border) + style.*.padding.x;
    cursor.h = scroll.h - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y));
    cursor.y = (scroll.y + style.*.border) + style.*.padding.y;
    empty_west.x = scroll.x;
    empty_west.y = scroll.y;
    empty_west.w = cursor.x - scroll.x;
    empty_west.h = scroll.h;
    empty_east.x = cursor.x + cursor.w;
    empty_east.y = scroll.y;
    empty_east.w = (scroll.x + scroll.w) - (cursor.x + cursor.w);
    empty_east.h = scroll.h;
    scroll_offset = nk_scrollbar_behavior(state, in, has_scrolling, &scroll, &cursor, &empty_west, &empty_east, scroll_offset, target, scroll_step, @as(c_uint, @bitCast(NK_HORIZONTAL)));
    scroll_off = scroll_offset / target;
    cursor.x = scroll.x + (scroll_off * scroll.w);
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_scrollbar(out, state.*, style, &scroll, &cursor);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return scroll_offset;
}
pub fn nk_draw_selectable(arg_out: [*c]struct_nk_command_buffer, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_selectable, arg_active: nk_bool, arg_bounds: [*c]const struct_nk_rect, arg_icon: [*c]const struct_nk_rect, arg_img: [*c]const struct_nk_image, arg_sym: enum_nk_symbol_type, arg_string: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_font: [*c]const struct_nk_user_font) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var active = arg_active;
    _ = &active;
    var bounds = arg_bounds;
    _ = &bounds;
    var icon = arg_icon;
    _ = &icon;
    var img = arg_img;
    _ = &img;
    var sym = arg_sym;
    _ = &sym;
    var string = arg_string;
    _ = &string;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var font = arg_font;
    _ = &font;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var text: struct_nk_text = undefined;
    _ = &text;
    text.padding = style.*.padding;
    if (!(active != 0)) {
        if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
            background = &style.*.pressed;
            text.text = style.*.text_pressed;
        } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
            background = &style.*.hover;
            text.text = style.*.text_hover;
        } else {
            background = &style.*.normal;
            text.text = style.*.text_normal;
        }
    } else {
        if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
            background = &style.*.pressed_active;
            text.text = style.*.text_pressed_active;
        } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
            background = &style.*.hover_active;
            text.text = style.*.text_hover_active;
        } else {
            background = &style.*.normal_active;
            text.text = style.*.text_normal_active;
        }
    }
    text.text = nk_rgb_factor(text.text, style.*.color_factor);
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_image(out, bounds.*, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_nine_slice(out, bounds.*, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                text.background = background.*.data.color;
                nk_fill_rect(out, bounds.*, style.*.rounding, background.*.data.color);
                break;
            },
            else => {},
        }
        break;
    }
    if (icon != null) {
        if (img != null) {
            nk_draw_image(out, icon.*, img, nk_rgb_factor(nk_white, style.*.color_factor));
        } else {
            nk_draw_symbol(out, sym, icon.*, text.background, text.text, @as(f32, @floatFromInt(@as(c_int, 1))), font);
        }
    }
    nk_widget_text(out, bounds.*, string, len, &text, @"align", font);
}
pub fn nk_do_selectable(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_value: [*c]nk_bool, arg_style: [*c]const struct_nk_style_selectable, arg_in: [*c]const struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var old_value: c_int = undefined;
    _ = &old_value;
    var touch: struct_nk_rect = undefined;
    _ = &touch;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25536))), "nk_bool nk_do_selectable(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25537))), "nk_bool nk_do_selectable(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25538))), "nk_bool nk_do_selectable(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len != 0) {} else {
                __assert_fail("len", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25539))), "nk_bool nk_do_selectable(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (value != null) {} else {
                __assert_fail("value", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25540))), "nk_bool nk_do_selectable(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25541))), "nk_bool nk_do_selectable(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25542))), "nk_bool nk_do_selectable(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if ((((((!(state != null) or !(out != null)) or !(str != null)) or !(len != 0)) or !(value != null)) or !(style != null)) or !(font != null)) return 0;
    old_value = value.*;
    touch.x = bounds.x - style.*.touch_padding.x;
    touch.y = bounds.y - style.*.touch_padding.y;
    touch.w = bounds.w + (style.*.touch_padding.x * @as(f32, @floatFromInt(@as(c_int, 2))));
    touch.h = bounds.h + (style.*.touch_padding.y * @as(f32, @floatFromInt(@as(c_int, 2))));
    if (nk_button_behavior(state, touch, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        value.* = @intFromBool(!(value.* != 0));
    }
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_selectable(out, state.*, style, value.*, &bounds, null, null, @as(c_uint, @bitCast(NK_SYMBOL_NONE)), str, len, @"align", font);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return @intFromBool(old_value != value.*);
}
pub fn nk_do_selectable_image(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_value: [*c]nk_bool, arg_img: [*c]const struct_nk_image, arg_style: [*c]const struct_nk_style_selectable, arg_in: [*c]const struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    var img = arg_img;
    _ = &img;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var old_value: nk_bool = undefined;
    _ = &old_value;
    var touch: struct_nk_rect = undefined;
    _ = &touch;
    var icon: struct_nk_rect = undefined;
    _ = &icon;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25573))), "nk_bool nk_do_selectable_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_image *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25574))), "nk_bool nk_do_selectable_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_image *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25575))), "nk_bool nk_do_selectable_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_image *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len != 0) {} else {
                __assert_fail("len", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25576))), "nk_bool nk_do_selectable_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_image *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (value != null) {} else {
                __assert_fail("value", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25577))), "nk_bool nk_do_selectable_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_image *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25578))), "nk_bool nk_do_selectable_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_image *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25579))), "nk_bool nk_do_selectable_image(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, const struct nk_image *, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if ((((((!(state != null) or !(out != null)) or !(str != null)) or !(len != 0)) or !(value != null)) or !(style != null)) or !(font != null)) return 0;
    old_value = value.*;
    touch.x = bounds.x - style.*.touch_padding.x;
    touch.y = bounds.y - style.*.touch_padding.y;
    touch.w = bounds.w + (style.*.touch_padding.x * @as(f32, @floatFromInt(@as(c_int, 2))));
    touch.h = bounds.h + (style.*.touch_padding.y * @as(f32, @floatFromInt(@as(c_int, 2))));
    if (nk_button_behavior(state, touch, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        value.* = @intFromBool(!(value.* != 0));
    }
    icon.y = bounds.y + style.*.padding.y;
    icon.w = blk: {
        const tmp = bounds.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y);
        icon.h = tmp;
        break :blk tmp;
    };
    if ((@"align" & @as(nk_flags, @bitCast(NK_TEXT_ALIGN_LEFT))) != 0) {
        icon.x = (bounds.x + bounds.w) - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) + icon.w);
        icon.x = if (icon.x < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else icon.x;
    } else {
        icon.x = bounds.x + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x);
    }
    icon.x += style.*.image_padding.x;
    icon.y += style.*.image_padding.y;
    icon.w -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.image_padding.x;
    icon.h -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.image_padding.y;
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_selectable(out, state.*, style, value.*, &bounds, &icon, img, @as(c_uint, @bitCast(NK_SYMBOL_NONE)), str, len, @"align", font);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return @intFromBool(old_value != value.*);
}
pub fn nk_edit_draw_text(arg_out: [*c]struct_nk_command_buffer, arg_style: [*c]const struct_nk_style_edit, arg_pos_x: f32, arg_pos_y: f32, arg_x_offset: f32, arg_text: [*c]const u8, arg_byte_len: c_int, arg_row_height: f32, arg_font: [*c]const struct_nk_user_font, arg_background: struct_nk_color, arg_foreground: struct_nk_color, arg_is_selected: nk_bool) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var style = arg_style;
    _ = &style;
    var pos_x = arg_pos_x;
    _ = &pos_x;
    var pos_y = arg_pos_y;
    _ = &pos_y;
    var x_offset = arg_x_offset;
    _ = &x_offset;
    var text = arg_text;
    _ = &text;
    var byte_len = arg_byte_len;
    _ = &byte_len;
    var row_height = arg_row_height;
    _ = &row_height;
    var font = arg_font;
    _ = &font;
    var background = arg_background;
    _ = &background;
    var foreground = arg_foreground;
    _ = &foreground;
    var is_selected = arg_is_selected;
    _ = &is_selected;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27896))), "void nk_edit_draw_text(struct nk_command_buffer *, const struct nk_style_edit *, float, float, float, const char *, int, float, const struct nk_user_font *, struct nk_color, struct nk_color, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27897))), "void nk_edit_draw_text(struct nk_command_buffer *, const struct nk_style_edit *, float, float, float, const char *, int, float, const struct nk_user_font *, struct nk_color, struct nk_color, nk_bool)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27898))), "void nk_edit_draw_text(struct nk_command_buffer *, const struct nk_style_edit *, float, float, float, const char *, int, float, const struct nk_user_font *, struct nk_color, struct nk_color, nk_bool)");
            };
        };
    };
    if (((!(text != null) or !(byte_len != 0)) or !(out != null)) or !(style != null)) return;
    {
        var glyph_len: c_int = 0;
        _ = &glyph_len;
        var unicode: nk_rune = 0;
        _ = &unicode;
        var text_len: c_int = 0;
        _ = &text_len;
        var line_width: f32 = 0;
        _ = &line_width;
        var glyph_width: f32 = undefined;
        _ = &glyph_width;
        var line: [*c]const u8 = text;
        _ = &line;
        var line_offset: f32 = 0;
        _ = &line_offset;
        var line_count: c_int = 0;
        _ = &line_count;
        var txt: struct_nk_text = undefined;
        _ = &txt;
        txt.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
        txt.background = background;
        txt.text = foreground;
        foreground = nk_rgb_factor(foreground, style.*.color_factor);
        background = nk_rgb_factor(background, style.*.color_factor);
        glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), &unicode, byte_len - text_len);
        if (!(glyph_len != 0)) return;
        while ((text_len < byte_len) and (glyph_len != 0)) {
            if (unicode == @as(nk_rune, @bitCast(@as(c_int, '\n')))) {
                var label: struct_nk_rect = undefined;
                _ = &label;
                label.y = pos_y + line_offset;
                label.h = row_height;
                label.w = line_width;
                label.x = pos_x;
                if (!(line_count != 0)) {
                    label.x += x_offset;
                }
                if (is_selected != 0) {
                    nk_fill_rect(out, label, @as(f32, @floatFromInt(@as(c_int, 0))), background);
                }
                nk_widget_text(out, label, line, @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(text + @as(usize, @bitCast(@as(isize, @intCast(text_len))))) -% @intFromPtr(line))), @sizeOf(u8)))))), &txt, @as(nk_flags, @bitCast(NK_TEXT_CENTERED)), font);
                text_len += 1;
                line_count += 1;
                line_width = 0;
                line = text + @as(usize, @bitCast(@as(isize, @intCast(text_len))));
                line_offset += row_height;
                glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), &unicode, byte_len - text_len);
                continue;
            }
            if (unicode == @as(nk_rune, @bitCast(@as(c_int, '\r')))) {
                text_len += 1;
                glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), &unicode, byte_len - text_len);
                continue;
            }
            glyph_width = font.*.width.?(font.*.userdata, font.*.height, text + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), glyph_len);
            line_width += glyph_width;
            text_len += glyph_len;
            glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), &unicode, byte_len - text_len);
            continue;
        }
        if (line_width > @as(f32, @floatFromInt(@as(c_int, 0)))) {
            var label: struct_nk_rect = undefined;
            _ = &label;
            label.y = pos_y + line_offset;
            label.h = row_height;
            label.w = line_width;
            label.x = pos_x;
            if (!(line_count != 0)) {
                label.x += x_offset;
            }
            if (is_selected != 0) {
                nk_fill_rect(out, label, @as(f32, @floatFromInt(@as(c_int, 0))), background);
            }
            nk_widget_text(out, label, line, @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(text + @as(usize, @bitCast(@as(isize, @intCast(text_len))))) -% @intFromPtr(line))), @sizeOf(u8)))))), &txt, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), font);
        }
    }
}
pub fn nk_do_edit(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_flags: nk_flags, arg_filter: nk_plugin_filter, arg_edit: [*c]struct_nk_text_edit, arg_style: [*c]const struct_nk_style_edit, arg_in: [*c]struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_flags {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var flags = arg_flags;
    _ = &flags;
    var filter = arg_filter;
    _ = &filter;
    var edit = arg_edit;
    _ = &edit;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var area: struct_nk_rect = undefined;
    _ = &area;
    var ret: nk_flags = 0;
    _ = &ret;
    var row_height: f32 = undefined;
    _ = &row_height;
    var prev_state: u8 = 0;
    _ = &prev_state;
    var is_hovered: u8 = 0;
    _ = &is_hovered;
    var select_all: u8 = 0;
    _ = &select_all;
    var cursor_follow: u8 = 0;
    _ = &cursor_follow;
    var old_clip: struct_nk_rect = undefined;
    _ = &old_clip;
    var clip: struct_nk_rect = undefined;
    _ = &clip;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27988))), "nk_flags nk_do_edit(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_flags, nk_plugin_filter, struct nk_text_edit *, const struct nk_style_edit *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27989))), "nk_flags nk_do_edit(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_flags, nk_plugin_filter, struct nk_text_edit *, const struct nk_style_edit *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 27990))), "nk_flags nk_do_edit(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_flags, nk_plugin_filter, struct nk_text_edit *, const struct nk_style_edit *, struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if ((!(state != null) or !(out != null)) or !(style != null)) return ret;
    area.x = (bounds.x + style.*.padding.x) + style.*.border;
    area.y = (bounds.y + style.*.padding.y) + style.*.border;
    area.w = bounds.w - ((2.0 * style.*.padding.x) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border));
    area.h = bounds.h - ((2.0 * style.*.padding.y) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border));
    if ((flags & @as(nk_flags, @bitCast(NK_EDIT_MULTILINE))) != 0) {
        area.w = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (area.w - style.*.scrollbar_size.x)) area.w - style.*.scrollbar_size.x else @as(f32, @floatFromInt(@as(c_int, 0)));
    }
    row_height = if ((flags & @as(nk_flags, @bitCast(NK_EDIT_MULTILINE))) != 0) font.*.height + style.*.row_padding else area.h;
    old_clip = out.*.clip;
    nk_unify(&clip, &old_clip, area.x, area.y, area.x + area.w, area.y + area.h);
    prev_state = @as(u8, @bitCast(edit.*.active));
    if (((in != null) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked != 0)) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0)) {
        edit.*.active = @as(u8, @intFromBool(((bounds.x <= in.*.mouse.pos.x) and (in.*.mouse.pos.x < (bounds.x + bounds.w))) and ((bounds.y <= in.*.mouse.pos.y) and (in.*.mouse.pos.y < (bounds.y + bounds.h)))));
    }
    if (!(prev_state != 0) and (@as(c_int, @bitCast(@as(c_uint, edit.*.active))) != 0)) {
        const @"type": enum_nk_text_edit_type = @as(c_uint, @bitCast(if ((flags & @as(nk_flags, @bitCast(NK_EDIT_MULTILINE))) != 0) NK_TEXT_EDIT_MULTI_LINE else NK_TEXT_EDIT_SINGLE_LINE));
        _ = &@"type";
        var oldscrollbar: struct_nk_vec2 = edit.*.scrollbar;
        _ = &oldscrollbar;
        nk_textedit_clear_state(edit, @"type", filter);
        edit.*.scrollbar = oldscrollbar;
        if ((flags & @as(nk_flags, @bitCast(NK_EDIT_AUTO_SELECT))) != 0) {
            select_all = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
        }
        if ((flags & @as(nk_flags, @bitCast(NK_EDIT_GOTO_END_ON_ACTIVATE))) != 0) {
            edit.*.cursor = edit.*.string.len;
            in = null;
        }
    } else if (!(edit.*.active != 0)) {
        edit.*.mode = @as(u8, @bitCast(@as(i8, @truncate(NK_TEXT_EDIT_MODE_VIEW))));
    }
    if ((flags & @as(nk_flags, @bitCast(NK_EDIT_READ_ONLY))) != 0) {
        edit.*.mode = @as(u8, @bitCast(@as(i8, @truncate(NK_TEXT_EDIT_MODE_VIEW))));
    } else if ((flags & @as(nk_flags, @bitCast(NK_EDIT_ALWAYS_INSERT_MODE))) != 0) {
        edit.*.mode = @as(u8, @bitCast(@as(i8, @truncate(NK_TEXT_EDIT_MODE_INSERT))));
    }
    ret = @as(nk_flags, @bitCast(if (@as(c_int, @bitCast(@as(c_uint, edit.*.active))) != 0) NK_EDIT_ACTIVE else NK_EDIT_INACTIVE));
    if (@as(c_int, @bitCast(@as(c_uint, prev_state))) != @as(c_int, @bitCast(@as(c_uint, edit.*.active)))) {
        ret |= @as(nk_flags, @bitCast(if (@as(c_int, @bitCast(@as(c_uint, edit.*.active))) != 0) NK_EDIT_ACTIVATED else NK_EDIT_DEACTIVATED));
    }
    if ((@as(c_int, @bitCast(@as(c_uint, edit.*.active))) != 0) and (in != null)) {
        var shift_mod: c_int = in.*.keyboard.keys[@as(c_uint, @intCast(NK_KEY_SHIFT))].down;
        _ = &shift_mod;
        const mouse_x: f32 = (in.*.mouse.pos.x - area.x) + edit.*.scrollbar.x;
        _ = &mouse_x;
        const mouse_y: f32 = (in.*.mouse.pos.y - area.y) + edit.*.scrollbar.y;
        _ = &mouse_y;
        is_hovered = @as(u8, @bitCast(@as(i8, @truncate(nk_input_is_mouse_hovering_rect(in, area)))));
        if (select_all != 0) {
            nk_textedit_select_all(edit);
        } else if (((@as(c_int, @bitCast(@as(c_uint, is_hovered))) != 0) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0)) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked != 0)) {
            nk_textedit_click(edit, mouse_x, mouse_y, font, row_height);
        } else if (((@as(c_int, @bitCast(@as(c_uint, is_hovered))) != 0) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0)) and ((in.*.mouse.delta.x != 0.0) or (in.*.mouse.delta.y != 0.0))) {
            nk_textedit_drag(edit, mouse_x, mouse_y, font, row_height);
            cursor_follow = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
        } else if (((@as(c_int, @bitCast(@as(c_uint, is_hovered))) != 0) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_RIGHT))].clicked != 0)) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_RIGHT))].down != 0)) {
            nk_textedit_key(edit, @as(c_uint, @bitCast(NK_KEY_TEXT_WORD_LEFT)), nk_false, font, row_height);
            nk_textedit_key(edit, @as(c_uint, @bitCast(NK_KEY_TEXT_WORD_RIGHT)), nk_true, font, row_height);
            cursor_follow = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
        }
        {
            var i: c_int = undefined;
            _ = &i;
            var old_mode: c_int = @as(c_int, @bitCast(@as(c_uint, edit.*.mode)));
            _ = &old_mode;
            {
                i = 0;
                while (i < NK_KEY_MAX) : (i += 1) {
                    if ((i == NK_KEY_ENTER) or (i == NK_KEY_TAB)) continue;
                    if (nk_input_is_key_pressed(in, @as(c_uint, @bitCast(i))) != 0) {
                        nk_textedit_key(edit, @as(c_uint, @bitCast(i)), shift_mod, font, row_height);
                        cursor_follow = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
                    }
                }
            }
            if (old_mode != @as(c_int, @bitCast(@as(c_uint, edit.*.mode)))) {
                in.*.keyboard.text_len = 0;
            }
        }
        edit.*.filter = filter;
        if (in.*.keyboard.text_len != 0) {
            nk_textedit_text(edit, @as([*c]u8, @ptrCast(@alignCast(&in.*.keyboard.text))), in.*.keyboard.text_len);
            cursor_follow = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
            in.*.keyboard.text_len = 0;
        }
        if (nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_ENTER))) != 0) {
            cursor_follow = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
            if (((flags & @as(nk_flags, @bitCast(NK_EDIT_CTRL_ENTER_NEWLINE))) != 0) and (shift_mod != 0)) {
                nk_textedit_text(edit, "\n", @as(c_int, 1));
            } else if ((flags & @as(nk_flags, @bitCast(NK_EDIT_SIG_ENTER))) != 0) {
                ret |= @as(nk_flags, @bitCast(NK_EDIT_COMMITED));
            } else {
                nk_textedit_text(edit, "\n", @as(c_int, 1));
            }
        }
        {
            var copy: c_int = nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_COPY)));
            _ = &copy;
            var cut: c_int = nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_CUT)));
            _ = &cut;
            if (((copy != 0) or (cut != 0)) and ((flags & @as(nk_flags, @bitCast(NK_EDIT_CLIPBOARD))) != 0)) {
                var glyph_len: c_int = undefined;
                _ = &glyph_len;
                var unicode: nk_rune = undefined;
                _ = &unicode;
                var text: [*c]const u8 = undefined;
                _ = &text;
                var b: c_int = edit.*.select_start;
                _ = &b;
                var e: c_int = edit.*.select_end;
                _ = &e;
                var begin: c_int = if (b < e) b else e;
                _ = &begin;
                var end: c_int = if (b < e) e else b;
                _ = &end;
                text = nk_str_at_const(&edit.*.string, begin, &unicode, &glyph_len);
                if (edit.*.clip.copy != null) {
                    edit.*.clip.copy.?(edit.*.clip.userdata, text, end - begin);
                }
                if ((cut != 0) and !((flags & @as(nk_flags, @bitCast(NK_EDIT_READ_ONLY))) != 0)) {
                    _ = nk_textedit_cut(edit);
                    cursor_follow = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
                }
            }
        }
        {
            var paste: c_int = nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_PASTE)));
            _ = &paste;
            if (((paste != 0) and ((flags & @as(nk_flags, @bitCast(NK_EDIT_CLIPBOARD))) != 0)) and (edit.*.clip.paste != null)) {
                edit.*.clip.paste.?(edit.*.clip.userdata, edit);
                cursor_follow = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
            }
        }
        {
            var tab: c_int = nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_TAB)));
            _ = &tab;
            if ((tab != 0) and ((flags & @as(nk_flags, @bitCast(NK_EDIT_ALLOW_TAB))) != 0)) {
                nk_textedit_text(edit, "    ", @as(c_int, 4));
                cursor_follow = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
            }
        }
    }
    if (edit.*.active != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
    } else if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    if (is_hovered != 0) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVERED));
    }
    {
        var text: [*c]const u8 = nk_str_get_const(&edit.*.string);
        _ = &text;
        var len: c_int = nk_str_len_char(&edit.*.string);
        _ = &len;
        {
            var background: [*c]const struct_nk_style_item = undefined;
            _ = &background;
            if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
                background = &style.*.active;
            } else if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
                background = &style.*.hover;
            } else {
                background = &style.*.normal;
            }
            while (true) {
                switch (background.*.type) {
                    @as(c_uint, @bitCast(@as(c_int, 1))) => {
                        nk_draw_image(out, bounds, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 2))) => {
                        nk_draw_nine_slice(out, bounds, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.color_factor));
                        break;
                    },
                    @as(c_uint, @bitCast(@as(c_int, 0))) => {
                        nk_fill_rect(out, bounds, style.*.rounding, nk_rgb_factor(background.*.data.color, style.*.color_factor));
                        nk_stroke_rect(out, bounds, style.*.rounding, style.*.border, nk_rgb_factor(style.*.border_color, style.*.color_factor));
                        break;
                    },
                    else => {},
                }
                break;
            }
        }
        area.w = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (area.w - style.*.cursor_size)) area.w - style.*.cursor_size else @as(f32, @floatFromInt(@as(c_int, 0)));
        if (edit.*.active != 0) {
            var total_lines: c_int = 1;
            _ = &total_lines;
            var text_size: struct_nk_vec2 = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
            _ = &text_size;
            var cursor_ptr: [*c]const u8 = null;
            _ = &cursor_ptr;
            var select_begin_ptr: [*c]const u8 = null;
            _ = &select_begin_ptr;
            var select_end_ptr: [*c]const u8 = null;
            _ = &select_end_ptr;
            var cursor_pos: struct_nk_vec2 = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
            _ = &cursor_pos;
            var selection_offset_start: struct_nk_vec2 = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
            _ = &selection_offset_start;
            var selection_offset_end: struct_nk_vec2 = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
            _ = &selection_offset_end;
            var selection_begin: c_int = if (edit.*.select_start < edit.*.select_end) edit.*.select_start else edit.*.select_end;
            _ = &selection_begin;
            var selection_end: c_int = if (edit.*.select_start < edit.*.select_end) edit.*.select_end else edit.*.select_start;
            _ = &selection_end;
            var line_width: f32 = 0.0;
            _ = &line_width;
            if ((text != null) and (len != 0)) {
                var glyph_width: f32 = undefined;
                _ = &glyph_width;
                var glyph_len: c_int = 0;
                _ = &glyph_len;
                var unicode: nk_rune = 0;
                _ = &unicode;
                var text_len: c_int = 0;
                _ = &text_len;
                var glyphs: c_int = 0;
                _ = &glyphs;
                var row_begin: c_int = 0;
                _ = &row_begin;
                glyph_len = nk_utf_decode(text, &unicode, len);
                glyph_width = font.*.width.?(font.*.userdata, font.*.height, text, glyph_len);
                line_width = 0;
                while ((text_len < len) and (glyph_len != 0)) {
                    if (!(cursor_ptr != null) and (glyphs == edit.*.cursor)) {
                        var glyph_offset: c_int = undefined;
                        _ = &glyph_offset;
                        var out_offset: struct_nk_vec2 = undefined;
                        _ = &out_offset;
                        var row_size: struct_nk_vec2 = undefined;
                        _ = &row_size;
                        var remaining: [*c]const u8 = undefined;
                        _ = &remaining;
                        cursor_pos.y = @as(f32, @floatFromInt(total_lines - @as(c_int, 1))) * row_height;
                        row_size = nk_text_calculate_text_bounds(font, text + @as(usize, @bitCast(@as(isize, @intCast(row_begin)))), text_len - row_begin, row_height, &remaining, &out_offset, &glyph_offset, NK_STOP_ON_NEW_LINE);
                        cursor_pos.x = row_size.x;
                        cursor_ptr = text + @as(usize, @bitCast(@as(isize, @intCast(text_len))));
                    }
                    if ((!(select_begin_ptr != null) and (edit.*.select_start != edit.*.select_end)) and (glyphs == selection_begin)) {
                        var glyph_offset: c_int = undefined;
                        _ = &glyph_offset;
                        var out_offset: struct_nk_vec2 = undefined;
                        _ = &out_offset;
                        var row_size: struct_nk_vec2 = undefined;
                        _ = &row_size;
                        var remaining: [*c]const u8 = undefined;
                        _ = &remaining;
                        selection_offset_start.y = @as(f32, @floatFromInt(if ((total_lines - @as(c_int, 1)) < @as(c_int, 0)) @as(c_int, 0) else total_lines - @as(c_int, 1))) * row_height;
                        row_size = nk_text_calculate_text_bounds(font, text + @as(usize, @bitCast(@as(isize, @intCast(row_begin)))), text_len - row_begin, row_height, &remaining, &out_offset, &glyph_offset, NK_STOP_ON_NEW_LINE);
                        selection_offset_start.x = row_size.x;
                        select_begin_ptr = text + @as(usize, @bitCast(@as(isize, @intCast(text_len))));
                    }
                    if ((!(select_end_ptr != null) and (edit.*.select_start != edit.*.select_end)) and (glyphs == selection_end)) {
                        var glyph_offset: c_int = undefined;
                        _ = &glyph_offset;
                        var out_offset: struct_nk_vec2 = undefined;
                        _ = &out_offset;
                        var row_size: struct_nk_vec2 = undefined;
                        _ = &row_size;
                        var remaining: [*c]const u8 = undefined;
                        _ = &remaining;
                        selection_offset_end.y = @as(f32, @floatFromInt(total_lines - @as(c_int, 1))) * row_height;
                        row_size = nk_text_calculate_text_bounds(font, text + @as(usize, @bitCast(@as(isize, @intCast(row_begin)))), text_len - row_begin, row_height, &remaining, &out_offset, &glyph_offset, NK_STOP_ON_NEW_LINE);
                        selection_offset_end.x = row_size.x;
                        select_end_ptr = text + @as(usize, @bitCast(@as(isize, @intCast(text_len))));
                    }
                    if (unicode == @as(nk_rune, @bitCast(@as(c_int, '\n')))) {
                        text_size.x = if (text_size.x < line_width) line_width else text_size.x;
                        total_lines += 1;
                        line_width = 0;
                        text_len += 1;
                        glyphs += 1;
                        row_begin = text_len;
                        glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), &unicode, len - text_len);
                        glyph_width = font.*.width.?(font.*.userdata, font.*.height, text + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), glyph_len);
                        continue;
                    }
                    glyphs += 1;
                    text_len += glyph_len;
                    line_width += glyph_width;
                    glyph_len = nk_utf_decode(text + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), &unicode, len - text_len);
                    glyph_width = font.*.width.?(font.*.userdata, font.*.height, text + @as(usize, @bitCast(@as(isize, @intCast(text_len)))), glyph_len);
                    continue;
                }
                text_size.y = @as(f32, @floatFromInt(total_lines)) * row_height;
                if (!(cursor_ptr != null) and (edit.*.cursor == edit.*.string.len)) {
                    cursor_pos.x = line_width;
                    cursor_pos.y = text_size.y - row_height;
                }
            }
            {
                if (cursor_follow != 0) {
                    if (!((flags & @as(nk_flags, @bitCast(NK_EDIT_NO_HORIZONTAL_SCROLL))) != 0)) {
                        const scroll_increment: f32 = area.w * 0.25;
                        _ = &scroll_increment;
                        if (cursor_pos.x < edit.*.scrollbar.x) {
                            edit.*.scrollbar.x = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(if (0.0 < (cursor_pos.x - scroll_increment)) cursor_pos.x - scroll_increment else 0.0))));
                        }
                        if (cursor_pos.x >= (edit.*.scrollbar.x + area.w)) {
                            edit.*.scrollbar.x = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(if (0.0 < ((cursor_pos.x - area.w) + scroll_increment)) (cursor_pos.x - area.w) + scroll_increment else 0.0))));
                        }
                    } else {
                        edit.*.scrollbar.x = 0;
                    }
                    if ((flags & @as(nk_flags, @bitCast(NK_EDIT_MULTILINE))) != 0) {
                        if (cursor_pos.y < edit.*.scrollbar.y) {
                            edit.*.scrollbar.y = if (0.0 < cursor_pos.y) cursor_pos.y else 0.0;
                        }
                        if (cursor_pos.y > ((edit.*.scrollbar.y + area.h) - row_height)) {
                            edit.*.scrollbar.y = edit.*.scrollbar.y + row_height;
                        }
                    } else {
                        edit.*.scrollbar.y = 0;
                    }
                }
                if ((flags & @as(nk_flags, @bitCast(NK_EDIT_MULTILINE))) != 0) {
                    var ws: nk_flags = undefined;
                    _ = &ws;
                    var scroll: struct_nk_rect = undefined;
                    _ = &scroll;
                    var scroll_target: f32 = undefined;
                    _ = &scroll_target;
                    var scroll_offset: f32 = undefined;
                    _ = &scroll_offset;
                    var scroll_step: f32 = undefined;
                    _ = &scroll_step;
                    var scroll_inc: f32 = undefined;
                    _ = &scroll_inc;
                    scroll = area;
                    scroll.x = ((bounds.x + bounds.w) - style.*.border) - style.*.scrollbar_size.x;
                    scroll.w = style.*.scrollbar_size.x;
                    scroll_offset = edit.*.scrollbar.y;
                    scroll_step = scroll.h * 0.10000000149011612;
                    scroll_inc = scroll.h * 0.009999999776482582;
                    scroll_target = text_size.y;
                    edit.*.scrollbar.y = nk_do_scrollbarv(&ws, out, scroll, @as(c_int, @bitCast(@as(c_uint, is_hovered))), scroll_offset, scroll_target, scroll_step, scroll_inc, &style.*.scrollbar, in, font);
                    if ((@as(c_int, @bitCast(@as(c_uint, is_hovered))) != 0) and (in.*.mouse.scroll_delta.y != 0)) {
                        in.*.mouse.scroll_delta.y = 0;
                    }
                }
            }
            {
                var background_color: struct_nk_color = undefined;
                _ = &background_color;
                var text_color: struct_nk_color = undefined;
                _ = &text_color;
                var sel_background_color: struct_nk_color = undefined;
                _ = &sel_background_color;
                var sel_text_color: struct_nk_color = undefined;
                _ = &sel_text_color;
                var cursor_color: struct_nk_color = undefined;
                _ = &cursor_color;
                var cursor_text_color: struct_nk_color = undefined;
                _ = &cursor_text_color;
                var background: [*c]const struct_nk_style_item = undefined;
                _ = &background;
                nk_push_scissor(out, clip);
                if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
                    background = &style.*.active;
                    text_color = style.*.text_active;
                    sel_text_color = style.*.selected_text_hover;
                    sel_background_color = style.*.selected_hover;
                    cursor_color = style.*.cursor_hover;
                    cursor_text_color = style.*.cursor_text_hover;
                } else if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
                    background = &style.*.hover;
                    text_color = style.*.text_hover;
                    sel_text_color = style.*.selected_text_hover;
                    sel_background_color = style.*.selected_hover;
                    cursor_text_color = style.*.cursor_text_hover;
                    cursor_color = style.*.cursor_hover;
                } else {
                    background = &style.*.normal;
                    text_color = style.*.text_normal;
                    sel_text_color = style.*.selected_text_normal;
                    sel_background_color = style.*.selected_normal;
                    cursor_color = style.*.cursor_normal;
                    cursor_text_color = style.*.cursor_text_normal;
                }
                if (background.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_IMAGE))) {
                    background_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                } else {
                    background_color = background.*.data.color;
                }
                cursor_color = nk_rgb_factor(cursor_color, style.*.color_factor);
                cursor_text_color = nk_rgb_factor(cursor_text_color, style.*.color_factor);
                if (edit.*.select_start == edit.*.select_end) {
                    var begin: [*c]const u8 = nk_str_get_const(&edit.*.string);
                    _ = &begin;
                    var l: c_int = nk_str_len_char(&edit.*.string);
                    _ = &l;
                    nk_edit_draw_text(out, style, area.x - edit.*.scrollbar.x, area.y - edit.*.scrollbar.y, @as(f32, @floatFromInt(@as(c_int, 0))), begin, l, row_height, font, background_color, text_color, nk_false);
                } else {
                    if ((edit.*.select_start != edit.*.select_end) and (selection_begin > @as(c_int, 0))) {
                        var begin: [*c]const u8 = nk_str_get_const(&edit.*.string);
                        _ = &begin;
                        _ = blk: {
                            _ = @sizeOf(c_int);
                            break :blk blk_1: {
                                break :blk_1 if (select_begin_ptr != null) {} else {
                                    __assert_fail("select_begin_ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28391))), "nk_flags nk_do_edit(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_flags, nk_plugin_filter, struct nk_text_edit *, const struct nk_style_edit *, struct nk_input *, const struct nk_user_font *)");
                                };
                            };
                        };
                        nk_edit_draw_text(out, style, area.x - edit.*.scrollbar.x, area.y - edit.*.scrollbar.y, @as(f32, @floatFromInt(@as(c_int, 0))), begin, @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(select_begin_ptr) -% @intFromPtr(begin))), @sizeOf(u8)))))), row_height, font, background_color, text_color, nk_false);
                    }
                    if (edit.*.select_start != edit.*.select_end) {
                        _ = blk: {
                            _ = @sizeOf(c_int);
                            break :blk blk_1: {
                                break :blk_1 if (select_begin_ptr != null) {} else {
                                    __assert_fail("select_begin_ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28398))), "nk_flags nk_do_edit(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_flags, nk_plugin_filter, struct nk_text_edit *, const struct nk_style_edit *, struct nk_input *, const struct nk_user_font *)");
                                };
                            };
                        };
                        if (!(select_end_ptr != null)) {
                            var begin: [*c]const u8 = nk_str_get_const(&edit.*.string);
                            _ = &begin;
                            select_end_ptr = begin + @as(usize, @bitCast(@as(isize, @intCast(nk_str_len_char(&edit.*.string)))));
                        }
                        nk_edit_draw_text(out, style, area.x - edit.*.scrollbar.x, (area.y + selection_offset_start.y) - edit.*.scrollbar.y, selection_offset_start.x, select_begin_ptr, @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(select_end_ptr) -% @intFromPtr(select_begin_ptr))), @sizeOf(u8)))))), row_height, font, sel_background_color, sel_text_color, nk_true);
                    }
                    if ((edit.*.select_start != edit.*.select_end) and (selection_end < edit.*.string.len)) {
                        var begin: [*c]const u8 = select_end_ptr;
                        _ = &begin;
                        var end: [*c]const u8 = nk_str_get_const(&edit.*.string) + @as(usize, @bitCast(@as(isize, @intCast(nk_str_len_char(&edit.*.string)))));
                        _ = &end;
                        _ = blk: {
                            _ = @sizeOf(c_int);
                            break :blk blk_1: {
                                break :blk_1 if (select_end_ptr != null) {} else {
                                    __assert_fail("select_end_ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28417))), "nk_flags nk_do_edit(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_flags, nk_plugin_filter, struct nk_text_edit *, const struct nk_style_edit *, struct nk_input *, const struct nk_user_font *)");
                                };
                            };
                        };
                        nk_edit_draw_text(out, style, area.x - edit.*.scrollbar.x, (area.y + selection_offset_end.y) - edit.*.scrollbar.y, selection_offset_end.x, begin, @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(end) -% @intFromPtr(begin))), @sizeOf(u8)))))), row_height, font, background_color, text_color, nk_true);
                    }
                }
                if (edit.*.select_start == edit.*.select_end) {
                    if ((edit.*.cursor >= nk_str_len(&edit.*.string)) or ((cursor_ptr != null) and (@as(c_int, @bitCast(@as(c_uint, cursor_ptr.*))) == @as(c_int, '\n')))) {
                        var cursor: struct_nk_rect = undefined;
                        _ = &cursor;
                        cursor.w = style.*.cursor_size;
                        cursor.h = font.*.height;
                        cursor.x = (area.x + cursor_pos.x) - edit.*.scrollbar.x;
                        cursor.y = ((area.y + cursor_pos.y) + (row_height / 2.0)) - (cursor.h / 2.0);
                        cursor.y -= edit.*.scrollbar.y;
                        nk_fill_rect(out, cursor, @as(f32, @floatFromInt(@as(c_int, 0))), cursor_color);
                    } else {
                        var glyph_len: c_int = undefined;
                        _ = &glyph_len;
                        var label: struct_nk_rect = undefined;
                        _ = &label;
                        var txt: struct_nk_text = undefined;
                        _ = &txt;
                        var unicode: nk_rune = undefined;
                        _ = &unicode;
                        _ = blk: {
                            _ = @sizeOf(c_int);
                            break :blk blk_1: {
                                break :blk_1 if (cursor_ptr != null) {} else {
                                    __assert_fail("cursor_ptr", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 28447))), "nk_flags nk_do_edit(nk_flags *, struct nk_command_buffer *, struct nk_rect, nk_flags, nk_plugin_filter, struct nk_text_edit *, const struct nk_style_edit *, struct nk_input *, const struct nk_user_font *)");
                                };
                            };
                        };
                        glyph_len = nk_utf_decode(cursor_ptr, &unicode, @as(c_int, 4));
                        label.x = (area.x + cursor_pos.x) - edit.*.scrollbar.x;
                        label.y = (area.y + cursor_pos.y) - edit.*.scrollbar.y;
                        label.w = font.*.width.?(font.*.userdata, font.*.height, cursor_ptr, glyph_len);
                        label.h = row_height;
                        txt.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
                        txt.background = cursor_color;
                        txt.text = cursor_text_color;
                        nk_fill_rect(out, label, @as(f32, @floatFromInt(@as(c_int, 0))), cursor_color);
                        nk_widget_text(out, label, cursor_ptr, glyph_len, &txt, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), font);
                    }
                }
            }
        } else {
            var l: c_int = nk_str_len_char(&edit.*.string);
            _ = &l;
            var begin: [*c]const u8 = nk_str_get_const(&edit.*.string);
            _ = &begin;
            var background: [*c]const struct_nk_style_item = undefined;
            _ = &background;
            var background_color: struct_nk_color = undefined;
            _ = &background_color;
            var text_color: struct_nk_color = undefined;
            _ = &text_color;
            nk_push_scissor(out, clip);
            if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
                background = &style.*.active;
                text_color = style.*.text_active;
            } else if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
                background = &style.*.hover;
                text_color = style.*.text_hover;
            } else {
                background = &style.*.normal;
                text_color = style.*.text_normal;
            }
            if (background.*.type == @as(c_uint, @bitCast(NK_STYLE_ITEM_IMAGE))) {
                background_color = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
            } else {
                background_color = background.*.data.color;
            }
            background_color = nk_rgb_factor(background_color, style.*.color_factor);
            text_color = nk_rgb_factor(text_color, style.*.color_factor);
            nk_edit_draw_text(out, style, area.x - edit.*.scrollbar.x, area.y - edit.*.scrollbar.y, @as(f32, @floatFromInt(@as(c_int, 0))), begin, l, row_height, font, background_color, text_color, nk_false);
        }
        nk_push_scissor(out, old_clip);
    }
    return ret;
}
pub fn nk_color_picker_behavior(arg_state: [*c]nk_flags, arg_bounds: [*c]const struct_nk_rect, arg_matrix: [*c]const struct_nk_rect, arg_hue_bar: [*c]const struct_nk_rect, arg_alpha_bar: [*c]const struct_nk_rect, arg_color: [*c]struct_nk_colorf, arg_in: [*c]const struct_nk_input) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var bounds = arg_bounds;
    _ = &bounds;
    var matrix = arg_matrix;
    _ = &matrix;
    var hue_bar = arg_hue_bar;
    _ = &hue_bar;
    var alpha_bar = arg_alpha_bar;
    _ = &alpha_bar;
    var color = arg_color;
    _ = &color;
    var in = arg_in;
    _ = &in;
    var hsva: [4]f32 = undefined;
    _ = &hsva;
    var value_changed: nk_bool = 0;
    _ = &value_changed;
    var hsv_changed: nk_bool = 0;
    _ = &hsv_changed;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29520))), "nk_bool nk_color_picker_behavior(nk_flags *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, struct nk_colorf *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (matrix != null) {} else {
                __assert_fail("matrix", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29521))), "nk_bool nk_color_picker_behavior(nk_flags *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, struct nk_colorf *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (hue_bar != null) {} else {
                __assert_fail("hue_bar", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29522))), "nk_bool nk_color_picker_behavior(nk_flags *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, struct nk_colorf *, const struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (color != null) {} else {
                __assert_fail("color", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29523))), "nk_bool nk_color_picker_behavior(nk_flags *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, struct nk_colorf *, const struct nk_input *)");
            };
        };
    };
    nk_colorf_hsva_fv(@as([*c]f32, @ptrCast(@alignCast(&hsva))), color.*);
    if (nk_button_behavior(state, matrix.*, in, @as(c_uint, @bitCast(NK_BUTTON_REPEATER))) != 0) {
        hsva[@as(c_uint, @intCast(@as(c_int, 1)))] = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < ((in.*.mouse.pos.x - matrix.*.x) / (matrix.*.w - @as(f32, @floatFromInt(@as(c_int, 1)))))) 1.0 else (in.*.mouse.pos.x - matrix.*.x) / (matrix.*.w - @as(f32, @floatFromInt(@as(c_int, 1)))))) if (1.0 < ((in.*.mouse.pos.x - matrix.*.x) / (matrix.*.w - @as(f32, @floatFromInt(@as(c_int, 1)))))) 1.0 else (in.*.mouse.pos.x - matrix.*.x) / (matrix.*.w - @as(f32, @floatFromInt(@as(c_int, 1)))) else @as(f32, @floatFromInt(@as(c_int, 0)));
        hsva[@as(c_uint, @intCast(@as(c_int, 2)))] = 1.0 - (if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < ((in.*.mouse.pos.y - matrix.*.y) / (matrix.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))))) 1.0 else (in.*.mouse.pos.y - matrix.*.y) / (matrix.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))))) if (1.0 < ((in.*.mouse.pos.y - matrix.*.y) / (matrix.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))))) 1.0 else (in.*.mouse.pos.y - matrix.*.y) / (matrix.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))) else @as(f32, @floatFromInt(@as(c_int, 0))));
        value_changed = blk: {
            const tmp = @as(c_int, 1);
            hsv_changed = tmp;
            break :blk tmp;
        };
    }
    if (nk_button_behavior(state, hue_bar.*, in, @as(c_uint, @bitCast(NK_BUTTON_REPEATER))) != 0) {
        hsva[@as(c_uint, @intCast(@as(c_int, 0)))] = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < ((in.*.mouse.pos.y - hue_bar.*.y) / (hue_bar.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))))) 1.0 else (in.*.mouse.pos.y - hue_bar.*.y) / (hue_bar.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))))) if (1.0 < ((in.*.mouse.pos.y - hue_bar.*.y) / (hue_bar.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))))) 1.0 else (in.*.mouse.pos.y - hue_bar.*.y) / (hue_bar.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))) else @as(f32, @floatFromInt(@as(c_int, 0)));
        value_changed = blk: {
            const tmp = @as(c_int, 1);
            hsv_changed = tmp;
            break :blk tmp;
        };
    }
    if (alpha_bar != null) {
        if (nk_button_behavior(state, alpha_bar.*, in, @as(c_uint, @bitCast(NK_BUTTON_REPEATER))) != 0) {
            hsva[@as(c_uint, @intCast(@as(c_int, 3)))] = 1.0 - (if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < ((in.*.mouse.pos.y - alpha_bar.*.y) / (alpha_bar.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))))) 1.0 else (in.*.mouse.pos.y - alpha_bar.*.y) / (alpha_bar.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))))) if (1.0 < ((in.*.mouse.pos.y - alpha_bar.*.y) / (alpha_bar.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))))) 1.0 else (in.*.mouse.pos.y - alpha_bar.*.y) / (alpha_bar.*.h - @as(f32, @floatFromInt(@as(c_int, 1)))) else @as(f32, @floatFromInt(@as(c_int, 0))));
            value_changed = 1;
        }
    }
    if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    if (hsv_changed != 0) {
        color.* = nk_hsva_colorfv(@as([*c]f32, @ptrCast(@alignCast(&hsva))));
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
    }
    if (value_changed != 0) {
        color.*.a = hsva[@as(c_uint, @intCast(@as(c_int, 3)))];
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
    }
    if (nk_input_is_mouse_hovering_rect(in, bounds.*) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVERED));
    }
    if (((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) and !(nk_input_is_mouse_prev_hovering_rect(in, bounds.*) != 0)) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_ENTERED));
    } else if (nk_input_is_mouse_prev_hovering_rect(in, bounds.*) != 0) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_LEFT));
    }
    return value_changed;
}
pub fn nk_draw_color_picker(arg_o: [*c]struct_nk_command_buffer, arg_matrix: [*c]const struct_nk_rect, arg_hue_bar: [*c]const struct_nk_rect, arg_alpha_bar: [*c]const struct_nk_rect, arg_col: struct_nk_colorf) callconv(.c) void {
    var o = arg_o;
    _ = &o;
    var matrix = arg_matrix;
    _ = &matrix;
    var hue_bar = arg_hue_bar;
    _ = &hue_bar;
    var alpha_bar = arg_alpha_bar;
    _ = &alpha_bar;
    var col = arg_col;
    _ = &col;
    const black = struct {
        const static: struct_nk_color = struct_nk_color{
            .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
            .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
            .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
            .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
        };
    };
    _ = &black;
    const white = struct {
        const static: struct_nk_color = struct_nk_color{
            .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
            .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
            .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
            .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
        };
    };
    _ = &white;
    const black_trans = struct {
        const static: struct_nk_color = struct_nk_color{
            .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
            .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
            .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
            .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
        };
    };
    _ = &black_trans;
    const crosshair_size: f32 = 7.0;
    _ = &crosshair_size;
    var temp: struct_nk_color = undefined;
    _ = &temp;
    var hsva: [4]f32 = undefined;
    _ = &hsva;
    var line_y: f32 = undefined;
    _ = &line_y;
    var i: c_int = undefined;
    _ = &i;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (o != null) {} else {
                __assert_fail("o", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29577))), "void nk_draw_color_picker(struct nk_command_buffer *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, struct nk_colorf)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (matrix != null) {} else {
                __assert_fail("matrix", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29578))), "void nk_draw_color_picker(struct nk_command_buffer *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, struct nk_colorf)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (hue_bar != null) {} else {
                __assert_fail("hue_bar", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29579))), "void nk_draw_color_picker(struct nk_command_buffer *, const struct nk_rect *, const struct nk_rect *, const struct nk_rect *, struct nk_colorf)");
            };
        };
    };
    nk_colorf_hsva_fv(@as([*c]f32, @ptrCast(@alignCast(&hsva))), col);
    {
        i = 0;
        while (i < @as(c_int, 6)) : (i += 1) {
            const hue_colors = struct {
                const static: [7]struct_nk_color = [7]struct_nk_color{
                    struct_nk_color{
                        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                    },
                    struct_nk_color{
                        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                    },
                    struct_nk_color{
                        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                    },
                    struct_nk_color{
                        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                    },
                    struct_nk_color{
                        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                    },
                    struct_nk_color{
                        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                    },
                    struct_nk_color{
                        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
                        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
                    },
                };
            };
            _ = &hue_colors;
            nk_fill_rect_multi_color(o, nk_rect(hue_bar.*.x, (hue_bar.*.y + (@as(f32, @floatFromInt(i)) * (hue_bar.*.h / 6.0))) + 0.5, hue_bar.*.w, (hue_bar.*.h / 6.0) + 0.5), hue_colors.static[@as(c_uint, @intCast(i))], hue_colors.static[@as(c_uint, @intCast(i))], hue_colors.static[@as(c_uint, @intCast(i + @as(c_int, 1)))], hue_colors.static[@as(c_uint, @intCast(i + @as(c_int, 1)))]);
        }
    }
    line_y = @as(f32, @floatFromInt(@as(c_int, @intFromFloat((hue_bar.*.y + (hsva[@as(c_uint, @intCast(@as(c_int, 0)))] * matrix.*.h)) + 0.5))));
    nk_stroke_line(o, hue_bar.*.x - @as(f32, @floatFromInt(@as(c_int, 1))), line_y, (hue_bar.*.x + hue_bar.*.w) + @as(f32, @floatFromInt(@as(c_int, 2))), line_y, @as(f32, @floatFromInt(@as(c_int, 1))), nk_rgb(@as(c_int, 255), @as(c_int, 255), @as(c_int, 255)));
    if (alpha_bar != null) {
        var alpha: f32 = if (@as(f32, @floatFromInt(@as(c_int, 0))) < (if (1.0 < col.a) 1.0 else col.a)) if (1.0 < col.a) 1.0 else col.a else @as(f32, @floatFromInt(@as(c_int, 0)));
        _ = &alpha;
        line_y = @as(f32, @floatFromInt(@as(c_int, @intFromFloat((alpha_bar.*.y + ((1.0 - alpha) * matrix.*.h)) + 0.5))));
        nk_fill_rect_multi_color(o, alpha_bar.*, white.static, white.static, black.static, black.static);
        nk_stroke_line(o, alpha_bar.*.x - @as(f32, @floatFromInt(@as(c_int, 1))), line_y, (alpha_bar.*.x + alpha_bar.*.w) + @as(f32, @floatFromInt(@as(c_int, 2))), line_y, @as(f32, @floatFromInt(@as(c_int, 1))), nk_rgb(@as(c_int, 255), @as(c_int, 255), @as(c_int, 255)));
    }
    temp = nk_hsv_f(hsva[@as(c_uint, @intCast(@as(c_int, 0)))], 1.0, 1.0);
    nk_fill_rect_multi_color(o, matrix.*, white.static, temp, temp, white.static);
    nk_fill_rect_multi_color(o, matrix.*, black_trans.static, black_trans.static, black.static, black.static);
    {
        var p: struct_nk_vec2 = undefined;
        _ = &p;
        var S: f32 = hsva[@as(c_uint, @intCast(@as(c_int, 1)))];
        _ = &S;
        var V: f32 = hsva[@as(c_uint, @intCast(@as(c_int, 2)))];
        _ = &V;
        p.x = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(matrix.*.x + (S * matrix.*.w)))));
        p.y = @as(f32, @floatFromInt(@as(c_int, @intFromFloat(matrix.*.y + ((1.0 - V) * matrix.*.h)))));
        nk_stroke_line(o, p.x - crosshair_size, p.y, p.x - @as(f32, @floatFromInt(@as(c_int, 2))), p.y, 1.0, white.static);
        nk_stroke_line(o, (p.x + crosshair_size) + @as(f32, @floatFromInt(@as(c_int, 1))), p.y, p.x + @as(f32, @floatFromInt(@as(c_int, 3))), p.y, 1.0, white.static);
        nk_stroke_line(o, p.x, (p.y + crosshair_size) + @as(f32, @floatFromInt(@as(c_int, 1))), p.x, p.y + @as(f32, @floatFromInt(@as(c_int, 3))), 1.0, white.static);
        nk_stroke_line(o, p.x, p.y - crosshair_size, p.x, p.y - @as(f32, @floatFromInt(@as(c_int, 2))), 1.0, white.static);
    }
}
pub fn nk_do_color_picker(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_col: [*c]struct_nk_colorf, arg_fmt: enum_nk_color_format, arg_bounds: struct_nk_rect, arg_padding: struct_nk_vec2, arg_in: [*c]const struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var col = arg_col;
    _ = &col;
    var fmt = arg_fmt;
    _ = &fmt;
    var bounds = arg_bounds;
    _ = &bounds;
    var padding = arg_padding;
    _ = &padding;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var ret: c_int = 0;
    _ = &ret;
    var matrix: struct_nk_rect = undefined;
    _ = &matrix;
    var hue_bar: struct_nk_rect = undefined;
    _ = &hue_bar;
    var alpha_bar: struct_nk_rect = undefined;
    _ = &alpha_bar;
    var bar_w: f32 = undefined;
    _ = &bar_w;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29634))), "nk_bool nk_do_color_picker(nk_flags *, struct nk_command_buffer *, struct nk_colorf *, enum nk_color_format, struct nk_rect, struct nk_vec2, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (col != null) {} else {
                __assert_fail("col", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29635))), "nk_bool nk_do_color_picker(nk_flags *, struct nk_command_buffer *, struct nk_colorf *, enum nk_color_format, struct nk_rect, struct nk_vec2, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29636))), "nk_bool nk_do_color_picker(nk_flags *, struct nk_command_buffer *, struct nk_colorf *, enum nk_color_format, struct nk_rect, struct nk_vec2, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29637))), "nk_bool nk_do_color_picker(nk_flags *, struct nk_command_buffer *, struct nk_colorf *, enum nk_color_format, struct nk_rect, struct nk_vec2, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if (((!(out != null) or !(col != null)) or !(state != null)) or !(font != null)) return ret;
    bar_w = font.*.height;
    bounds.x += padding.x;
    bounds.y += padding.x;
    bounds.w -= @as(f32, @floatFromInt(@as(c_int, 2))) * padding.x;
    bounds.h -= @as(f32, @floatFromInt(@as(c_int, 2))) * padding.y;
    matrix.x = bounds.x;
    matrix.y = bounds.y;
    matrix.h = bounds.h;
    matrix.w = bounds.w - ((@as(f32, @floatFromInt(@as(c_int, 3))) * padding.x) + (@as(f32, @floatFromInt(@as(c_int, 2))) * bar_w));
    hue_bar.w = bar_w;
    hue_bar.y = bounds.y;
    hue_bar.h = matrix.h;
    hue_bar.x = (matrix.x + matrix.w) + padding.x;
    alpha_bar.x = (hue_bar.x + hue_bar.w) + padding.x;
    alpha_bar.y = bounds.y;
    alpha_bar.w = bar_w;
    alpha_bar.h = matrix.h;
    ret = nk_color_picker_behavior(state, &bounds, &matrix, &hue_bar, if (fmt == @as(c_uint, @bitCast(NK_RGBA))) &alpha_bar else null, col, in);
    nk_draw_color_picker(out, &matrix, &hue_bar, if (fmt == @as(c_uint, @bitCast(NK_RGBA))) &alpha_bar else null, col.*);
    return ret;
}
pub const NK_PROPERTY_DEFAULT: c_int = 0;
pub const NK_PROPERTY_EDIT: c_int = 1;
pub const NK_PROPERTY_DRAG: c_int = 2;
pub const enum_nk_property_status = c_uint;
pub const NK_FILTER_INT: c_int = 0;
pub const NK_FILTER_FLOAT: c_int = 1;
pub const enum_nk_property_filter = c_uint;
pub fn nk_property_variant_int(arg_value: c_int, arg_min_value: c_int, arg_max_value: c_int, arg_step: c_int) callconv(.c) struct_nk_property_variant {
    var value = arg_value;
    _ = &value;
    var min_value = arg_min_value;
    _ = &min_value;
    var max_value = arg_max_value;
    _ = &max_value;
    var step = arg_step;
    _ = &step;
    var result: struct_nk_property_variant = undefined;
    _ = &result;
    result.kind = @as(c_uint, @bitCast(NK_PROPERTY_INT));
    result.value.i = value;
    result.min_value.i = min_value;
    result.max_value.i = max_value;
    result.step.i = step;
    return result;
}
pub fn nk_property_variant_float(arg_value: f32, arg_min_value: f32, arg_max_value: f32, arg_step: f32) callconv(.c) struct_nk_property_variant {
    var value = arg_value;
    _ = &value;
    var min_value = arg_min_value;
    _ = &min_value;
    var max_value = arg_max_value;
    _ = &max_value;
    var step = arg_step;
    _ = &step;
    var result: struct_nk_property_variant = undefined;
    _ = &result;
    result.kind = @as(c_uint, @bitCast(NK_PROPERTY_FLOAT));
    result.value.f = value;
    result.min_value.f = min_value;
    result.max_value.f = max_value;
    result.step.f = step;
    return result;
}
pub fn nk_property_variant_double(arg_value: f64, arg_min_value: f64, arg_max_value: f64, arg_step: f64) callconv(.c) struct_nk_property_variant {
    var value = arg_value;
    _ = &value;
    var min_value = arg_min_value;
    _ = &min_value;
    var max_value = arg_max_value;
    _ = &max_value;
    var step = arg_step;
    _ = &step;
    var result: struct_nk_property_variant = undefined;
    _ = &result;
    result.kind = @as(c_uint, @bitCast(NK_PROPERTY_DOUBLE));
    result.value.d = value;
    result.min_value.d = min_value;
    result.max_value.d = max_value;
    result.step.d = step;
    return result;
}
pub fn nk_drag_behavior(arg_state: [*c]nk_flags, arg_in: [*c]const struct_nk_input, arg_drag: struct_nk_rect, arg_variant: [*c]struct_nk_property_variant, arg_inc_per_pixel: f32) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var in = arg_in;
    _ = &in;
    var drag = arg_drag;
    _ = &drag;
    var variant = arg_variant;
    _ = &variant;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    var left_mouse_down: c_int = @intFromBool((in != null) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0));
    _ = &left_mouse_down;
    var left_mouse_click_in_cursor: c_int = @intFromBool((in != null) and (nk_input_has_mouse_click_down_in_rect(in, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), drag, nk_true) != 0));
    _ = &left_mouse_click_in_cursor;
    if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    if (nk_input_is_mouse_hovering_rect(in, drag) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVERED));
    }
    if ((left_mouse_down != 0) and (left_mouse_click_in_cursor != 0)) {
        var delta: f32 = undefined;
        _ = &delta;
        var pixels: f32 = undefined;
        _ = &pixels;
        pixels = in.*.mouse.delta.x;
        delta = pixels * inc_per_pixel;
        while (true) {
            switch (variant.*.kind) {
                else => break,
                @as(c_uint, @bitCast(@as(c_int, 0))) => {
                    variant.*.value.i = variant.*.value.i + @as(c_int, @intFromFloat(delta));
                    variant.*.value.i = if ((if (variant.*.value.i < variant.*.max_value.i) variant.*.value.i else variant.*.max_value.i) < variant.*.min_value.i) variant.*.min_value.i else if (variant.*.value.i < variant.*.max_value.i) variant.*.value.i else variant.*.max_value.i;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    variant.*.value.f = variant.*.value.f + delta;
                    variant.*.value.f = if ((if (variant.*.value.f < variant.*.max_value.f) variant.*.value.f else variant.*.max_value.f) < variant.*.min_value.f) variant.*.min_value.f else if (variant.*.value.f < variant.*.max_value.f) variant.*.value.f else variant.*.max_value.f;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    variant.*.value.d = variant.*.value.d + @as(f64, @floatCast(delta));
                    variant.*.value.d = if ((if (variant.*.value.d < variant.*.max_value.d) variant.*.value.d else variant.*.max_value.d) < variant.*.min_value.d) variant.*.min_value.d else if (variant.*.value.d < variant.*.max_value.d) variant.*.value.d else variant.*.max_value.d;
                    break;
                },
            }
            break;
        }
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
    }
    if (((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) and !(nk_input_is_mouse_prev_hovering_rect(in, drag) != 0)) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_ENTERED));
    } else if (nk_input_is_mouse_prev_hovering_rect(in, drag) != 0) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_LEFT));
    }
}
pub fn nk_property_behavior(arg_ws: [*c]nk_flags, arg_in: [*c]const struct_nk_input, arg_property: struct_nk_rect, arg_label: struct_nk_rect, arg_edit: struct_nk_rect, arg_empty: struct_nk_rect, arg_state: [*c]c_int, arg_variant: [*c]struct_nk_property_variant, arg_inc_per_pixel: f32) callconv(.c) void {
    var ws = arg_ws;
    _ = &ws;
    var in = arg_in;
    _ = &in;
    var property = arg_property;
    _ = &property;
    var label = arg_label;
    _ = &label;
    var edit = arg_edit;
    _ = &edit;
    var empty = arg_empty;
    _ = &empty;
    var state = arg_state;
    _ = &state;
    var variant = arg_variant;
    _ = &variant;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    if ((ws.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        ws.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        ws.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    if ((in != null) and (state.* == NK_PROPERTY_DEFAULT)) {
        if (nk_button_behavior(ws, edit, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
            state.* = NK_PROPERTY_EDIT;
        } else if (nk_input_is_mouse_click_down_in_rect(in, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), label, nk_true) != 0) {
            state.* = NK_PROPERTY_DRAG;
        } else if (nk_input_is_mouse_click_down_in_rect(in, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), empty, nk_true) != 0) {
            state.* = NK_PROPERTY_DRAG;
        }
    }
    if (state.* == NK_PROPERTY_DRAG) {
        nk_drag_behavior(ws, in, property, variant, inc_per_pixel);
        if (!((ws.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0)) {
            state.* = NK_PROPERTY_DEFAULT;
        }
    }
}
pub fn nk_draw_property(arg_out: [*c]struct_nk_command_buffer, arg_style: [*c]const struct_nk_style_property, arg_bounds: [*c]const struct_nk_rect, arg_label: [*c]const struct_nk_rect, arg_state: nk_flags, arg_name: [*c]const u8, arg_len: c_int, arg_font: [*c]const struct_nk_user_font) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var style = arg_style;
    _ = &style;
    var bounds = arg_bounds;
    _ = &bounds;
    var label = arg_label;
    _ = &label;
    var state = arg_state;
    _ = &state;
    var name = arg_name;
    _ = &name;
    var len = arg_len;
    _ = &len;
    var font = arg_font;
    _ = &font;
    var text: struct_nk_text = undefined;
    _ = &text;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.active;
        text.text = style.*.label_active;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.hover;
        text.text = style.*.label_hover;
    } else {
        background = &style.*.normal;
        text.text = style.*.label_normal;
    }
    text.text = nk_rgb_factor(text.text, style.*.color_factor);
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_image(out, bounds.*, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                text.background = nk_rgba(@as(c_int, 0), @as(c_int, 0), @as(c_int, 0), @as(c_int, 0));
                nk_draw_nine_slice(out, bounds.*, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                text.background = background.*.data.color;
                nk_fill_rect(out, bounds.*, style.*.rounding, nk_rgb_factor(background.*.data.color, style.*.color_factor));
                nk_stroke_rect(out, bounds.*, style.*.rounding, style.*.border, nk_rgb_factor(style.*.border_color, style.*.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
    if ((name != null) and (@as(c_int, @bitCast(@as(c_uint, name[@as(c_uint, @intCast(@as(c_int, 0)))]))) != @as(c_int, '#'))) {
        nk_widget_text(out, label.*, name, len, &text, @as(nk_flags, @bitCast(NK_TEXT_CENTERED)), font);
    }
}
pub fn nk_do_property(arg_ws: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_property: struct_nk_rect, arg_name: [*c]const u8, arg_variant: [*c]struct_nk_property_variant, arg_inc_per_pixel: f32, arg_buffer: [*c]u8, arg_len: [*c]c_int, arg_state: [*c]c_int, arg_cursor: [*c]c_int, arg_select_begin: [*c]c_int, arg_select_end: [*c]c_int, arg_style: [*c]const struct_nk_style_property, arg_filter: enum_nk_property_filter, arg_in: [*c]struct_nk_input, arg_font: [*c]const struct_nk_user_font, arg_text_edit: [*c]struct_nk_text_edit, arg_behavior: enum_nk_button_behavior) callconv(.c) void {
    var ws = arg_ws;
    _ = &ws;
    var out = arg_out;
    _ = &out;
    var property = arg_property;
    _ = &property;
    var name = arg_name;
    _ = &name;
    var variant = arg_variant;
    _ = &variant;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    var buffer = arg_buffer;
    _ = &buffer;
    var len = arg_len;
    _ = &len;
    var state = arg_state;
    _ = &state;
    var cursor = arg_cursor;
    _ = &cursor;
    var select_begin = arg_select_begin;
    _ = &select_begin;
    var select_end = arg_select_end;
    _ = &select_end;
    var style = arg_style;
    _ = &style;
    var filter = arg_filter;
    _ = &filter;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var text_edit = arg_text_edit;
    _ = &text_edit;
    var behavior = arg_behavior;
    _ = &behavior;
    const filters: [2]nk_plugin_filter = [2]nk_plugin_filter{
        &nk_filter_decimal,
        &nk_filter_float,
    };
    _ = &filters;
    var active: nk_bool = undefined;
    _ = &active;
    var old: nk_bool = undefined;
    _ = &old;
    var num_len: c_int = 0;
    _ = &num_len;
    var name_len: c_int = 0;
    _ = &name_len;
    var string: [64]u8 = undefined;
    _ = &string;
    var size: f32 = undefined;
    _ = &size;
    var dst: [*c]u8 = null;
    _ = &dst;
    var length: [*c]c_int = undefined;
    _ = &length;
    var left: struct_nk_rect = undefined;
    _ = &left;
    var right: struct_nk_rect = undefined;
    _ = &right;
    var label: struct_nk_rect = undefined;
    _ = &label;
    var edit: struct_nk_rect = undefined;
    _ = &edit;
    var empty: struct_nk_rect = undefined;
    _ = &empty;
    left.h = font.*.height / @as(f32, @floatFromInt(@as(c_int, 2)));
    left.w = left.h;
    left.x = (property.x + style.*.border) + style.*.padding.x;
    left.y = ((property.y + style.*.border) + (property.h / 2.0)) - (left.h / @as(f32, @floatFromInt(@as(c_int, 2))));
    if ((name != null) and (@as(c_int, @bitCast(@as(c_uint, name[@as(c_uint, @intCast(@as(c_int, 0)))]))) != @as(c_int, '#'))) {
        name_len = nk_strlen(name);
    }
    size = font.*.width.?(font.*.userdata, font.*.height, name, name_len);
    label.x = (left.x + left.w) + style.*.padding.x;
    label.w = size + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x);
    label.y = (property.y + style.*.border) + style.*.padding.y;
    label.h = property.h - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border) + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y));
    right.y = left.y;
    right.w = left.w;
    right.h = left.h;
    right.x = (property.x + property.w) - (right.w + style.*.padding.x);
    if (state.* == NK_PROPERTY_EDIT) {
        size = font.*.width.?(font.*.userdata, font.*.height, buffer, len.*);
        size += style.*.edit.cursor_size;
        length = len;
        dst = buffer;
    } else {
        while (true) {
            switch (variant.*.kind) {
                else => break,
                @as(c_uint, @bitCast(@as(c_int, 0))) => {
                    _ = nk_itoa(@as([*c]u8, @ptrCast(@alignCast(&string))), @as(c_long, @bitCast(@as(c_long, variant.*.value.i))));
                    num_len = nk_strlen(@as([*c]u8, @ptrCast(@alignCast(&string))));
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    _ = nk_dtoa(@as([*c]u8, @ptrCast(@alignCast(&string))), @as(f64, @floatCast(variant.*.value.f)));
                    num_len = nk_string_float_limit(@as([*c]u8, @ptrCast(@alignCast(&string))), @as(c_int, 2));
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    _ = nk_dtoa(@as([*c]u8, @ptrCast(@alignCast(&string))), variant.*.value.d);
                    num_len = nk_string_float_limit(@as([*c]u8, @ptrCast(@alignCast(&string))), @as(c_int, 2));
                    break;
                },
            }
            break;
        }
        size = font.*.width.?(font.*.userdata, font.*.height, @as([*c]u8, @ptrCast(@alignCast(&string))), num_len);
        dst = @as([*c]u8, @ptrCast(@alignCast(&string)));
        length = &num_len;
    }
    edit.w = size + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x);
    edit.w = if (edit.w < (right.x - (label.x + label.w))) edit.w else right.x - (label.x + label.w);
    edit.x = right.x - (edit.w + style.*.padding.x);
    edit.y = property.y + style.*.border;
    edit.h = property.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.border);
    empty.w = edit.x - (label.x + label.w);
    empty.x = label.x + label.w;
    empty.y = property.y;
    empty.h = property.h;
    old = @intFromBool(state.* == NK_PROPERTY_EDIT);
    nk_property_behavior(ws, in, property, label, edit, empty, state, variant, inc_per_pixel);
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_property(out, style, &property, &label, ws.*, name, name_len, font);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    if (nk_do_button_symbol(ws, out, left, style.*.sym_left, behavior, &style.*.dec_button, in, font) != 0) {
        while (true) {
            switch (variant.*.kind) {
                else => break,
                @as(c_uint, @bitCast(@as(c_int, 0))) => {
                    variant.*.value.i = if ((if ((variant.*.value.i - variant.*.step.i) < variant.*.max_value.i) variant.*.value.i - variant.*.step.i else variant.*.max_value.i) < variant.*.min_value.i) variant.*.min_value.i else if ((variant.*.value.i - variant.*.step.i) < variant.*.max_value.i) variant.*.value.i - variant.*.step.i else variant.*.max_value.i;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    variant.*.value.f = if ((if ((variant.*.value.f - variant.*.step.f) < variant.*.max_value.f) variant.*.value.f - variant.*.step.f else variant.*.max_value.f) < variant.*.min_value.f) variant.*.min_value.f else if ((variant.*.value.f - variant.*.step.f) < variant.*.max_value.f) variant.*.value.f - variant.*.step.f else variant.*.max_value.f;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    variant.*.value.d = if ((if ((variant.*.value.d - variant.*.step.d) < variant.*.max_value.d) variant.*.value.d - variant.*.step.d else variant.*.max_value.d) < variant.*.min_value.d) variant.*.min_value.d else if ((variant.*.value.d - variant.*.step.d) < variant.*.max_value.d) variant.*.value.d - variant.*.step.d else variant.*.max_value.d;
                    break;
                },
            }
            break;
        }
    }
    if (nk_do_button_symbol(ws, out, right, style.*.sym_right, behavior, &style.*.inc_button, in, font) != 0) {
        while (true) {
            switch (variant.*.kind) {
                else => break,
                @as(c_uint, @bitCast(@as(c_int, 0))) => {
                    variant.*.value.i = if ((if ((variant.*.value.i + variant.*.step.i) < variant.*.max_value.i) variant.*.value.i + variant.*.step.i else variant.*.max_value.i) < variant.*.min_value.i) variant.*.min_value.i else if ((variant.*.value.i + variant.*.step.i) < variant.*.max_value.i) variant.*.value.i + variant.*.step.i else variant.*.max_value.i;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    variant.*.value.f = if ((if ((variant.*.value.f + variant.*.step.f) < variant.*.max_value.f) variant.*.value.f + variant.*.step.f else variant.*.max_value.f) < variant.*.min_value.f) variant.*.min_value.f else if ((variant.*.value.f + variant.*.step.f) < variant.*.max_value.f) variant.*.value.f + variant.*.step.f else variant.*.max_value.f;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    variant.*.value.d = if ((if ((variant.*.value.d + variant.*.step.d) < variant.*.max_value.d) variant.*.value.d + variant.*.step.d else variant.*.max_value.d) < variant.*.min_value.d) variant.*.min_value.d else if ((variant.*.value.d + variant.*.step.d) < variant.*.max_value.d) variant.*.value.d + variant.*.step.d else variant.*.max_value.d;
                    break;
                },
            }
            break;
        }
    }
    if ((old != NK_PROPERTY_EDIT) and (state.* == NK_PROPERTY_EDIT)) {
        _ = nk_memcopy(@as(?*anyopaque, @ptrCast(buffer)), @as(?*const anyopaque, @ptrCast(dst)), @as(nk_size, @bitCast(@as(c_long, length.*))));
        cursor.* = nk_utf_len(buffer, length.*);
        len.* = length.*;
        length = len;
        dst = buffer;
        active = 0;
    } else {
        active = @intFromBool(state.* == NK_PROPERTY_EDIT);
    }
    nk_textedit_clear_state(text_edit, @as(c_uint, @bitCast(NK_TEXT_EDIT_SINGLE_LINE)), filters[filter]);
    text_edit.*.active = @as(u8, @bitCast(@as(i8, @truncate(active))));
    text_edit.*.string.len = length.*;
    text_edit.*.cursor = if ((if (cursor.* < length.*) cursor.* else length.*) < @as(c_int, 0)) @as(c_int, 0) else if (cursor.* < length.*) cursor.* else length.*;
    text_edit.*.select_start = if ((if (select_begin.* < length.*) select_begin.* else length.*) < @as(c_int, 0)) @as(c_int, 0) else if (select_begin.* < length.*) select_begin.* else length.*;
    text_edit.*.select_end = if ((if (select_end.* < length.*) select_end.* else length.*) < @as(c_int, 0)) @as(c_int, 0) else if (select_end.* < length.*) select_end.* else length.*;
    text_edit.*.string.buffer.allocated = @as(nk_size, @bitCast(@as(c_long, length.*)));
    text_edit.*.string.buffer.memory.size = 64;
    text_edit.*.string.buffer.memory.ptr = @as(?*anyopaque, @ptrCast(dst));
    text_edit.*.string.buffer.size = 64;
    text_edit.*.mode = @as(u8, @bitCast(@as(i8, @truncate(NK_TEXT_EDIT_MODE_INSERT))));
    _ = nk_do_edit(ws, out, edit, @as(nk_flags, @bitCast(NK_EDIT_FIELD | NK_EDIT_AUTO_SELECT)), filters[filter], text_edit, &style.*.edit, if (state.* == NK_PROPERTY_EDIT) in else null, font);
    length.* = text_edit.*.string.len;
    cursor.* = text_edit.*.cursor;
    select_begin.* = text_edit.*.select_start;
    select_end.* = text_edit.*.select_end;
    if ((@as(c_int, @bitCast(@as(c_uint, text_edit.*.active))) != 0) and (nk_input_is_key_pressed(in, @as(c_uint, @bitCast(NK_KEY_ENTER))) != 0)) {
        text_edit.*.active = @as(u8, @bitCast(@as(i8, @truncate(nk_false))));
    }
    if ((active != 0) and !(text_edit.*.active != 0)) {
        state.* = NK_PROPERTY_DEFAULT;
        (blk: {
            const tmp = len.*;
            if (tmp >= 0) break :blk buffer + @as(usize, @intCast(tmp)) else break :blk buffer - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = '\x00';
        while (true) {
            switch (variant.*.kind) {
                else => break,
                @as(c_uint, @bitCast(@as(c_int, 0))) => {
                    variant.*.value.i = nk_strtoi(buffer, null);
                    variant.*.value.i = if ((if (variant.*.value.i < variant.*.max_value.i) variant.*.value.i else variant.*.max_value.i) < variant.*.min_value.i) variant.*.min_value.i else if (variant.*.value.i < variant.*.max_value.i) variant.*.value.i else variant.*.max_value.i;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    _ = nk_string_float_limit(buffer, @as(c_int, 2));
                    variant.*.value.f = nk_strtof(buffer, null);
                    variant.*.value.f = if ((if (variant.*.value.f < variant.*.max_value.f) variant.*.value.f else variant.*.max_value.f) < variant.*.min_value.f) variant.*.min_value.f else if (variant.*.value.f < variant.*.max_value.f) variant.*.value.f else variant.*.max_value.f;
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    _ = nk_string_float_limit(buffer, @as(c_int, 2));
                    variant.*.value.d = nk_strtod(buffer, null);
                    variant.*.value.d = if ((if (variant.*.value.d < variant.*.max_value.d) variant.*.value.d else variant.*.max_value.d) < variant.*.min_value.d) variant.*.min_value.d else if (variant.*.value.d < variant.*.max_value.d) variant.*.value.d else variant.*.max_value.d;
                    break;
                },
            }
            break;
        }
    }
}
pub fn nk_property(arg_ctx: [*c]struct_nk_context, arg_name: [*c]const u8, arg_variant: [*c]struct_nk_property_variant, arg_inc_per_pixel: f32, filter: enum_nk_property_filter) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var name = arg_name;
    _ = &name;
    var variant = arg_variant;
    _ = &variant;
    var inc_per_pixel = arg_inc_per_pixel;
    _ = &inc_per_pixel;
    _ = &filter;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var in: [*c]struct_nk_input = undefined;
    _ = &in;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var s: enum_nk_widget_layout_states = undefined;
    _ = &s;
    var state: [*c]c_int = null;
    _ = &state;
    var hash: nk_hash = 0;
    _ = &hash;
    var buffer: [*c]u8 = null;
    _ = &buffer;
    var len: [*c]c_int = null;
    _ = &len;
    var cursor: [*c]c_int = null;
    _ = &cursor;
    var select_begin: [*c]c_int = null;
    _ = &select_begin;
    var select_end: [*c]c_int = null;
    _ = &select_end;
    var old_state: c_int = undefined;
    _ = &old_state;
    var dummy_buffer: [64]u8 = undefined;
    _ = &dummy_buffer;
    var dummy_state: c_int = NK_PROPERTY_DEFAULT;
    _ = &dummy_state;
    var dummy_length: c_int = 0;
    _ = &dummy_length;
    var dummy_cursor: c_int = 0;
    _ = &dummy_cursor;
    var dummy_select_begin: c_int = 0;
    _ = &dummy_select_begin;
    var dummy_select_end: c_int = 0;
    _ = &dummy_select_end;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29008))), "void nk_property(struct nk_context *, const char *, struct nk_property_variant *, float, const enum nk_property_filter)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29009))), "void nk_property(struct nk_context *, const char *, struct nk_property_variant *, float, const enum nk_property_filter)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29010))), "void nk_property(struct nk_context *, const char *, struct nk_property_variant *, float, const enum nk_property_filter)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return;
    win = ctx.*.current;
    layout = win.*.layout;
    style = &ctx.*.style;
    s = nk_widget(&bounds, ctx);
    if (!(s != 0)) return;
    if (@as(c_int, @bitCast(@as(c_uint, name[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, '#')) {
        hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), nk_strlen(name), blk: {
            const ref = &win.*.property.seq;
            const tmp = ref.*;
            ref.* +%= 1;
            break :blk tmp;
        });
        name += 1;
    } else {
        hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(name)), nk_strlen(name), @as(nk_hash, @bitCast(@as(c_int, 42))));
    }
    if ((win.*.property.active != 0) and (hash == win.*.property.name)) {
        buffer = @as([*c]u8, @ptrCast(@alignCast(&win.*.property.buffer)));
        len = &win.*.property.length;
        cursor = &win.*.property.cursor;
        state = &win.*.property.state;
        select_begin = &win.*.property.select_start;
        select_end = &win.*.property.select_end;
    } else {
        buffer = @as([*c]u8, @ptrCast(@alignCast(&dummy_buffer)));
        len = &dummy_length;
        cursor = &dummy_cursor;
        state = &dummy_state;
        select_begin = &dummy_select_begin;
        select_end = &dummy_select_end;
    }
    old_state = state.*;
    ctx.*.text_edit.clip = ctx.*.clip;
    in = if ((((s == @as(c_uint, @bitCast(NK_WIDGET_ROM))) and !(win.*.property.active != 0)) or ((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) or (s == @as(c_uint, @bitCast(NK_WIDGET_DISABLED)))) null else &ctx.*.input;
    nk_do_property(&ctx.*.last_widget_state, &win.*.buffer, bounds, name, variant, inc_per_pixel, buffer, len, state, cursor, select_begin, select_end, &style.*.property, filter, in, style.*.font, &ctx.*.text_edit, ctx.*.button_behavior);
    if (((in != null) and (state.* != NK_PROPERTY_DEFAULT)) and !(win.*.property.active != 0)) {
        win.*.property.active = 1;
        _ = nk_memcopy(@as(?*anyopaque, @ptrCast(@as([*c]u8, @ptrCast(@alignCast(&win.*.property.buffer))))), @as(?*const anyopaque, @ptrCast(buffer)), @as(nk_size, @bitCast(@as(c_long, len.*))));
        win.*.property.length = len.*;
        win.*.property.cursor = cursor.*;
        win.*.property.state = state.*;
        win.*.property.name = hash;
        win.*.property.select_start = select_begin.*;
        win.*.property.select_end = select_end.*;
        if (state.* == NK_PROPERTY_DRAG) {
            ctx.*.input.mouse.grab = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
            ctx.*.input.mouse.grabbed = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
        }
    }
    if ((state.* == NK_PROPERTY_DEFAULT) and (old_state != NK_PROPERTY_DEFAULT)) {
        if (old_state == NK_PROPERTY_DRAG) {
            ctx.*.input.mouse.grab = @as(u8, @bitCast(@as(i8, @truncate(nk_false))));
            ctx.*.input.mouse.grabbed = @as(u8, @bitCast(@as(i8, @truncate(nk_false))));
            ctx.*.input.mouse.ungrab = @as(u8, @bitCast(@as(i8, @truncate(nk_true))));
        }
        win.*.property.select_start = 0;
        win.*.property.select_end = 0;
        win.*.property.active = 0;
    }
}
pub fn nk_str_match_here(arg_regexp: [*c]const u8, arg_text: [*c]const u8) callconv(.c) c_int {
    var regexp = arg_regexp;
    _ = &regexp;
    var text = arg_text;
    _ = &text;
    if (@as(c_int, @bitCast(@as(c_uint, regexp[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, '\x00')) return 1;
    if (@as(c_int, @bitCast(@as(c_uint, regexp[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, '*')) return nk_str_match_star(@as(c_int, @bitCast(@as(c_uint, regexp[@as(c_uint, @intCast(@as(c_int, 0)))]))), regexp + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 2))))), text);
    if ((@as(c_int, @bitCast(@as(c_uint, regexp[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, '$')) and (@as(c_int, @bitCast(@as(c_uint, regexp[@as(c_uint, @intCast(@as(c_int, 1)))]))) == @as(c_int, '\x00'))) return @intFromBool(@as(c_int, @bitCast(@as(c_uint, text.*))) == @as(c_int, '\x00'));
    if ((@as(c_int, @bitCast(@as(c_uint, text.*))) != @as(c_int, '\x00')) and ((@as(c_int, @bitCast(@as(c_uint, regexp[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, '.')) or (@as(c_int, @bitCast(@as(c_uint, regexp[@as(c_uint, @intCast(@as(c_int, 0)))]))) == @as(c_int, @bitCast(@as(c_uint, text.*)))))) return nk_str_match_here(regexp + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))), text + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))));
    return 0;
}
pub fn nk_str_match_star(arg_c: c_int, arg_regexp: [*c]const u8, arg_text: [*c]const u8) callconv(.c) c_int {
    var c = arg_c;
    _ = &c;
    var regexp = arg_regexp;
    _ = &regexp;
    var text = arg_text;
    _ = &text;
    while (true) {
        if (nk_str_match_here(regexp, text) != 0) return 1;
        if (!((@as(c_int, @bitCast(@as(c_uint, text.*))) != @as(c_int, '\x00')) and ((@as(c_int, @bitCast(@as(c_uint, (blk: {
            const ref = &text;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*))) == c) or (c == @as(c_int, '.'))))) break;
    }
    return 0;
}
pub fn nk_strrev_ascii(arg_s: [*c]u8) callconv(.c) void {
    var s = arg_s;
    _ = &s;
    var len: c_int = nk_strlen(s);
    _ = &len;
    var end: c_int = @divTrunc(len, @as(c_int, 2));
    _ = &end;
    var i: c_int = 0;
    _ = &i;
    var t: u8 = undefined;
    _ = &t;
    while (i < end) : (i += 1) {
        t = (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        (blk: {
            const tmp = i;
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = (blk: {
            const tmp = (len - @as(c_int, 1)) - i;
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*;
        (blk: {
            const tmp = (len - @as(c_int, 1)) - i;
            if (tmp >= 0) break :blk s + @as(usize, @intCast(tmp)) else break :blk s - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).* = t;
    }
}
pub fn nk_parse_hex(arg_p: [*c]const u8, arg_length: c_int) callconv(.c) c_int {
    var p = arg_p;
    _ = &p;
    var length = arg_length;
    _ = &length;
    var i: c_int = 0;
    _ = &i;
    var len: c_int = 0;
    _ = &len;
    while (len < length) {
        i <<= @intCast(@as(c_int, 4));
        if ((@as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = len;
            if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))) >= @as(c_int, 'a')) and (@as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = len;
            if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))) <= @as(c_int, 'f'))) {
            i += (@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = len;
                if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) - @as(c_int, 'a')) + @as(c_int, 10);
        } else if ((@as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = len;
            if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))) >= @as(c_int, 'A')) and (@as(c_int, @bitCast(@as(c_uint, (blk: {
            const tmp = len;
            if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
        }).*))) <= @as(c_int, 'F'))) {
            i += (@as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = len;
                if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) - @as(c_int, 'A')) + @as(c_int, 10);
        } else {
            i += @as(c_int, @bitCast(@as(c_uint, (blk: {
                const tmp = len;
                if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
            }).*))) - @as(c_int, '0');
        }
        len += 1;
    }
    return i;
}
pub const nk_utfbyte: [5]nk_byte = [5]nk_byte{
    128,
    0,
    192,
    224,
    240,
};
pub const nk_utfmask: [5]nk_byte = [5]nk_byte{
    192,
    128,
    224,
    240,
    248,
};
pub const nk_utfmin: [5]nk_uint = [5]nk_uint{
    0,
    0,
    128,
    @as(nk_uint, @bitCast(@as(c_int, 2048))),
    @as(nk_uint, @bitCast(@as(c_int, 65536))),
};
pub const nk_utfmax: [5]nk_uint = [5]nk_uint{
    @as(nk_uint, @bitCast(@as(c_int, 1114111))),
    127,
    @as(nk_uint, @bitCast(@as(c_int, 2047))),
    @as(nk_uint, @bitCast(@as(c_int, 65535))),
    @as(nk_uint, @bitCast(@as(c_int, 1114111))),
};
pub fn nk_utf_validate(arg_u: [*c]nk_rune, arg_i: c_int) callconv(.c) c_int {
    var u = arg_u;
    _ = &u;
    var i = arg_i;
    _ = &i;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (u != null) {} else {
                __assert_fail("u", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8353))), "int nk_utf_validate(nk_rune *, int)");
            };
        };
    };
    if (!(u != null)) return 0;
    if (!((nk_utfmin[@as(c_uint, @intCast(i))] <= u.*) and (u.* < nk_utfmax[@as(c_uint, @intCast(i))])) or ((@as(nk_rune, @bitCast(@as(c_int, 55296))) <= u.*) and (u.* < @as(nk_rune, @bitCast(@as(c_int, 57343)))))) {
        u.* = @as(nk_rune, @bitCast(@as(c_int, 65533)));
    }
    {
        i = 1;
        while (u.* > nk_utfmax[@as(c_uint, @intCast(i))]) : (i += 1) {}
    }
    return i;
}
pub fn nk_utf_decode_byte(arg_c: u8, arg_i: [*c]c_int) callconv(.c) nk_rune {
    var c = arg_c;
    _ = &c;
    var i = arg_i;
    _ = &i;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (i != null) {} else {
                __assert_fail("i", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 8364))), "nk_rune nk_utf_decode_byte(char, int *)");
            };
        };
    };
    if (!(i != null)) return 0;
    {
        i.* = 0;
        while (i.* < @as(c_int, @bitCast(@as(c_uint, @truncate(@sizeOf([5]nk_byte) / @sizeOf(nk_byte)))))) : (i.* += 1) {
            if ((@as(c_int, @bitCast(@as(c_uint, @as(nk_byte, @bitCast(c))))) & @as(c_int, @bitCast(@as(c_uint, nk_utfmask[@as(c_uint, @intCast(i.*))])))) == @as(c_int, @bitCast(@as(c_uint, nk_utfbyte[@as(c_uint, @intCast(i.*))])))) return @as(nk_rune, @bitCast(@as(c_uint, @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, c))) & ~@as(c_int, @bitCast(@as(c_uint, nk_utfmask[@as(c_uint, @intCast(i.*))]))))))))));
        }
    }
    return 0;
}
pub fn nk_utf_encode_byte(arg_u: nk_rune, arg_i: c_int) callconv(.c) u8 {
    var u = arg_u;
    _ = &u;
    var i = arg_i;
    _ = &i;
    return @as(u8, @bitCast(@as(i8, @truncate(@as(c_int, @bitCast(@as(c_uint, nk_utfbyte[@as(c_uint, @intCast(i))]))) | (@as(c_int, @bitCast(@as(c_uint, @as(nk_byte, @bitCast(@as(u8, @truncate(u))))))) & ~@as(c_int, @bitCast(@as(c_uint, nk_utfmask[@as(c_uint, @intCast(i))]))))))));
}
pub const stbrp_coord = c_int;
pub const struct_stbrp_node = extern struct {
    x: stbrp_coord = @import("std").mem.zeroes(stbrp_coord),
    y: stbrp_coord = @import("std").mem.zeroes(stbrp_coord),
    next: [*c]stbrp_node = @import("std").mem.zeroes([*c]stbrp_node),
};
pub const stbrp_node = struct_stbrp_node;
pub const struct_stbrp_context = extern struct {
    width: c_int = @import("std").mem.zeroes(c_int),
    height: c_int = @import("std").mem.zeroes(c_int),
    @"align": c_int = @import("std").mem.zeroes(c_int),
    init_mode: c_int = @import("std").mem.zeroes(c_int),
    heuristic: c_int = @import("std").mem.zeroes(c_int),
    num_nodes: c_int = @import("std").mem.zeroes(c_int),
    active_head: [*c]stbrp_node = @import("std").mem.zeroes([*c]stbrp_node),
    free_head: [*c]stbrp_node = @import("std").mem.zeroes([*c]stbrp_node),
    extra: [2]stbrp_node = @import("std").mem.zeroes([2]stbrp_node),
};
pub const stbrp_context = struct_stbrp_context;
pub const struct_stbrp_rect = extern struct {
    id: c_int = @import("std").mem.zeroes(c_int),
    w: stbrp_coord = @import("std").mem.zeroes(stbrp_coord),
    h: stbrp_coord = @import("std").mem.zeroes(stbrp_coord),
    x: stbrp_coord = @import("std").mem.zeroes(stbrp_coord),
    y: stbrp_coord = @import("std").mem.zeroes(stbrp_coord),
    was_packed: c_int = @import("std").mem.zeroes(c_int),
};
pub const stbrp_rect = struct_stbrp_rect;
pub extern fn stbrp_pack_rects(context: [*c]stbrp_context, rects: [*c]stbrp_rect, num_rects: c_int) c_int;
pub extern fn stbrp_init_target(context: [*c]stbrp_context, width: c_int, height: c_int, nodes: [*c]stbrp_node, num_nodes: c_int) void;
pub extern fn stbrp_setup_allow_out_of_mem(context: [*c]stbrp_context, allow_out_of_mem: c_int) void;
pub extern fn stbrp_setup_heuristic(context: [*c]stbrp_context, heuristic: c_int) void;
pub const STBRP_HEURISTIC_Skyline_default: c_int = 0;
pub const STBRP_HEURISTIC_Skyline_BL_sortHeight: c_int = 0;
pub const STBRP_HEURISTIC_Skyline_BF_sortHeight: c_int = 1;
const enum_unnamed_4 = c_uint;
pub const stbtt__buf = extern struct {
    data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    cursor: c_int = @import("std").mem.zeroes(c_int),
    size: c_int = @import("std").mem.zeroes(c_int),
};
pub const stbtt_bakedchar = extern struct {
    x0: c_ushort = @import("std").mem.zeroes(c_ushort),
    y0: c_ushort = @import("std").mem.zeroes(c_ushort),
    x1: c_ushort = @import("std").mem.zeroes(c_ushort),
    y1: c_ushort = @import("std").mem.zeroes(c_ushort),
    xoff: f32 = @import("std").mem.zeroes(f32),
    yoff: f32 = @import("std").mem.zeroes(f32),
    xadvance: f32 = @import("std").mem.zeroes(f32),
};
pub extern fn stbtt_BakeFontBitmap(data: [*c]const u8, offset: c_int, pixel_height: f32, pixels: [*c]u8, pw: c_int, ph: c_int, first_char: c_int, num_chars: c_int, chardata: [*c]stbtt_bakedchar) c_int;
pub const stbtt_aligned_quad = extern struct {
    x0: f32 = @import("std").mem.zeroes(f32),
    y0: f32 = @import("std").mem.zeroes(f32),
    s0: f32 = @import("std").mem.zeroes(f32),
    t0: f32 = @import("std").mem.zeroes(f32),
    x1: f32 = @import("std").mem.zeroes(f32),
    y1: f32 = @import("std").mem.zeroes(f32),
    s1: f32 = @import("std").mem.zeroes(f32),
    t1: f32 = @import("std").mem.zeroes(f32),
};
pub extern fn stbtt_GetBakedQuad(chardata: [*c]const stbtt_bakedchar, pw: c_int, ph: c_int, char_index: c_int, xpos: [*c]f32, ypos: [*c]f32, q: [*c]stbtt_aligned_quad, opengl_fillrule: c_int) void;
pub extern fn stbtt_GetScaledFontVMetrics(fontdata: [*c]const u8, index: c_int, size: f32, ascent: [*c]f32, descent: [*c]f32, lineGap: [*c]f32) void;
pub const stbtt_packedchar = extern struct {
    x0: c_ushort = @import("std").mem.zeroes(c_ushort),
    y0: c_ushort = @import("std").mem.zeroes(c_ushort),
    x1: c_ushort = @import("std").mem.zeroes(c_ushort),
    y1: c_ushort = @import("std").mem.zeroes(c_ushort),
    xoff: f32 = @import("std").mem.zeroes(f32),
    yoff: f32 = @import("std").mem.zeroes(f32),
    xadvance: f32 = @import("std").mem.zeroes(f32),
    xoff2: f32 = @import("std").mem.zeroes(f32),
    yoff2: f32 = @import("std").mem.zeroes(f32),
};
pub const struct_stbtt_pack_context = extern struct {
    user_allocator_context: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    pack_info: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    width: c_int = @import("std").mem.zeroes(c_int),
    height: c_int = @import("std").mem.zeroes(c_int),
    stride_in_bytes: c_int = @import("std").mem.zeroes(c_int),
    padding: c_int = @import("std").mem.zeroes(c_int),
    skip_missing: c_int = @import("std").mem.zeroes(c_int),
    h_oversample: c_uint = @import("std").mem.zeroes(c_uint),
    v_oversample: c_uint = @import("std").mem.zeroes(c_uint),
    pixels: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    nodes: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const stbtt_pack_context = struct_stbtt_pack_context;
pub const struct_stbtt_fontinfo = extern struct {
    userdata: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    fontstart: c_int = @import("std").mem.zeroes(c_int),
    numGlyphs: c_int = @import("std").mem.zeroes(c_int),
    loca: c_int = @import("std").mem.zeroes(c_int),
    head: c_int = @import("std").mem.zeroes(c_int),
    glyf: c_int = @import("std").mem.zeroes(c_int),
    hhea: c_int = @import("std").mem.zeroes(c_int),
    hmtx: c_int = @import("std").mem.zeroes(c_int),
    kern: c_int = @import("std").mem.zeroes(c_int),
    gpos: c_int = @import("std").mem.zeroes(c_int),
    svg: c_int = @import("std").mem.zeroes(c_int),
    index_map: c_int = @import("std").mem.zeroes(c_int),
    indexToLocFormat: c_int = @import("std").mem.zeroes(c_int),
    cff: stbtt__buf = @import("std").mem.zeroes(stbtt__buf),
    charstrings: stbtt__buf = @import("std").mem.zeroes(stbtt__buf),
    gsubrs: stbtt__buf = @import("std").mem.zeroes(stbtt__buf),
    subrs: stbtt__buf = @import("std").mem.zeroes(stbtt__buf),
    fontdicts: stbtt__buf = @import("std").mem.zeroes(stbtt__buf),
    fdselect: stbtt__buf = @import("std").mem.zeroes(stbtt__buf),
};
pub const stbtt_fontinfo = struct_stbtt_fontinfo;
pub extern fn stbtt_PackBegin(spc: [*c]stbtt_pack_context, pixels: [*c]u8, width: c_int, height: c_int, stride_in_bytes: c_int, padding: c_int, alloc_context: ?*anyopaque) c_int;
pub extern fn stbtt_PackEnd(spc: [*c]stbtt_pack_context) void;
pub extern fn stbtt_PackFontRange(spc: [*c]stbtt_pack_context, fontdata: [*c]const u8, font_index: c_int, font_size: f32, first_unicode_char_in_range: c_int, num_chars_in_range: c_int, chardata_for_range: [*c]stbtt_packedchar) c_int;
pub const stbtt_pack_range = extern struct {
    font_size: f32 = @import("std").mem.zeroes(f32),
    first_unicode_codepoint_in_range: c_int = @import("std").mem.zeroes(c_int),
    array_of_unicode_codepoints: [*c]c_int = @import("std").mem.zeroes([*c]c_int),
    num_chars: c_int = @import("std").mem.zeroes(c_int),
    chardata_for_range: [*c]stbtt_packedchar = @import("std").mem.zeroes([*c]stbtt_packedchar),
    h_oversample: u8 = @import("std").mem.zeroes(u8),
    v_oversample: u8 = @import("std").mem.zeroes(u8),
};
pub extern fn stbtt_PackFontRanges(spc: [*c]stbtt_pack_context, fontdata: [*c]const u8, font_index: c_int, ranges: [*c]stbtt_pack_range, num_ranges: c_int) c_int;
pub extern fn stbtt_PackSetOversampling(spc: [*c]stbtt_pack_context, h_oversample: c_uint, v_oversample: c_uint) void;
pub extern fn stbtt_PackSetSkipMissingCodepoints(spc: [*c]stbtt_pack_context, skip: c_int) void;
pub extern fn stbtt_GetPackedQuad(chardata: [*c]const stbtt_packedchar, pw: c_int, ph: c_int, char_index: c_int, xpos: [*c]f32, ypos: [*c]f32, q: [*c]stbtt_aligned_quad, align_to_integer: c_int) void;
pub extern fn stbtt_PackFontRangesGatherRects(spc: [*c]stbtt_pack_context, info: [*c]const stbtt_fontinfo, ranges: [*c]stbtt_pack_range, num_ranges: c_int, rects: [*c]stbrp_rect) c_int;
pub extern fn stbtt_PackFontRangesPackRects(spc: [*c]stbtt_pack_context, rects: [*c]stbrp_rect, num_rects: c_int) void;
pub extern fn stbtt_PackFontRangesRenderIntoRects(spc: [*c]stbtt_pack_context, info: [*c]const stbtt_fontinfo, ranges: [*c]stbtt_pack_range, num_ranges: c_int, rects: [*c]stbrp_rect) c_int;
pub extern fn stbtt_GetNumberOfFonts(data: [*c]const u8) c_int;
pub extern fn stbtt_GetFontOffsetForIndex(data: [*c]const u8, index: c_int) c_int;
pub extern fn stbtt_InitFont(info: [*c]stbtt_fontinfo, data: [*c]const u8, offset: c_int) c_int;
pub extern fn stbtt_FindGlyphIndex(info: [*c]const stbtt_fontinfo, unicode_codepoint: c_int) c_int;
pub extern fn stbtt_ScaleForPixelHeight(info: [*c]const stbtt_fontinfo, pixels: f32) f32;
pub extern fn stbtt_ScaleForMappingEmToPixels(info: [*c]const stbtt_fontinfo, pixels: f32) f32;
pub extern fn stbtt_GetFontVMetrics(info: [*c]const stbtt_fontinfo, ascent: [*c]c_int, descent: [*c]c_int, lineGap: [*c]c_int) void;
pub extern fn stbtt_GetFontVMetricsOS2(info: [*c]const stbtt_fontinfo, typoAscent: [*c]c_int, typoDescent: [*c]c_int, typoLineGap: [*c]c_int) c_int;
pub extern fn stbtt_GetFontBoundingBox(info: [*c]const stbtt_fontinfo, x0: [*c]c_int, y0: [*c]c_int, x1: [*c]c_int, y1: [*c]c_int) void;
pub extern fn stbtt_GetCodepointHMetrics(info: [*c]const stbtt_fontinfo, codepoint: c_int, advanceWidth: [*c]c_int, leftSideBearing: [*c]c_int) void;
pub extern fn stbtt_GetCodepointKernAdvance(info: [*c]const stbtt_fontinfo, ch1: c_int, ch2: c_int) c_int;
pub extern fn stbtt_GetCodepointBox(info: [*c]const stbtt_fontinfo, codepoint: c_int, x0: [*c]c_int, y0: [*c]c_int, x1: [*c]c_int, y1: [*c]c_int) c_int;
pub extern fn stbtt_GetGlyphHMetrics(info: [*c]const stbtt_fontinfo, glyph_index: c_int, advanceWidth: [*c]c_int, leftSideBearing: [*c]c_int) void;
pub extern fn stbtt_GetGlyphKernAdvance(info: [*c]const stbtt_fontinfo, glyph1: c_int, glyph2: c_int) c_int;
pub extern fn stbtt_GetGlyphBox(info: [*c]const stbtt_fontinfo, glyph_index: c_int, x0: [*c]c_int, y0: [*c]c_int, x1: [*c]c_int, y1: [*c]c_int) c_int;
pub const struct_stbtt_kerningentry = extern struct {
    glyph1: c_int = @import("std").mem.zeroes(c_int),
    glyph2: c_int = @import("std").mem.zeroes(c_int),
    advance: c_int = @import("std").mem.zeroes(c_int),
};
pub const stbtt_kerningentry = struct_stbtt_kerningentry;
pub extern fn stbtt_GetKerningTableLength(info: [*c]const stbtt_fontinfo) c_int;
pub extern fn stbtt_GetKerningTable(info: [*c]const stbtt_fontinfo, table: [*c]stbtt_kerningentry, table_length: c_int) c_int;
pub const STBTT_vmove: c_int = 1;
pub const STBTT_vline: c_int = 2;
pub const STBTT_vcurve: c_int = 3;
pub const STBTT_vcubic: c_int = 4;
const enum_unnamed_5 = c_uint;
pub const stbtt_vertex = extern struct {
    x: c_short = @import("std").mem.zeroes(c_short),
    y: c_short = @import("std").mem.zeroes(c_short),
    cx: c_short = @import("std").mem.zeroes(c_short),
    cy: c_short = @import("std").mem.zeroes(c_short),
    cx1: c_short = @import("std").mem.zeroes(c_short),
    cy1: c_short = @import("std").mem.zeroes(c_short),
    type: u8 = @import("std").mem.zeroes(u8),
    padding: u8 = @import("std").mem.zeroes(u8),
};
pub extern fn stbtt_IsGlyphEmpty(info: [*c]const stbtt_fontinfo, glyph_index: c_int) c_int;
pub extern fn stbtt_GetCodepointShape(info: [*c]const stbtt_fontinfo, unicode_codepoint: c_int, vertices: [*c][*c]stbtt_vertex) c_int;
pub extern fn stbtt_GetGlyphShape(info: [*c]const stbtt_fontinfo, glyph_index: c_int, vertices: [*c][*c]stbtt_vertex) c_int;
pub extern fn stbtt_FreeShape(info: [*c]const stbtt_fontinfo, vertices: [*c]stbtt_vertex) void;
pub extern fn stbtt_FindSVGDoc(info: [*c]const stbtt_fontinfo, gl: c_int) [*c]u8;
pub extern fn stbtt_GetCodepointSVG(info: [*c]const stbtt_fontinfo, unicode_codepoint: c_int, svg: [*c][*c]const u8) c_int;
pub extern fn stbtt_GetGlyphSVG(info: [*c]const stbtt_fontinfo, gl: c_int, svg: [*c][*c]const u8) c_int;
pub extern fn stbtt_FreeBitmap(bitmap: [*c]u8, userdata: ?*anyopaque) void;
pub extern fn stbtt_GetCodepointBitmap(info: [*c]const stbtt_fontinfo, scale_x: f32, scale_y: f32, codepoint: c_int, width: [*c]c_int, height: [*c]c_int, xoff: [*c]c_int, yoff: [*c]c_int) [*c]u8;
pub extern fn stbtt_GetCodepointBitmapSubpixel(info: [*c]const stbtt_fontinfo, scale_x: f32, scale_y: f32, shift_x: f32, shift_y: f32, codepoint: c_int, width: [*c]c_int, height: [*c]c_int, xoff: [*c]c_int, yoff: [*c]c_int) [*c]u8;
pub extern fn stbtt_MakeCodepointBitmap(info: [*c]const stbtt_fontinfo, output: [*c]u8, out_w: c_int, out_h: c_int, out_stride: c_int, scale_x: f32, scale_y: f32, codepoint: c_int) void;
pub extern fn stbtt_MakeCodepointBitmapSubpixel(info: [*c]const stbtt_fontinfo, output: [*c]u8, out_w: c_int, out_h: c_int, out_stride: c_int, scale_x: f32, scale_y: f32, shift_x: f32, shift_y: f32, codepoint: c_int) void;
pub extern fn stbtt_MakeCodepointBitmapSubpixelPrefilter(info: [*c]const stbtt_fontinfo, output: [*c]u8, out_w: c_int, out_h: c_int, out_stride: c_int, scale_x: f32, scale_y: f32, shift_x: f32, shift_y: f32, oversample_x: c_int, oversample_y: c_int, sub_x: [*c]f32, sub_y: [*c]f32, codepoint: c_int) void;
pub extern fn stbtt_GetCodepointBitmapBox(font: [*c]const stbtt_fontinfo, codepoint: c_int, scale_x: f32, scale_y: f32, ix0: [*c]c_int, iy0: [*c]c_int, ix1: [*c]c_int, iy1: [*c]c_int) void;
pub extern fn stbtt_GetCodepointBitmapBoxSubpixel(font: [*c]const stbtt_fontinfo, codepoint: c_int, scale_x: f32, scale_y: f32, shift_x: f32, shift_y: f32, ix0: [*c]c_int, iy0: [*c]c_int, ix1: [*c]c_int, iy1: [*c]c_int) void;
pub extern fn stbtt_GetGlyphBitmap(info: [*c]const stbtt_fontinfo, scale_x: f32, scale_y: f32, glyph: c_int, width: [*c]c_int, height: [*c]c_int, xoff: [*c]c_int, yoff: [*c]c_int) [*c]u8;
pub extern fn stbtt_GetGlyphBitmapSubpixel(info: [*c]const stbtt_fontinfo, scale_x: f32, scale_y: f32, shift_x: f32, shift_y: f32, glyph: c_int, width: [*c]c_int, height: [*c]c_int, xoff: [*c]c_int, yoff: [*c]c_int) [*c]u8;
pub extern fn stbtt_MakeGlyphBitmap(info: [*c]const stbtt_fontinfo, output: [*c]u8, out_w: c_int, out_h: c_int, out_stride: c_int, scale_x: f32, scale_y: f32, glyph: c_int) void;
pub extern fn stbtt_MakeGlyphBitmapSubpixel(info: [*c]const stbtt_fontinfo, output: [*c]u8, out_w: c_int, out_h: c_int, out_stride: c_int, scale_x: f32, scale_y: f32, shift_x: f32, shift_y: f32, glyph: c_int) void;
pub extern fn stbtt_MakeGlyphBitmapSubpixelPrefilter(info: [*c]const stbtt_fontinfo, output: [*c]u8, out_w: c_int, out_h: c_int, out_stride: c_int, scale_x: f32, scale_y: f32, shift_x: f32, shift_y: f32, oversample_x: c_int, oversample_y: c_int, sub_x: [*c]f32, sub_y: [*c]f32, glyph: c_int) void;
pub extern fn stbtt_GetGlyphBitmapBox(font: [*c]const stbtt_fontinfo, glyph: c_int, scale_x: f32, scale_y: f32, ix0: [*c]c_int, iy0: [*c]c_int, ix1: [*c]c_int, iy1: [*c]c_int) void;
pub extern fn stbtt_GetGlyphBitmapBoxSubpixel(font: [*c]const stbtt_fontinfo, glyph: c_int, scale_x: f32, scale_y: f32, shift_x: f32, shift_y: f32, ix0: [*c]c_int, iy0: [*c]c_int, ix1: [*c]c_int, iy1: [*c]c_int) void;
pub const stbtt__bitmap = extern struct {
    w: c_int = @import("std").mem.zeroes(c_int),
    h: c_int = @import("std").mem.zeroes(c_int),
    stride: c_int = @import("std").mem.zeroes(c_int),
    pixels: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub extern fn stbtt_Rasterize(result: [*c]stbtt__bitmap, flatness_in_pixels: f32, vertices: [*c]stbtt_vertex, num_verts: c_int, scale_x: f32, scale_y: f32, shift_x: f32, shift_y: f32, x_off: c_int, y_off: c_int, invert: c_int, userdata: ?*anyopaque) void;
pub extern fn stbtt_FreeSDF(bitmap: [*c]u8, userdata: ?*anyopaque) void;
pub extern fn stbtt_GetGlyphSDF(info: [*c]const stbtt_fontinfo, scale: f32, glyph: c_int, padding: c_int, onedge_value: u8, pixel_dist_scale: f32, width: [*c]c_int, height: [*c]c_int, xoff: [*c]c_int, yoff: [*c]c_int) [*c]u8;
pub extern fn stbtt_GetCodepointSDF(info: [*c]const stbtt_fontinfo, scale: f32, codepoint: c_int, padding: c_int, onedge_value: u8, pixel_dist_scale: f32, width: [*c]c_int, height: [*c]c_int, xoff: [*c]c_int, yoff: [*c]c_int) [*c]u8;
pub extern fn stbtt_FindMatchingFont(fontdata: [*c]const u8, name: [*c]const u8, flags: c_int) c_int;
pub extern fn stbtt_CompareUTF8toUTF16_bigendian(s1: [*c]const u8, len1: c_int, s2: [*c]const u8, len2: c_int) c_int;
pub extern fn stbtt_GetFontNameString(font: [*c]const stbtt_fontinfo, length: [*c]c_int, platformID: c_int, encodingID: c_int, languageID: c_int, nameID: c_int) [*c]const u8;
pub const STBTT_PLATFORM_ID_UNICODE: c_int = 0;
pub const STBTT_PLATFORM_ID_MAC: c_int = 1;
pub const STBTT_PLATFORM_ID_ISO: c_int = 2;
pub const STBTT_PLATFORM_ID_MICROSOFT: c_int = 3;
const enum_unnamed_6 = c_uint;
pub const STBTT_UNICODE_EID_UNICODE_1_0: c_int = 0;
pub const STBTT_UNICODE_EID_UNICODE_1_1: c_int = 1;
pub const STBTT_UNICODE_EID_ISO_10646: c_int = 2;
pub const STBTT_UNICODE_EID_UNICODE_2_0_BMP: c_int = 3;
pub const STBTT_UNICODE_EID_UNICODE_2_0_FULL: c_int = 4;
const enum_unnamed_7 = c_uint;
pub const STBTT_MS_EID_SYMBOL: c_int = 0;
pub const STBTT_MS_EID_UNICODE_BMP: c_int = 1;
pub const STBTT_MS_EID_SHIFTJIS: c_int = 2;
pub const STBTT_MS_EID_UNICODE_FULL: c_int = 10;
const enum_unnamed_8 = c_uint;
pub const STBTT_MAC_EID_ROMAN: c_int = 0;
pub const STBTT_MAC_EID_ARABIC: c_int = 4;
pub const STBTT_MAC_EID_JAPANESE: c_int = 1;
pub const STBTT_MAC_EID_HEBREW: c_int = 5;
pub const STBTT_MAC_EID_CHINESE_TRAD: c_int = 2;
pub const STBTT_MAC_EID_GREEK: c_int = 6;
pub const STBTT_MAC_EID_KOREAN: c_int = 3;
pub const STBTT_MAC_EID_RUSSIAN: c_int = 7;
const enum_unnamed_9 = c_uint;
pub const STBTT_MS_LANG_ENGLISH: c_int = 1033;
pub const STBTT_MS_LANG_ITALIAN: c_int = 1040;
pub const STBTT_MS_LANG_CHINESE: c_int = 2052;
pub const STBTT_MS_LANG_JAPANESE: c_int = 1041;
pub const STBTT_MS_LANG_DUTCH: c_int = 1043;
pub const STBTT_MS_LANG_KOREAN: c_int = 1042;
pub const STBTT_MS_LANG_FRENCH: c_int = 1036;
pub const STBTT_MS_LANG_RUSSIAN: c_int = 1049;
pub const STBTT_MS_LANG_GERMAN: c_int = 1031;
pub const STBTT_MS_LANG_SPANISH: c_int = 1033;
pub const STBTT_MS_LANG_HEBREW: c_int = 1037;
pub const STBTT_MS_LANG_SWEDISH: c_int = 1053;
const enum_unnamed_10 = c_uint;
pub const STBTT_MAC_LANG_ENGLISH: c_int = 0;
pub const STBTT_MAC_LANG_JAPANESE: c_int = 11;
pub const STBTT_MAC_LANG_ARABIC: c_int = 12;
pub const STBTT_MAC_LANG_KOREAN: c_int = 23;
pub const STBTT_MAC_LANG_DUTCH: c_int = 4;
pub const STBTT_MAC_LANG_RUSSIAN: c_int = 32;
pub const STBTT_MAC_LANG_FRENCH: c_int = 1;
pub const STBTT_MAC_LANG_SPANISH: c_int = 6;
pub const STBTT_MAC_LANG_GERMAN: c_int = 2;
pub const STBTT_MAC_LANG_SWEDISH: c_int = 5;
pub const STBTT_MAC_LANG_HEBREW: c_int = 10;
pub const STBTT_MAC_LANG_CHINESE_SIMPLIFIED: c_int = 33;
pub const STBTT_MAC_LANG_ITALIAN: c_int = 3;
pub const STBTT_MAC_LANG_CHINESE_TRAD: c_int = 19;
const enum_unnamed_11 = c_uint;
pub const nk_default_color_style: [32]struct_nk_color = [32]struct_nk_color{
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 175))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 175))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 175))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 65))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 65))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 65))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 50))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 50))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 50))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 35))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 35))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 35))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 35))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 35))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 35))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 150))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 150))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 150))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 175))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 175))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 175))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 45))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 0))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 150))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 150))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 150))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 40))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 38))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 100))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 120))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
    struct_nk_color{
        .r = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 150))))),
        .g = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 150))))),
        .b = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 150))))),
        .a = @as(nk_byte, @bitCast(@as(i8, @truncate(@as(c_int, 255))))),
    },
};
pub var nk_color_names: [32][*c]const u8 = [32][*c]const u8{
    "NK_COLOR_TEXT",
    "NK_COLOR_WINDOW",
    "NK_COLOR_HEADER",
    "NK_COLOR_BORDER",
    "NK_COLOR_BUTTON",
    "NK_COLOR_BUTTON_HOVER",
    "NK_COLOR_BUTTON_ACTIVE",
    "NK_COLOR_TOGGLE",
    "NK_COLOR_TOGGLE_HOVER",
    "NK_COLOR_TOGGLE_CURSOR",
    "NK_COLOR_SELECT",
    "NK_COLOR_SELECT_ACTIVE",
    "NK_COLOR_SLIDER",
    "NK_COLOR_SLIDER_CURSOR",
    "NK_COLOR_SLIDER_CURSOR_HOVER",
    "NK_COLOR_SLIDER_CURSOR_ACTIVE",
    "NK_COLOR_PROPERTY",
    "NK_COLOR_EDIT",
    "NK_COLOR_EDIT_CURSOR",
    "NK_COLOR_COMBO",
    "NK_COLOR_CHART",
    "NK_COLOR_CHART_COLOR",
    "NK_COLOR_CHART_COLOR_HIGHLIGHT",
    "NK_COLOR_SCROLLBAR",
    "NK_COLOR_SCROLLBAR_CURSOR",
    "NK_COLOR_SCROLLBAR_CURSOR_HOVER",
    "NK_COLOR_SCROLLBAR_CURSOR_ACTIVE",
    "NK_COLOR_TAB_HEADER",
    "NK_COLOR_KNOB",
    "NK_COLOR_KNOB_CURSOR",
    "NK_COLOR_KNOB_CURSOR_HOVER",
    "NK_COLOR_KNOB_CURSOR_ACTIVE",
};
pub fn nk_setup(arg_ctx: [*c]struct_nk_context, arg_font: [*c]const struct_nk_user_font) callconv(.c) void {
    var ctx = arg_ctx;
    _ = &ctx;
    var font = arg_font;
    _ = &font;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 19342))), "void nk_setup(struct nk_context *, const struct nk_user_font *)");
            };
        };
    };
    if (!(ctx != null)) return;
    nk_zero(@as(?*anyopaque, @ptrCast(&ctx.*)), @sizeOf(struct_nk_context));
    nk_style_default(ctx);
    ctx.*.seq = 1;
    if (font != null) {
        ctx.*.style.font = font;
    }
}
pub fn nk_menu_begin(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window, arg_id: [*c]const u8, arg_is_clicked: c_int, arg_header: struct_nk_rect, arg_size: struct_nk_vec2) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var id = arg_id;
    _ = &id;
    var is_clicked = arg_is_clicked;
    _ = &is_clicked;
    var header = arg_header;
    _ = &header;
    var size = arg_size;
    _ = &size;
    var is_open: c_int = 0;
    _ = &is_open;
    var is_active: c_int = 0;
    _ = &is_active;
    var body: struct_nk_rect = undefined;
    _ = &body;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    var hash: nk_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(id)), nk_strlen(id), @as(nk_hash, @bitCast(NK_PANEL_MENU)));
    _ = &hash;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21778))), "int nk_menu_begin(struct nk_context *, struct nk_window *, const char *, int, struct nk_rect, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21779))), "int nk_menu_begin(struct nk_context *, struct nk_window *, const char *, int, struct nk_rect, struct nk_vec2)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 21780))), "int nk_menu_begin(struct nk_context *, struct nk_window *, const char *, int, struct nk_rect, struct nk_vec2)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    body.x = header.x;
    body.w = size.x;
    body.y = header.y + header.h;
    body.h = size.y;
    popup = win.*.popup.win;
    is_open = if (popup != null) nk_true else nk_false;
    is_active = @intFromBool(((popup != null) and (win.*.popup.name == hash)) and (win.*.popup.type == @as(c_uint, @bitCast(NK_PANEL_MENU))));
    if (((((is_clicked != 0) and (is_open != 0)) and !(is_active != 0)) or ((is_open != 0) and !(is_active != 0))) or ((!(is_open != 0) and !(is_active != 0)) and !(is_clicked != 0))) return 0;
    if (!(nk_nonblock_begin(ctx, @as(nk_flags, @bitCast(NK_WINDOW_NO_SCROLLBAR)), body, header, @as(c_uint, @bitCast(NK_PANEL_MENU))) != 0)) return 0;
    win.*.popup.type = @as(c_uint, @bitCast(NK_PANEL_MENU));
    win.*.popup.name = hash;
    return 1;
}
pub fn nk_tree_state_base(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_img: [*c]struct_nk_image, arg_title: [*c]const u8, arg_state: [*c]enum_nk_collapse_states) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var img = arg_img;
    _ = &img;
    var title = arg_title;
    _ = &title;
    var state = arg_state;
    _ = &state;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var out: [*c]struct_nk_command_buffer = undefined;
    _ = &out;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var button: [*c]const struct_nk_style_button = undefined;
    _ = &button;
    var symbol: enum_nk_symbol_type = undefined;
    _ = &symbol;
    var row_height: f32 = undefined;
    _ = &row_height;
    var item_spacing: struct_nk_vec2 = undefined;
    _ = &item_spacing;
    var header: struct_nk_rect = struct_nk_rect{
        .x = @as(f32, @floatFromInt(@as(c_int, 0))),
        .y = @as(f32, @floatFromInt(@as(c_int, 0))),
        .w = @as(f32, @floatFromInt(@as(c_int, 0))),
        .h = @as(f32, @floatFromInt(@as(c_int, 0))),
    };
    _ = &header;
    var sym: struct_nk_rect = struct_nk_rect{
        .x = @as(f32, @floatFromInt(@as(c_int, 0))),
        .y = @as(f32, @floatFromInt(@as(c_int, 0))),
        .w = @as(f32, @floatFromInt(@as(c_int, 0))),
        .h = @as(f32, @floatFromInt(@as(c_int, 0))),
    };
    _ = &sym;
    var text: struct_nk_text = undefined;
    _ = &text;
    var ws: nk_flags = 0;
    _ = &ws;
    var widget_state: enum_nk_widget_layout_states = undefined;
    _ = &widget_state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22786))), "int nk_tree_state_base(struct nk_context *, enum nk_tree_type, struct nk_image *, const char *, enum nk_collapse_states *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22787))), "int nk_tree_state_base(struct nk_context *, enum nk_tree_type, struct nk_image *, const char *, enum nk_collapse_states *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22788))), "int nk_tree_state_base(struct nk_context *, enum nk_tree_type, struct nk_image *, const char *, enum nk_collapse_states *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    out = &win.*.buffer;
    style = &ctx.*.style;
    item_spacing = style.*.window.spacing;
    row_height = style.*.font.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.tab.padding.y);
    nk_layout_set_min_row_height(ctx, row_height);
    nk_layout_row_dynamic(ctx, row_height, @as(c_int, 1));
    nk_layout_reset_min_row_height(ctx);
    widget_state = nk_widget(&header, ctx);
    if (@"type" == @as(c_uint, @bitCast(NK_TREE_TAB))) {
        var background: [*c]const struct_nk_style_item = &style.*.tab.background;
        _ = &background;
        while (true) {
            switch (background.*.type) {
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    nk_draw_image(out, header, &background.*.data.image, nk_rgb_factor(nk_white, style.*.tab.color_factor));
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    nk_draw_nine_slice(out, header, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.tab.color_factor));
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 0))) => {
                    nk_fill_rect(out, header, @as(f32, @floatFromInt(@as(c_int, 0))), nk_rgb_factor(style.*.tab.border_color, style.*.tab.color_factor));
                    nk_fill_rect(out, nk_shrink_rect(header, style.*.tab.border), style.*.tab.rounding, nk_rgb_factor(background.*.data.color, style.*.tab.color_factor));
                    break;
                },
                else => {},
            }
            break;
        }
    } else {
        text.background = style.*.window.background;
    }
    in = if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) &ctx.*.input else null;
    in = if ((in != null) and (widget_state == @as(c_uint, @bitCast(NK_WIDGET_VALID)))) &ctx.*.input else null;
    if (nk_button_behavior(&ws, header, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        state.* = @as(c_uint, @bitCast(if (state.* == @as(c_uint, @bitCast(NK_MAXIMIZED))) NK_MINIMIZED else NK_MAXIMIZED));
    }
    if (state.* == @as(c_uint, @bitCast(NK_MAXIMIZED))) {
        symbol = style.*.tab.sym_maximize;
        if (@"type" == @as(c_uint, @bitCast(NK_TREE_TAB))) {
            button = &style.*.tab.tab_maximize_button;
        } else {
            button = &style.*.tab.node_maximize_button;
        }
    } else {
        symbol = style.*.tab.sym_minimize;
        if (@"type" == @as(c_uint, @bitCast(NK_TREE_TAB))) {
            button = &style.*.tab.tab_minimize_button;
        } else {
            button = &style.*.tab.node_minimize_button;
        }
    }
    {
        sym.w = blk: {
            const tmp = style.*.font.*.height;
            sym.h = tmp;
            break :blk tmp;
        };
        sym.y = header.y + style.*.tab.padding.y;
        sym.x = header.x + style.*.tab.padding.x;
        _ = nk_do_button_symbol(&ws, &win.*.buffer, sym, symbol, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), button, null, style.*.font);
        if (img != null) {
            sym.x = (sym.x + sym.w) + (@as(f32, @floatFromInt(@as(c_int, 4))) * item_spacing.x);
            nk_draw_image(&win.*.buffer, sym, img, nk_white);
            sym.w = style.*.font.*.height + style.*.tab.spacing.x;
        }
    }
    {
        var label: struct_nk_rect = undefined;
        _ = &label;
        header.w = if (header.w < (sym.w + item_spacing.x)) sym.w + item_spacing.x else header.w;
        label.x = (sym.x + sym.w) + item_spacing.x;
        label.y = sym.y;
        label.w = header.w - ((sym.w + item_spacing.y) + style.*.tab.indent);
        label.h = style.*.font.*.height;
        text.text = nk_rgb_factor(style.*.tab.text, style.*.tab.color_factor);
        text.padding = nk_vec2(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))));
        nk_widget_text(out, label, title, nk_strlen(title), &text, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), style.*.font);
    }
    if (state.* == @as(c_uint, @bitCast(NK_MAXIMIZED))) {
        layout.*.at_x = (header.x + @as(f32, @floatFromInt(layout.*.offset_x.*))) + style.*.tab.indent;
        layout.*.bounds.w = if (layout.*.bounds.w < style.*.tab.indent) style.*.tab.indent else layout.*.bounds.w;
        layout.*.bounds.w -= style.*.tab.indent + style.*.window.padding.x;
        layout.*.row.tree_depth += 1;
        return nk_true;
    } else return nk_false;
    return 0;
}
pub fn nk_tree_base(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_img: [*c]struct_nk_image, arg_title: [*c]const u8, arg_initial_state: enum_nk_collapse_states, arg_hash: [*c]const u8, arg_len: c_int, arg_line: c_int) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var img = arg_img;
    _ = &img;
    var title = arg_title;
    _ = &title;
    var initial_state = arg_initial_state;
    _ = &initial_state;
    var hash = arg_hash;
    _ = &hash;
    var len = arg_len;
    _ = &len;
    var line = arg_line;
    _ = &line;
    var win: [*c]struct_nk_window = ctx.*.current;
    _ = &win;
    var title_len: c_int = 0;
    _ = &title_len;
    var tree_hash: nk_hash = 0;
    _ = &tree_hash;
    var state: [*c]nk_uint = null;
    _ = &state;
    if (!(hash != null)) {
        title_len = nk_strlen(title);
        tree_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(title)), title_len, @as(nk_hash, @bitCast(line)));
    } else {
        tree_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(hash)), len, @as(nk_hash, @bitCast(line)));
    }
    state = nk_find_value(win, tree_hash);
    if (!(state != null)) {
        state = nk_add_value(ctx, win, tree_hash, @as(nk_uint, @bitCast(@as(c_int, 0))));
        state.* = @as(nk_uint, @bitCast(initial_state));
    }
    return nk_tree_state_base(ctx, @"type", img, title, @as([*c]enum_nk_collapse_states, @ptrCast(@alignCast(state))));
}
pub fn nk_tree_element_image_push_hashed_base(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_img: [*c]struct_nk_image, arg_title: [*c]const u8, arg_title_len: c_int, arg_state: [*c]enum_nk_collapse_states, arg_selected: [*c]nk_bool) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var img = arg_img;
    _ = &img;
    var title = arg_title;
    _ = &title;
    var title_len = arg_title_len;
    _ = &title_len;
    var state = arg_state;
    _ = &state;
    var selected = arg_selected;
    _ = &selected;
    var win: [*c]struct_nk_window = undefined;
    _ = &win;
    var layout: [*c]struct_nk_panel = undefined;
    _ = &layout;
    var style: [*c]const struct_nk_style = undefined;
    _ = &style;
    var out: [*c]struct_nk_command_buffer = undefined;
    _ = &out;
    var in: [*c]const struct_nk_input = undefined;
    _ = &in;
    var button: [*c]const struct_nk_style_button = undefined;
    _ = &button;
    var symbol: enum_nk_symbol_type = undefined;
    _ = &symbol;
    var row_height: f32 = undefined;
    _ = &row_height;
    var padding: struct_nk_vec2 = undefined;
    _ = &padding;
    var text_len: c_int = undefined;
    _ = &text_len;
    var text_width: f32 = undefined;
    _ = &text_width;
    var item_spacing: struct_nk_vec2 = undefined;
    _ = &item_spacing;
    var header: struct_nk_rect = struct_nk_rect{
        .x = @as(f32, @floatFromInt(@as(c_int, 0))),
        .y = @as(f32, @floatFromInt(@as(c_int, 0))),
        .w = @as(f32, @floatFromInt(@as(c_int, 0))),
        .h = @as(f32, @floatFromInt(@as(c_int, 0))),
    };
    _ = &header;
    var sym: struct_nk_rect = struct_nk_rect{
        .x = @as(f32, @floatFromInt(@as(c_int, 0))),
        .y = @as(f32, @floatFromInt(@as(c_int, 0))),
        .w = @as(f32, @floatFromInt(@as(c_int, 0))),
        .h = @as(f32, @floatFromInt(@as(c_int, 0))),
    };
    _ = &sym;
    var ws: nk_flags = 0;
    _ = &ws;
    var widget_state: enum_nk_widget_layout_states = undefined;
    _ = &widget_state;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22975))), "int nk_tree_element_image_push_hashed_base(struct nk_context *, enum nk_tree_type, struct nk_image *, const char *, int, enum nk_collapse_states *, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22976))), "int nk_tree_element_image_push_hashed_base(struct nk_context *, enum nk_tree_type, struct nk_image *, const char *, int, enum nk_collapse_states *, nk_bool *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 22977))), "int nk_tree_element_image_push_hashed_base(struct nk_context *, enum nk_tree_type, struct nk_image *, const char *, int, enum nk_collapse_states *, nk_bool *)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    win = ctx.*.current;
    layout = win.*.layout;
    out = &win.*.buffer;
    style = &ctx.*.style;
    item_spacing = style.*.window.spacing;
    padding = style.*.selectable.padding;
    row_height = style.*.font.*.height + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.tab.padding.y);
    nk_layout_set_min_row_height(ctx, row_height);
    nk_layout_row_dynamic(ctx, row_height, @as(c_int, 1));
    nk_layout_reset_min_row_height(ctx);
    widget_state = nk_widget(&header, ctx);
    if (@"type" == @as(c_uint, @bitCast(NK_TREE_TAB))) {
        var background: [*c]const struct_nk_style_item = &style.*.tab.background;
        _ = &background;
        while (true) {
            switch (background.*.type) {
                @as(c_uint, @bitCast(@as(c_int, 1))) => {
                    nk_draw_image(out, header, &background.*.data.image, nk_rgb_factor(nk_white, style.*.tab.color_factor));
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 2))) => {
                    nk_draw_nine_slice(out, header, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.tab.color_factor));
                    break;
                },
                @as(c_uint, @bitCast(@as(c_int, 0))) => {
                    nk_fill_rect(out, header, @as(f32, @floatFromInt(@as(c_int, 0))), nk_rgb_factor(style.*.tab.border_color, style.*.tab.color_factor));
                    nk_fill_rect(out, nk_shrink_rect(header, style.*.tab.border), style.*.tab.rounding, nk_rgb_factor(background.*.data.color, style.*.tab.color_factor));
                    break;
                },
                else => {},
            }
            break;
        }
    }
    in = if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) &ctx.*.input else null;
    in = if ((in != null) and (widget_state == @as(c_uint, @bitCast(NK_WIDGET_VALID)))) &ctx.*.input else null;
    if (state.* == @as(c_uint, @bitCast(NK_MAXIMIZED))) {
        symbol = style.*.tab.sym_maximize;
        if (@"type" == @as(c_uint, @bitCast(NK_TREE_TAB))) {
            button = &style.*.tab.tab_maximize_button;
        } else {
            button = &style.*.tab.node_maximize_button;
        }
    } else {
        symbol = style.*.tab.sym_minimize;
        if (@"type" == @as(c_uint, @bitCast(NK_TREE_TAB))) {
            button = &style.*.tab.tab_minimize_button;
        } else {
            button = &style.*.tab.node_minimize_button;
        }
    }
    {
        sym.w = blk: {
            const tmp = style.*.font.*.height;
            sym.h = tmp;
            break :blk tmp;
        };
        sym.y = header.y + style.*.tab.padding.y;
        sym.x = header.x + style.*.tab.padding.x;
        if (nk_do_button_symbol(&ws, &win.*.buffer, sym, symbol, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT)), button, in, style.*.font) != 0) {
            state.* = @as(c_uint, @bitCast(if (state.* == @as(c_uint, @bitCast(NK_MAXIMIZED))) NK_MINIMIZED else NK_MAXIMIZED));
        }
    }
    {
        var dummy: nk_flags = 0;
        _ = &dummy;
        var label: struct_nk_rect = undefined;
        _ = &label;
        text_len = nk_strlen(title);
        text_width = style.*.font.*.width.?(style.*.font.*.userdata, style.*.font.*.height, title, text_len);
        text_width += @as(f32, @floatFromInt(@as(c_int, 4))) * padding.x;
        header.w = if (header.w < (sym.w + item_spacing.x)) sym.w + item_spacing.x else header.w;
        label.x = (sym.x + sym.w) + item_spacing.x;
        label.y = sym.y;
        label.w = if ((header.w - ((sym.w + item_spacing.y) + style.*.tab.indent)) < text_width) header.w - ((sym.w + item_spacing.y) + style.*.tab.indent) else text_width;
        label.h = style.*.font.*.height;
        if (img != null) {
            _ = nk_do_selectable_image(&dummy, &win.*.buffer, label, title, title_len, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), selected, img, &style.*.selectable, in, style.*.font);
        } else {
            _ = nk_do_selectable(&dummy, &win.*.buffer, label, title, title_len, @as(nk_flags, @bitCast(NK_TEXT_LEFT)), selected, &style.*.selectable, in, style.*.font);
        }
    }
    if (state.* == @as(c_uint, @bitCast(NK_MAXIMIZED))) {
        layout.*.at_x = (header.x + @as(f32, @floatFromInt(layout.*.offset_x.*))) + style.*.tab.indent;
        layout.*.bounds.w = if (layout.*.bounds.w < style.*.tab.indent) style.*.tab.indent else layout.*.bounds.w;
        layout.*.bounds.w -= style.*.tab.indent + style.*.window.padding.x;
        layout.*.row.tree_depth += 1;
        return nk_true;
    } else return nk_false;
    return 0;
}
pub fn nk_tree_element_base(arg_ctx: [*c]struct_nk_context, arg_type: enum_nk_tree_type, arg_img: [*c]struct_nk_image, arg_title: [*c]const u8, arg_initial_state: enum_nk_collapse_states, arg_selected: [*c]nk_bool, arg_hash: [*c]const u8, arg_len: c_int, arg_line: c_int) callconv(.c) c_int {
    var ctx = arg_ctx;
    _ = &ctx;
    var @"type" = arg_type;
    _ = &@"type";
    var img = arg_img;
    _ = &img;
    var title = arg_title;
    _ = &title;
    var initial_state = arg_initial_state;
    _ = &initial_state;
    var selected = arg_selected;
    _ = &selected;
    var hash = arg_hash;
    _ = &hash;
    var len = arg_len;
    _ = &len;
    var line = arg_line;
    _ = &line;
    var win: [*c]struct_nk_window = ctx.*.current;
    _ = &win;
    var title_len: c_int = 0;
    _ = &title_len;
    var tree_hash: nk_hash = 0;
    _ = &tree_hash;
    var state: [*c]nk_uint = null;
    _ = &state;
    if (!(hash != null)) {
        title_len = nk_strlen(title);
        tree_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(title)), title_len, @as(nk_hash, @bitCast(line)));
    } else {
        tree_hash = nk_murmur_hash(@as(?*const anyopaque, @ptrCast(hash)), len, @as(nk_hash, @bitCast(line)));
    }
    state = nk_find_value(win, tree_hash);
    if (!(state != null)) {
        state = nk_add_value(ctx, win, tree_hash, @as(nk_uint, @bitCast(@as(c_int, 0))));
        state.* = @as(nk_uint, @bitCast(initial_state));
    }
    return nk_tree_element_image_push_hashed_base(ctx, @"type", img, title, nk_strlen(title), @as([*c]enum_nk_collapse_states, @ptrCast(@alignCast(state))), selected);
}
pub fn nk_do_selectable_symbol(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_str: [*c]const u8, arg_len: c_int, arg_align: nk_flags, arg_value: [*c]nk_bool, arg_sym: enum_nk_symbol_type, arg_style: [*c]const struct_nk_style_selectable, arg_in: [*c]const struct_nk_input, arg_font: [*c]const struct_nk_user_font) callconv(.c) nk_bool {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var str = arg_str;
    _ = &str;
    var len = arg_len;
    _ = &len;
    var @"align" = arg_align;
    _ = &@"align";
    var value = arg_value;
    _ = &value;
    var sym = arg_sym;
    _ = &sym;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var font = arg_font;
    _ = &font;
    var old_value: c_int = undefined;
    _ = &old_value;
    var touch: struct_nk_rect = undefined;
    _ = &touch;
    var icon: struct_nk_rect = undefined;
    _ = &icon;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (state != null) {} else {
                __assert_fail("state", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25620))), "nk_bool nk_do_selectable_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, enum nk_symbol_type, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25621))), "nk_bool nk_do_selectable_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, enum nk_symbol_type, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (str != null) {} else {
                __assert_fail("str", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25622))), "nk_bool nk_do_selectable_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, enum nk_symbol_type, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (len != 0) {} else {
                __assert_fail("len", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25623))), "nk_bool nk_do_selectable_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, enum nk_symbol_type, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (value != null) {} else {
                __assert_fail("value", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25624))), "nk_bool nk_do_selectable_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, enum nk_symbol_type, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25625))), "nk_bool nk_do_selectable_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, enum nk_symbol_type, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (font != null) {} else {
                __assert_fail("font", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 25626))), "nk_bool nk_do_selectable_symbol(nk_flags *, struct nk_command_buffer *, struct nk_rect, const char *, int, nk_flags, nk_bool *, enum nk_symbol_type, const struct nk_style_selectable *, const struct nk_input *, const struct nk_user_font *)");
            };
        };
    };
    if ((((((!(state != null) or !(out != null)) or !(str != null)) or !(len != 0)) or !(value != null)) or !(style != null)) or !(font != null)) return 0;
    old_value = value.*;
    touch.x = bounds.x - style.*.touch_padding.x;
    touch.y = bounds.y - style.*.touch_padding.y;
    touch.w = bounds.w + (style.*.touch_padding.x * @as(f32, @floatFromInt(@as(c_int, 2))));
    touch.h = bounds.h + (style.*.touch_padding.y * @as(f32, @floatFromInt(@as(c_int, 2))));
    if (nk_button_behavior(state, touch, in, @as(c_uint, @bitCast(NK_BUTTON_DEFAULT))) != 0) {
        value.* = @intFromBool(!(value.* != 0));
    }
    icon.y = bounds.y + style.*.padding.y;
    icon.w = blk: {
        const tmp = bounds.h - (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y);
        icon.h = tmp;
        break :blk tmp;
    };
    if ((@"align" & @as(nk_flags, @bitCast(NK_TEXT_ALIGN_LEFT))) != 0) {
        icon.x = (bounds.x + bounds.w) - ((@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x) + icon.w);
        icon.x = if (icon.x < @as(f32, @floatFromInt(@as(c_int, 0)))) @as(f32, @floatFromInt(@as(c_int, 0))) else icon.x;
    } else {
        icon.x = bounds.x + (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x);
    }
    icon.x += style.*.image_padding.x;
    icon.y += style.*.image_padding.y;
    icon.w -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.image_padding.x;
    icon.h -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.image_padding.y;
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_selectable(out, state.*, style, value.*, &bounds, &icon, null, sym, str, len, @"align", font);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return @intFromBool(old_value != value.*);
}
pub fn nk_knob_behavior(arg_state: [*c]nk_flags, arg_in: [*c]struct_nk_input, arg_bounds: struct_nk_rect, arg_knob_min: f32, arg_knob_max: f32, arg_knob_value: f32, arg_knob_step: f32, arg_knob_steps: f32, arg_zero_direction: enum_nk_heading, arg_dead_zone_percent: f32) callconv(.c) f32 {
    var state = arg_state;
    _ = &state;
    var in = arg_in;
    _ = &in;
    var bounds = arg_bounds;
    _ = &bounds;
    var knob_min = arg_knob_min;
    _ = &knob_min;
    var knob_max = arg_knob_max;
    _ = &knob_max;
    var knob_value = arg_knob_value;
    _ = &knob_value;
    var knob_step = arg_knob_step;
    _ = &knob_step;
    var knob_steps = arg_knob_steps;
    _ = &knob_steps;
    var zero_direction = arg_zero_direction;
    _ = &zero_direction;
    var dead_zone_percent = arg_dead_zone_percent;
    _ = &dead_zone_percent;
    var origin: struct_nk_vec2 = undefined;
    _ = &origin;
    var angle: f32 = 0.0;
    _ = &angle;
    origin.x = bounds.x + (bounds.w / @as(f32, @floatFromInt(@as(c_int, 2))));
    origin.y = bounds.y + (bounds.h / @as(f32, @floatFromInt(@as(c_int, 2))));
    if ((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_MODIFIED))) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE | NK_WIDGET_STATE_MODIFIED));
    } else {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_INACTIVE));
    }
    if (((in != null) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0)) and (nk_input_has_mouse_click_down_in_rect(in, @as(c_uint, @bitCast(NK_BUTTON_LEFT)), bounds, nk_true) != 0)) {
        const direction_rads: [4]f32 = [4]f32{
            3.1415927410125732 * 2.5,
            3.1415927410125732 * 2.0,
            3.1415927410125732 * 1.5,
            3.1415927410125732,
        };
        _ = &direction_rads;
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVE));
        angle = nk_atan2(in.*.mouse.pos.y - origin.y, in.*.mouse.pos.x - origin.x) + direction_rads[zero_direction];
        angle -= if (angle > (3.1415927410125732 * @as(f32, @floatFromInt(@as(c_int, 2))))) 3.1415927410125732 * @as(f32, @floatFromInt(@as(c_int, 3))) else 3.1415927410125732;
        angle *= 1.0 / (1.0 - dead_zone_percent);
        angle = if ((if (angle < 3.1415927410125732) angle else 3.1415927410125732) < -3.1415927410125732) -3.1415927410125732 else if (angle < 3.1415927410125732) angle else 3.1415927410125732;
        angle = (angle + 3.1415927410125732) / (3.1415927410125732 * @as(f32, @floatFromInt(@as(c_int, 2))));
        knob_value = knob_min + (@as(f32, @floatFromInt(@as(c_int, @intFromFloat((angle * knob_steps) + (knob_step / @as(f32, @floatFromInt(@as(c_int, 2)))))))) * knob_step);
        knob_value = if ((if (knob_value < knob_max) knob_value else knob_max) < knob_min) knob_min else if (knob_value < knob_max) knob_value else knob_max;
    }
    if (nk_input_is_mouse_hovering_rect(in, bounds) != 0) {
        state.* = @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVERED));
        if ((in.*.mouse.scroll_delta.y > @as(f32, @floatFromInt(@as(c_int, 0)))) or ((in.*.keyboard.keys[@as(c_uint, @intCast(NK_KEY_UP))].down != 0) and (in.*.keyboard.keys[@as(c_uint, @intCast(NK_KEY_UP))].clicked != 0))) {
            knob_value += knob_step;
        }
        if ((in.*.mouse.scroll_delta.y < @as(f32, @floatFromInt(@as(c_int, 0)))) or ((in.*.keyboard.keys[@as(c_uint, @intCast(NK_KEY_DOWN))].down != 0) and (in.*.keyboard.keys[@as(c_uint, @intCast(NK_KEY_DOWN))].clicked != 0))) {
            knob_value -= knob_step;
        }
        in.*.mouse.scroll_delta.y = 0;
        knob_value = if ((if (knob_value < knob_max) knob_value else knob_max) < knob_min) knob_min else if (knob_value < knob_max) knob_value else knob_max;
    }
    if (((state.* & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) and !(nk_input_is_mouse_prev_hovering_rect(in, bounds) != 0)) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_ENTERED));
    } else if (nk_input_is_mouse_prev_hovering_rect(in, bounds) != 0) {
        state.* |= @as(nk_flags, @bitCast(NK_WIDGET_STATE_LEFT));
    }
    return knob_value;
}
pub fn nk_draw_knob(arg_out: [*c]struct_nk_command_buffer, arg_state: nk_flags, arg_style: [*c]const struct_nk_style_knob, arg_bounds: [*c]const struct_nk_rect, arg_min: f32, arg_value: f32, arg_max: f32, arg_zero_direction: enum_nk_heading, arg_dead_zone_percent: f32) callconv(.c) void {
    var out = arg_out;
    _ = &out;
    var state = arg_state;
    _ = &state;
    var style = arg_style;
    _ = &style;
    var bounds = arg_bounds;
    _ = &bounds;
    var min = arg_min;
    _ = &min;
    var value = arg_value;
    _ = &value;
    var max = arg_max;
    _ = &max;
    var zero_direction = arg_zero_direction;
    _ = &zero_direction;
    var dead_zone_percent = arg_dead_zone_percent;
    _ = &dead_zone_percent;
    var background: [*c]const struct_nk_style_item = undefined;
    _ = &background;
    var knob_color: struct_nk_color = undefined;
    _ = &knob_color;
    var cursor: struct_nk_color = undefined;
    _ = &cursor;
    _ = &min;
    _ = &max;
    _ = &value;
    if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_ACTIVED))) != 0) {
        background = &style.*.active;
        knob_color = style.*.knob_active;
        cursor = style.*.cursor_active;
    } else if ((state & @as(nk_flags, @bitCast(NK_WIDGET_STATE_HOVER))) != 0) {
        background = &style.*.hover;
        knob_color = style.*.knob_hover;
        cursor = style.*.cursor_hover;
    } else {
        background = &style.*.normal;
        knob_color = style.*.knob_normal;
        cursor = style.*.cursor_normal;
    }
    while (true) {
        switch (background.*.type) {
            @as(c_uint, @bitCast(@as(c_int, 1))) => {
                nk_draw_image(out, bounds.*, &background.*.data.image, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 2))) => {
                nk_draw_nine_slice(out, bounds.*, &background.*.data.slice, nk_rgb_factor(nk_white, style.*.color_factor));
                break;
            },
            @as(c_uint, @bitCast(@as(c_int, 0))) => {
                nk_fill_rect(out, bounds.*, @as(f32, @floatFromInt(@as(c_int, 0))), nk_rgb_factor(background.*.data.color, style.*.color_factor));
                nk_stroke_rect(out, bounds.*, @as(f32, @floatFromInt(@as(c_int, 0))), style.*.border, nk_rgb_factor(style.*.border_color, style.*.color_factor));
                break;
            },
            else => {},
        }
        break;
    }
    nk_fill_circle(out, bounds.*, nk_rgb_factor(knob_color, style.*.color_factor));
    if (style.*.knob_border > @as(f32, @floatFromInt(@as(c_int, 0)))) {
        var border_bounds: struct_nk_rect = bounds.*;
        _ = &border_bounds;
        border_bounds.x += style.*.knob_border / @as(f32, @floatFromInt(@as(c_int, 2)));
        border_bounds.y += style.*.knob_border / @as(f32, @floatFromInt(@as(c_int, 2)));
        border_bounds.w -= style.*.knob_border;
        border_bounds.h -= style.*.knob_border;
        nk_stroke_circle(out, border_bounds, style.*.knob_border, nk_rgb_factor(style.*.knob_border_color, style.*.color_factor));
    }
    {
        var half_circle_size: f32 = bounds.*.w / @as(f32, @floatFromInt(@as(c_int, 2)));
        _ = &half_circle_size;
        var angle: f32 = (value - min) / (max - min);
        _ = &angle;
        var alive_zone: f32 = 1.0 - dead_zone_percent;
        _ = &alive_zone;
        var cursor_start: struct_nk_vec2 = undefined;
        _ = &cursor_start;
        var cursor_end: struct_nk_vec2 = undefined;
        _ = &cursor_end;
        const direction_rads: [4]f32 = [4]f32{
            3.1415927410125732 * 1.5,
            0.0,
            3.1415927410125732 * 0.5,
            3.1415927410125732,
        };
        _ = &direction_rads;
        angle = (angle * alive_zone) + (dead_zone_percent / @as(f32, @floatFromInt(@as(c_int, 2))));
        angle *= 3.1415927410125732 * @as(f32, @floatFromInt(@as(c_int, 2)));
        angle += direction_rads[zero_direction];
        if (angle > (3.1415927410125732 * @as(f32, @floatFromInt(@as(c_int, 2))))) {
            angle -= 3.1415927410125732 * @as(f32, @floatFromInt(@as(c_int, 2)));
        }
        cursor_start.x = (bounds.*.x + half_circle_size) + @as(f32, @floatFromInt(@intFromBool(angle > 3.1415927410125732)));
        cursor_start.y = (bounds.*.y + half_circle_size) + @as(f32, @floatFromInt(@intFromBool((angle < 1.5707963705062866) or (angle > (3.1415927410125732 * 1.5)))));
        cursor_end.x = cursor_start.x + (half_circle_size * nk_cos(angle));
        cursor_end.y = cursor_start.y + (half_circle_size * nk_sin(angle));
        cursor_start.x = (cursor_start.x + cursor_end.x) / @as(f32, @floatFromInt(@as(c_int, 2)));
        cursor_start.y = (cursor_start.y + cursor_end.y) / @as(f32, @floatFromInt(@as(c_int, 2)));
        nk_stroke_line(out, cursor_start.x, cursor_start.y, cursor_end.x, cursor_end.y, @as(f32, @floatFromInt(@as(c_int, 2))), nk_rgb_factor(cursor, style.*.color_factor));
    }
}
pub fn nk_do_knob(arg_state: [*c]nk_flags, arg_out: [*c]struct_nk_command_buffer, arg_bounds: struct_nk_rect, arg_min: f32, arg_val: f32, arg_max: f32, arg_step: f32, arg_zero_direction: enum_nk_heading, arg_dead_zone_percent: f32, arg_style: [*c]const struct_nk_style_knob, arg_in: [*c]struct_nk_input) callconv(.c) f32 {
    var state = arg_state;
    _ = &state;
    var out = arg_out;
    _ = &out;
    var bounds = arg_bounds;
    _ = &bounds;
    var min = arg_min;
    _ = &min;
    var val = arg_val;
    _ = &val;
    var max = arg_max;
    _ = &max;
    var step = arg_step;
    _ = &step;
    var zero_direction = arg_zero_direction;
    _ = &zero_direction;
    var dead_zone_percent = arg_dead_zone_percent;
    _ = &dead_zone_percent;
    var style = arg_style;
    _ = &style;
    var in = arg_in;
    _ = &in;
    var knob_range: f32 = undefined;
    _ = &knob_range;
    var knob_min: f32 = undefined;
    _ = &knob_min;
    var knob_max: f32 = undefined;
    _ = &knob_max;
    var knob_value: f32 = undefined;
    _ = &knob_value;
    var knob_steps: f32 = undefined;
    _ = &knob_steps;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (style != null) {} else {
                __assert_fail("style", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26230))), "float nk_do_knob(nk_flags *, struct nk_command_buffer *, struct nk_rect, float, float, float, float, enum nk_heading, float, const struct nk_style_knob *, struct nk_input *)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (out != null) {} else {
                __assert_fail("out", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 26231))), "float nk_do_knob(nk_flags *, struct nk_command_buffer *, struct nk_rect, float, float, float, float, enum nk_heading, float, const struct nk_style_knob *, struct nk_input *)");
            };
        };
    };
    if (!(out != null) or !(style != null)) return 0;
    bounds.y = bounds.y + style.*.padding.y;
    bounds.x = bounds.x + style.*.padding.x;
    bounds.h = if (bounds.h < (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y)) @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y else bounds.h;
    bounds.w = if (bounds.w < (@as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x)) @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x else bounds.w;
    bounds.w -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.x;
    bounds.h -= @as(f32, @floatFromInt(@as(c_int, 2))) * style.*.padding.y;
    if (bounds.h < bounds.w) {
        bounds.x += (bounds.w - bounds.h) / @as(f32, @floatFromInt(@as(c_int, 2)));
        bounds.w = bounds.h;
    }
    knob_max = if (min < max) max else min;
    knob_min = if (min < max) min else max;
    knob_value = if ((if (val < knob_max) val else knob_max) < knob_min) knob_min else if (val < knob_max) val else knob_max;
    knob_range = knob_max - knob_min;
    knob_steps = knob_range / step;
    knob_value = nk_knob_behavior(state, in, bounds, knob_min, knob_max, knob_value, step, knob_steps, zero_direction, dead_zone_percent);
    if (style.*.draw_begin != null) {
        style.*.draw_begin.?(out, style.*.userdata);
    }
    nk_draw_knob(out, state.*, style, &bounds, knob_min, knob_value, knob_max, zero_direction, dead_zone_percent);
    if (style.*.draw_end != null) {
        style.*.draw_end.?(out, style.*.userdata);
    }
    return knob_value;
}
pub const struct_nk_text_find = extern struct {
    x: f32 = @import("std").mem.zeroes(f32),
    y: f32 = @import("std").mem.zeroes(f32),
    height: f32 = @import("std").mem.zeroes(f32),
    first_char: c_int = @import("std").mem.zeroes(c_int),
    length: c_int = @import("std").mem.zeroes(c_int),
    prev_first: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_nk_text_edit_row = extern struct {
    x0: f32 = @import("std").mem.zeroes(f32),
    x1: f32 = @import("std").mem.zeroes(f32),
    baseline_y_delta: f32 = @import("std").mem.zeroes(f32),
    ymin: f32 = @import("std").mem.zeroes(f32),
    ymax: f32 = @import("std").mem.zeroes(f32),
    num_chars: c_int = @import("std").mem.zeroes(c_int),
};
pub fn nk_textedit_makeundo_delete(arg_state: [*c]struct_nk_text_edit, arg_where: c_int, arg_length: c_int) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var where = arg_where;
    _ = &where;
    var length = arg_length;
    _ = &length;
    var i: c_int = undefined;
    _ = &i;
    var p: [*c]nk_rune = nk_textedit_createundo(&state.*.undo, where, length, @as(c_int, 0));
    _ = &p;
    if (p != null) {
        {
            i = 0;
            while (i < length) : (i += 1) {
                (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* = nk_str_rune_at(&state.*.string, where + i);
            }
        }
    }
}
pub fn nk_textedit_makeundo_insert(arg_state: [*c]struct_nk_text_edit, arg_where: c_int, arg_length: c_int) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var where = arg_where;
    _ = &where;
    var length = arg_length;
    _ = &length;
    _ = nk_textedit_createundo(&state.*.undo, where, @as(c_int, 0), length);
}
pub fn nk_textedit_makeundo_replace(arg_state: [*c]struct_nk_text_edit, arg_where: c_int, arg_old_length: c_int, arg_new_length: c_int) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var where = arg_where;
    _ = &where;
    var old_length = arg_old_length;
    _ = &old_length;
    var new_length = arg_new_length;
    _ = &new_length;
    var i: c_int = undefined;
    _ = &i;
    var p: [*c]nk_rune = nk_textedit_createundo(&state.*.undo, where, old_length, new_length);
    _ = &p;
    if (p != null) {
        {
            i = 0;
            while (i < old_length) : (i += 1) {
                (blk: {
                    const tmp = i;
                    if (tmp >= 0) break :blk p + @as(usize, @intCast(tmp)) else break :blk p - ~@as(usize, @bitCast(@as(isize, @intCast(tmp)) +% -1));
                }).* = nk_str_rune_at(&state.*.string, where + i);
            }
        }
    }
}
pub fn nk_textedit_get_width(arg_edit: [*c]const struct_nk_text_edit, arg_line_start: c_int, arg_char_id: c_int, arg_font: [*c]const struct_nk_user_font) callconv(.c) f32 {
    var edit = arg_edit;
    _ = &edit;
    var line_start = arg_line_start;
    _ = &line_start;
    var char_id = arg_char_id;
    _ = &char_id;
    var font = arg_font;
    _ = &font;
    var len: c_int = 0;
    _ = &len;
    var unicode: nk_rune = 0;
    _ = &unicode;
    var str: [*c]const u8 = nk_str_at_const(&edit.*.string, line_start + char_id, &unicode, &len);
    _ = &str;
    return font.*.width.?(font.*.userdata, font.*.height, str, len);
}
pub fn nk_textedit_layout_row(arg_r: [*c]struct_nk_text_edit_row, arg_edit: [*c]struct_nk_text_edit, arg_line_start_id: c_int, arg_row_height: f32, arg_font: [*c]const struct_nk_user_font) callconv(.c) void {
    var r = arg_r;
    _ = &r;
    var edit = arg_edit;
    _ = &edit;
    var line_start_id = arg_line_start_id;
    _ = &line_start_id;
    var row_height = arg_row_height;
    _ = &row_height;
    var font = arg_font;
    _ = &font;
    var l: c_int = undefined;
    _ = &l;
    var glyphs: c_int = 0;
    _ = &glyphs;
    var unicode: nk_rune = undefined;
    _ = &unicode;
    var remaining: [*c]const u8 = undefined;
    _ = &remaining;
    var len: c_int = nk_str_len_char(&edit.*.string);
    _ = &len;
    var end: [*c]const u8 = nk_str_get_const(&edit.*.string) + @as(usize, @bitCast(@as(isize, @intCast(len))));
    _ = &end;
    var text: [*c]const u8 = nk_str_at_const(&edit.*.string, line_start_id, &unicode, &l);
    _ = &text;
    const size: struct_nk_vec2 = nk_text_calculate_text_bounds(font, text, @as(c_int, @bitCast(@as(c_int, @truncate(@divExact(@as(c_long, @bitCast(@intFromPtr(end) -% @intFromPtr(text))), @sizeOf(u8)))))), row_height, &remaining, null, &glyphs, NK_STOP_ON_NEW_LINE);
    _ = &size;
    r.*.x0 = 0.0;
    r.*.x1 = size.x;
    r.*.baseline_y_delta = size.y;
    r.*.ymin = 0.0;
    r.*.ymax = size.y;
    r.*.num_chars = glyphs;
}
pub fn nk_textedit_locate_coord(arg_edit: [*c]struct_nk_text_edit, arg_x: f32, arg_y: f32, arg_font: [*c]const struct_nk_user_font, arg_row_height: f32) callconv(.c) c_int {
    var edit = arg_edit;
    _ = &edit;
    var x = arg_x;
    _ = &x;
    var y = arg_y;
    _ = &y;
    var font = arg_font;
    _ = &font;
    var row_height = arg_row_height;
    _ = &row_height;
    var r: struct_nk_text_edit_row = undefined;
    _ = &r;
    var n: c_int = edit.*.string.len;
    _ = &n;
    var base_y: f32 = 0;
    _ = &base_y;
    var prev_x: f32 = undefined;
    _ = &prev_x;
    var i: c_int = 0;
    _ = &i;
    var k: c_int = undefined;
    _ = &k;
    r.x0 = blk: {
        const tmp = @as(f32, @floatFromInt(@as(c_int, 0)));
        r.x1 = tmp;
        break :blk tmp;
    };
    r.ymin = blk: {
        const tmp = @as(f32, @floatFromInt(@as(c_int, 0)));
        r.ymax = tmp;
        break :blk tmp;
    };
    r.num_chars = 0;
    while (i < n) {
        nk_textedit_layout_row(&r, edit, i, row_height, font);
        if (r.num_chars <= @as(c_int, 0)) return n;
        if ((i == @as(c_int, 0)) and (y < (base_y + r.ymin))) return 0;
        if (y < (base_y + r.ymax)) break;
        i += r.num_chars;
        base_y += r.baseline_y_delta;
    }
    if (i >= n) return n;
    if (x < r.x0) return i;
    if (x < r.x1) {
        k = i;
        prev_x = r.x0;
        {
            i = 0;
            while (i < r.num_chars) : (i += 1) {
                var w: f32 = nk_textedit_get_width(edit, k, i, font);
                _ = &w;
                if (x < (prev_x + w)) {
                    if (x < (prev_x + (w / @as(f32, @floatFromInt(@as(c_int, 2)))))) return k + i else return (k + i) + @as(c_int, 1);
                }
                prev_x += w;
            }
        }
    }
    if (nk_str_rune_at(&edit.*.string, (i + r.num_chars) - @as(c_int, 1)) == @as(nk_rune, @bitCast(@as(c_int, '\n')))) return (i + r.num_chars) - @as(c_int, 1) else return i + r.num_chars;
    return 0;
}
pub fn nk_textedit_find_charpos(arg_find: [*c]struct_nk_text_find, arg_state: [*c]struct_nk_text_edit, arg_n: c_int, arg_single_line: c_int, arg_font: [*c]const struct_nk_user_font, arg_row_height: f32) callconv(.c) void {
    var find = arg_find;
    _ = &find;
    var state = arg_state;
    _ = &state;
    var n = arg_n;
    _ = &n;
    var single_line = arg_single_line;
    _ = &single_line;
    var font = arg_font;
    _ = &font;
    var row_height = arg_row_height;
    _ = &row_height;
    var r: struct_nk_text_edit_row = undefined;
    _ = &r;
    var prev_start: c_int = 0;
    _ = &prev_start;
    var z: c_int = state.*.string.len;
    _ = &z;
    var i: c_int = 0;
    _ = &i;
    var first: c_int = undefined;
    _ = &first;
    nk_zero(@as(?*anyopaque, @ptrCast(&r)), @sizeOf(struct_nk_text_edit_row));
    if (n == z) {
        nk_textedit_layout_row(&r, state, @as(c_int, 0), row_height, font);
        if (single_line != 0) {
            find.*.first_char = 0;
            find.*.length = z;
        } else {
            while (i < z) {
                prev_start = i;
                i += r.num_chars;
                nk_textedit_layout_row(&r, state, i, row_height, font);
            }
            find.*.first_char = i;
            find.*.length = r.num_chars;
        }
        find.*.x = r.x1;
        find.*.y = r.ymin;
        find.*.height = r.ymax - r.ymin;
        find.*.prev_first = prev_start;
        return;
    }
    find.*.y = 0;
    while (true) {
        nk_textedit_layout_row(&r, state, i, row_height, font);
        if (n < (i + r.num_chars)) break;
        prev_start = i;
        i += r.num_chars;
        find.*.y += r.baseline_y_delta;
    }
    find.*.first_char = blk: {
        const tmp = i;
        first = tmp;
        break :blk tmp;
    };
    find.*.length = r.num_chars;
    find.*.height = r.ymax - r.ymin;
    find.*.prev_first = prev_start;
    find.*.x = r.x0;
    {
        i = 0;
        while ((first + i) < n) : (i += 1) {
            find.*.x += nk_textedit_get_width(state, first, i, font);
        }
    }
}
pub fn nk_textedit_clamp(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var n: c_int = state.*.string.len;
    _ = &n;
    if (state.*.select_start != state.*.select_end) {
        if (state.*.select_start > n) {
            state.*.select_start = n;
        }
        if (state.*.select_end > n) {
            state.*.select_end = n;
        }
        if (state.*.select_start == state.*.select_end) {
            state.*.cursor = state.*.select_start;
        }
    }
    if (state.*.cursor > n) {
        state.*.cursor = n;
    }
}
pub fn nk_textedit_sortselection(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    if (state.*.select_end < state.*.select_start) {
        var temp: c_int = state.*.select_end;
        _ = &temp;
        state.*.select_end = state.*.select_start;
        state.*.select_start = temp;
    }
}
pub fn nk_textedit_move_to_first(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    if (state.*.select_start != state.*.select_end) {
        nk_textedit_sortselection(state);
        state.*.cursor = state.*.select_start;
        state.*.select_end = state.*.select_start;
        state.*.has_preferred_x = 0;
    }
}
pub fn nk_textedit_move_to_last(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    if (state.*.select_start != state.*.select_end) {
        nk_textedit_sortselection(state);
        nk_textedit_clamp(state);
        state.*.cursor = state.*.select_end;
        state.*.select_start = state.*.select_end;
        state.*.has_preferred_x = 0;
    }
}
pub fn nk_is_word_boundary(arg_state: [*c]struct_nk_text_edit, arg_idx: c_int) callconv(.c) c_int {
    var state = arg_state;
    _ = &state;
    var idx = arg_idx;
    _ = &idx;
    var len: c_int = undefined;
    _ = &len;
    var c: nk_rune = undefined;
    _ = &c;
    if (idx < @as(c_int, 0)) return 1;
    if (!(nk_str_at_rune(&state.*.string, idx, &c, &len) != null)) return 1;
    return @intFromBool(((((((c == @as(nk_rune, @bitCast(@as(c_int, ' ')))) or (c == @as(nk_rune, @bitCast(@as(c_int, '\t'))))) or (c == @as(nk_rune, @bitCast(@as(c_int, '\n'))))) or (c == @as(nk_rune, @bitCast(@as(c_int, '\r'))))) or (c == @as(nk_rune, @bitCast(@as(c_int, '\x0c'))))) or (c == @as(nk_rune, @bitCast(@as(c_int, '\x0b'))))) or (c == @as(nk_rune, @bitCast(@as(c_int, 12288)))));
}
pub fn nk_textedit_move_to_word_previous(arg_state: [*c]struct_nk_text_edit) callconv(.c) c_int {
    var state = arg_state;
    _ = &state;
    var c: c_int = state.*.cursor - @as(c_int, 1);
    _ = &c;
    if (c > @as(c_int, 0)) {
        if (nk_is_word_boundary(state, c) != 0) {
            while ((c > @as(c_int, 0)) and (nk_is_word_boundary(state, blk: {
                const ref = &c;
                ref.* -= 1;
                break :blk ref.*;
            }) != 0)) {}
        }
        while (!(nk_is_word_boundary(state, blk: {
            const ref = &c;
            ref.* -= 1;
            break :blk ref.*;
        }) != 0)) {}
        c += 1;
    } else {
        return 0;
    }
    return c;
}
pub fn nk_textedit_move_to_word_next(arg_state: [*c]struct_nk_text_edit) callconv(.c) c_int {
    var state = arg_state;
    _ = &state;
    const len: c_int = state.*.string.len;
    _ = &len;
    var c: c_int = state.*.cursor;
    _ = &c;
    if (c < len) {
        if (!(nk_is_word_boundary(state, c) != 0)) {
            while ((c < len) and !(nk_is_word_boundary(state, blk: {
                const ref = &c;
                ref.* += 1;
                break :blk ref.*;
            }) != 0)) {}
        }
        while ((c < len) and (nk_is_word_boundary(state, blk: {
            const ref = &c;
            ref.* += 1;
            break :blk ref.*;
        }) != 0)) {}
    } else {
        return len;
    }
    return c;
}
pub fn nk_textedit_prep_selection_at_cursor(arg_state: [*c]struct_nk_text_edit) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    if (!(state.*.select_start != state.*.select_end)) {
        state.*.select_start = blk: {
            const tmp = state.*.cursor;
            state.*.select_end = tmp;
            break :blk tmp;
        };
    } else {
        state.*.cursor = state.*.select_end;
    }
}
pub fn nk_textedit_flush_redo(arg_state: [*c]struct_nk_text_undo_state) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    state.*.redo_point = 99;
    state.*.redo_char_point = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, 999)))));
}
pub fn nk_textedit_discard_undo(arg_state: [*c]struct_nk_text_undo_state) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    if (@as(c_int, @bitCast(@as(c_int, state.*.undo_point))) > @as(c_int, 0)) {
        if (@as(c_int, @bitCast(@as(c_int, state.*.undo_rec[@as(c_uint, @intCast(@as(c_int, 0)))].char_storage))) >= @as(c_int, 0)) {
            var n: c_int = @as(c_int, @bitCast(@as(c_int, state.*.undo_rec[@as(c_uint, @intCast(@as(c_int, 0)))].insert_length)));
            _ = &n;
            var i: c_int = undefined;
            _ = &i;
            state.*.undo_char_point = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_int, state.*.undo_char_point))) - n))));
            _ = nk_memcopy(@as(?*anyopaque, @ptrCast(@as([*c]nk_rune, @ptrCast(@alignCast(&state.*.undo_char))))), @as(?*const anyopaque, @ptrCast(@as([*c]nk_rune, @ptrCast(@alignCast(&state.*.undo_char))) + @as(usize, @bitCast(@as(isize, @intCast(n)))))), @as(nk_size, @bitCast(@as(c_long, state.*.undo_char_point))) *% @sizeOf(nk_rune));
            {
                i = 0;
                while (i < @as(c_int, @bitCast(@as(c_int, state.*.undo_point)))) : (i += 1) {
                    if (@as(c_int, @bitCast(@as(c_int, state.*.undo_rec[@as(c_uint, @intCast(i))].char_storage))) >= @as(c_int, 0)) {
                        state.*.undo_rec[@as(c_uint, @intCast(i))].char_storage = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_int, state.*.undo_rec[@as(c_uint, @intCast(i))].char_storage))) - n))));
                    }
                }
            }
        }
        state.*.undo_point -= 1;
        _ = nk_memcopy(@as(?*anyopaque, @ptrCast(@as([*c]struct_nk_text_undo_record, @ptrCast(@alignCast(&state.*.undo_rec))))), @as(?*const anyopaque, @ptrCast(@as([*c]struct_nk_text_undo_record, @ptrCast(@alignCast(&state.*.undo_rec))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))))), @as(nk_size, @bitCast(@as(nk_size, @bitCast(@as(c_long, state.*.undo_point))) *% @sizeOf(struct_nk_text_undo_record))));
    }
}
pub fn nk_textedit_discard_redo(arg_state: [*c]struct_nk_text_undo_state) callconv(.c) void {
    var state = arg_state;
    _ = &state;
    var num: nk_size = undefined;
    _ = &num;
    var k: c_int = @as(c_int, 99) - @as(c_int, 1);
    _ = &k;
    if (@as(c_int, @bitCast(@as(c_int, state.*.redo_point))) <= k) {
        if (@as(c_int, @bitCast(@as(c_int, state.*.undo_rec[@as(c_uint, @intCast(k))].char_storage))) >= @as(c_int, 0)) {
            var n: c_int = @as(c_int, @bitCast(@as(c_int, state.*.undo_rec[@as(c_uint, @intCast(k))].insert_length)));
            _ = &n;
            var i: c_int = undefined;
            _ = &i;
            state.*.redo_char_point = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_int, state.*.redo_char_point))) + n))));
            num = @as(nk_size, @bitCast(@as(c_long, @as(c_int, 999) - @as(c_int, @bitCast(@as(c_int, state.*.redo_char_point))))));
            _ = nk_memcopy(@as(?*anyopaque, @ptrCast(@as([*c]nk_rune, @ptrCast(@alignCast(&state.*.undo_char))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, @bitCast(@as(c_int, state.*.redo_char_point))))))))), @as(?*const anyopaque, @ptrCast((@as([*c]nk_rune, @ptrCast(@alignCast(&state.*.undo_char))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, @bitCast(@as(c_int, state.*.redo_char_point)))))))) - @as(usize, @bitCast(@as(isize, @intCast(n)))))), num *% @sizeOf(u8));
            {
                i = @as(c_int, @bitCast(@as(c_int, state.*.redo_point)));
                while (i < k) : (i += 1) {
                    if (@as(c_int, @bitCast(@as(c_int, state.*.undo_rec[@as(c_uint, @intCast(i))].char_storage))) >= @as(c_int, 0)) {
                        state.*.undo_rec[@as(c_uint, @intCast(i))].char_storage = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_int, state.*.undo_rec[@as(c_uint, @intCast(i))].char_storage))) + n))));
                    }
                }
            }
        }
        state.*.redo_point += 1;
        num = @as(nk_size, @bitCast(@as(c_long, @as(c_int, 99) - @as(c_int, @bitCast(@as(c_int, state.*.redo_point))))));
        if (num != 0) {
            _ = nk_memcopy(@as(?*anyopaque, @ptrCast((@as([*c]struct_nk_text_undo_record, @ptrCast(@alignCast(&state.*.undo_rec))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, @bitCast(@as(c_int, state.*.redo_point)))))))) - @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, 1))))))), @as(?*const anyopaque, @ptrCast(@as([*c]struct_nk_text_undo_record, @ptrCast(@alignCast(&state.*.undo_rec))) + @as(usize, @bitCast(@as(isize, @intCast(@as(c_int, @bitCast(@as(c_int, state.*.redo_point))))))))), num *% @sizeOf(struct_nk_text_undo_record));
        }
    }
}
pub fn nk_textedit_create_undo_record(arg_state: [*c]struct_nk_text_undo_state, arg_numchars: c_int) callconv(.c) [*c]struct_nk_text_undo_record {
    var state = arg_state;
    _ = &state;
    var numchars = arg_numchars;
    _ = &numchars;
    nk_textedit_flush_redo(state);
    if (@as(c_int, @bitCast(@as(c_int, state.*.undo_point))) == @as(c_int, 99)) {
        nk_textedit_discard_undo(state);
    }
    if (numchars > @as(c_int, 999)) {
        state.*.undo_point = 0;
        state.*.undo_char_point = 0;
        return null;
    }
    while ((@as(c_int, @bitCast(@as(c_int, state.*.undo_char_point))) + numchars) > @as(c_int, 999)) {
        nk_textedit_discard_undo(state);
    }
    return &state.*.undo_rec[@as(c_ushort, @intCast(blk: {
        const ref = &state.*.undo_point;
        const tmp = ref.*;
        ref.* += 1;
        break :blk tmp;
    }))];
}
pub fn nk_textedit_createundo(arg_state: [*c]struct_nk_text_undo_state, arg_pos: c_int, arg_insert_len: c_int, arg_delete_len: c_int) callconv(.c) [*c]nk_rune {
    var state = arg_state;
    _ = &state;
    var pos = arg_pos;
    _ = &pos;
    var insert_len = arg_insert_len;
    _ = &insert_len;
    var delete_len = arg_delete_len;
    _ = &delete_len;
    var r: [*c]struct_nk_text_undo_record = nk_textedit_create_undo_record(state, insert_len);
    _ = &r;
    if (r == null) return null;
    r.*.where = pos;
    r.*.insert_length = @as(c_short, @bitCast(@as(c_short, @truncate(insert_len))));
    r.*.delete_length = @as(c_short, @bitCast(@as(c_short, @truncate(delete_len))));
    if (insert_len == @as(c_int, 0)) {
        r.*.char_storage = @as(c_short, @bitCast(@as(c_short, @truncate(-@as(c_int, 1)))));
        return null;
    } else {
        r.*.char_storage = state.*.undo_char_point;
        state.*.undo_char_point = @as(c_short, @bitCast(@as(c_short, @truncate(@as(c_int, @bitCast(@as(c_int, state.*.undo_char_point))) + insert_len))));
        return &state.*.undo_char[@as(c_ushort, @intCast(r.*.char_storage))];
    }
    return null;
}
pub fn nk_chart_push_line(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window, arg_g: [*c]struct_nk_chart, arg_value: f32, arg_slot: c_int) callconv(.c) nk_flags {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var g = arg_g;
    _ = &g;
    var value = arg_value;
    _ = &value;
    var slot = arg_slot;
    _ = &slot;
    var layout: [*c]struct_nk_panel = win.*.layout;
    _ = &layout;
    var i: [*c]const struct_nk_input = if (ctx.*.current.*.widgets_disabled != 0) null else &ctx.*.input;
    _ = &i;
    var out: [*c]struct_nk_command_buffer = &win.*.buffer;
    _ = &out;
    var ret: nk_flags = 0;
    _ = &ret;
    var cur: struct_nk_vec2 = undefined;
    _ = &cur;
    var bounds: struct_nk_rect = undefined;
    _ = &bounds;
    var color: struct_nk_color = undefined;
    _ = &color;
    var step: f32 = undefined;
    _ = &step;
    var range: f32 = undefined;
    _ = &range;
    var ratio: f32 = undefined;
    _ = &ratio;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((slot >= @as(c_int, 0)) and (slot < @as(c_int, 4))) {} else {
                __assert_fail("slot >= 0 && slot < 4", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29299))), "nk_flags nk_chart_push_line(struct nk_context *, struct nk_window *, struct nk_chart *, float, int)");
            };
        };
    };
    step = g.*.w / @as(f32, @floatFromInt(g.*.slots[@as(c_uint, @intCast(slot))].count));
    range = g.*.slots[@as(c_uint, @intCast(slot))].max - g.*.slots[@as(c_uint, @intCast(slot))].min;
    ratio = (value - g.*.slots[@as(c_uint, @intCast(slot))].min) / range;
    if (g.*.slots[@as(c_uint, @intCast(slot))].index == @as(c_int, 0)) {
        g.*.slots[@as(c_uint, @intCast(slot))].last.x = g.*.x;
        g.*.slots[@as(c_uint, @intCast(slot))].last.y = (g.*.y + g.*.h) - (ratio * g.*.h);
        bounds.x = g.*.slots[@as(c_uint, @intCast(slot))].last.x - @as(f32, @floatFromInt(@as(c_int, 2)));
        bounds.y = g.*.slots[@as(c_uint, @intCast(slot))].last.y - @as(f32, @floatFromInt(@as(c_int, 2)));
        bounds.w = blk: {
            const tmp = @as(f32, @floatFromInt(@as(c_int, 4)));
            bounds.h = tmp;
            break :blk tmp;
        };
        color = g.*.slots[@as(c_uint, @intCast(slot))].color;
        if ((!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) and (i != null)) and ((((g.*.slots[@as(c_uint, @intCast(slot))].last.x - @as(f32, @floatFromInt(@as(c_int, 3)))) <= i.*.mouse.pos.x) and (i.*.mouse.pos.x < ((g.*.slots[@as(c_uint, @intCast(slot))].last.x - @as(f32, @floatFromInt(@as(c_int, 3)))) + @as(f32, @floatFromInt(@as(c_int, 6)))))) and (((g.*.slots[@as(c_uint, @intCast(slot))].last.y - @as(f32, @floatFromInt(@as(c_int, 3)))) <= i.*.mouse.pos.y) and (i.*.mouse.pos.y < ((g.*.slots[@as(c_uint, @intCast(slot))].last.y - @as(f32, @floatFromInt(@as(c_int, 3)))) + @as(f32, @floatFromInt(@as(c_int, 6)))))))) {
            ret = @as(nk_flags, @bitCast(if (nk_input_is_mouse_hovering_rect(i, bounds) != 0) NK_CHART_HOVERING else @as(c_int, 0)));
            ret |= @as(nk_flags, @bitCast(if ((i.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0) and (i.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked != 0)) NK_CHART_CLICKED else @as(c_int, 0)));
            color = g.*.slots[@as(c_uint, @intCast(slot))].highlight;
        }
        if (g.*.slots[@as(c_uint, @intCast(slot))].show_markers != 0) {
            nk_fill_rect(out, bounds, @as(f32, @floatFromInt(@as(c_int, 0))), color);
        }
        g.*.slots[@as(c_uint, @intCast(slot))].index += @as(c_int, 1);
        return ret;
    }
    color = g.*.slots[@as(c_uint, @intCast(slot))].color;
    cur.x = g.*.x + (step * @as(f32, @floatFromInt(g.*.slots[@as(c_uint, @intCast(slot))].index)));
    cur.y = (g.*.y + g.*.h) - (ratio * g.*.h);
    nk_stroke_line(out, g.*.slots[@as(c_uint, @intCast(slot))].last.x, g.*.slots[@as(c_uint, @intCast(slot))].last.y, cur.x, cur.y, 1.0, color);
    bounds.x = cur.x - @as(f32, @floatFromInt(@as(c_int, 3)));
    bounds.y = cur.y - @as(f32, @floatFromInt(@as(c_int, 3)));
    bounds.w = blk: {
        const tmp = @as(f32, @floatFromInt(@as(c_int, 6)));
        bounds.h = tmp;
        break :blk tmp;
    };
    if (!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0)) {
        if (nk_input_is_mouse_hovering_rect(i, bounds) != 0) {
            ret = @as(nk_flags, @bitCast(NK_CHART_HOVERING));
            ret |= @as(nk_flags, @bitCast(if (!(i.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0) and (i.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked != 0)) NK_CHART_CLICKED else @as(c_int, 0)));
            color = g.*.slots[@as(c_uint, @intCast(slot))].highlight;
        }
    }
    if (g.*.slots[@as(c_uint, @intCast(slot))].show_markers != 0) {
        nk_fill_rect(out, nk_rect(cur.x - @as(f32, @floatFromInt(@as(c_int, 2))), cur.y - @as(f32, @floatFromInt(@as(c_int, 2))), @as(f32, @floatFromInt(@as(c_int, 4))), @as(f32, @floatFromInt(@as(c_int, 4)))), @as(f32, @floatFromInt(@as(c_int, 0))), color);
    }
    g.*.slots[@as(c_uint, @intCast(slot))].last.x = cur.x;
    g.*.slots[@as(c_uint, @intCast(slot))].last.y = cur.y;
    g.*.slots[@as(c_uint, @intCast(slot))].index += @as(c_int, 1);
    return ret;
}
pub fn nk_chart_push_column(arg_ctx: [*c]const struct_nk_context, arg_win: [*c]struct_nk_window, arg_chart: [*c]struct_nk_chart, arg_value: f32, arg_slot: c_int) callconv(.c) nk_flags {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var chart = arg_chart;
    _ = &chart;
    var value = arg_value;
    _ = &value;
    var slot = arg_slot;
    _ = &slot;
    var out: [*c]struct_nk_command_buffer = &win.*.buffer;
    _ = &out;
    var in: [*c]const struct_nk_input = if (ctx.*.current.*.widgets_disabled != 0) null else &ctx.*.input;
    _ = &in;
    var layout: [*c]struct_nk_panel = win.*.layout;
    _ = &layout;
    var ratio: f32 = undefined;
    _ = &ratio;
    var ret: nk_flags = 0;
    _ = &ret;
    var color: struct_nk_color = undefined;
    _ = &color;
    var item: struct_nk_rect = struct_nk_rect{
        .x = @as(f32, @floatFromInt(@as(c_int, 0))),
        .y = @as(f32, @floatFromInt(@as(c_int, 0))),
        .w = @as(f32, @floatFromInt(@as(c_int, 0))),
        .h = @as(f32, @floatFromInt(@as(c_int, 0))),
    };
    _ = &item;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if ((slot >= @as(c_int, 0)) and (slot < @as(c_int, 4))) {} else {
                __assert_fail("slot >= 0 && slot < 4", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29370))), "nk_flags nk_chart_push_column(const struct nk_context *, struct nk_window *, struct nk_chart *, float, int)");
            };
        };
    };
    if (chart.*.slots[@as(c_uint, @intCast(slot))].index >= chart.*.slots[@as(c_uint, @intCast(slot))].count) return @as(nk_flags, @bitCast(nk_false));
    if (chart.*.slots[@as(c_uint, @intCast(slot))].count != 0) {
        var padding: f32 = @as(f32, @floatFromInt(chart.*.slots[@as(c_uint, @intCast(slot))].count - @as(c_int, 1)));
        _ = &padding;
        item.w = (chart.*.w - padding) / @as(f32, @floatFromInt(chart.*.slots[@as(c_uint, @intCast(slot))].count));
    }
    color = chart.*.slots[@as(c_uint, @intCast(slot))].color;
    item.h = chart.*.h * (if ((value / chart.*.slots[@as(c_uint, @intCast(slot))].range) < @as(f32, @floatFromInt(@as(c_int, 0)))) -(value / chart.*.slots[@as(c_uint, @intCast(slot))].range) else value / chart.*.slots[@as(c_uint, @intCast(slot))].range);
    if (value >= @as(f32, @floatFromInt(@as(c_int, 0)))) {
        ratio = (value + (if (chart.*.slots[@as(c_uint, @intCast(slot))].min < @as(f32, @floatFromInt(@as(c_int, 0)))) -chart.*.slots[@as(c_uint, @intCast(slot))].min else chart.*.slots[@as(c_uint, @intCast(slot))].min)) / (if (chart.*.slots[@as(c_uint, @intCast(slot))].range < @as(f32, @floatFromInt(@as(c_int, 0)))) -chart.*.slots[@as(c_uint, @intCast(slot))].range else chart.*.slots[@as(c_uint, @intCast(slot))].range);
        item.y = (chart.*.y + chart.*.h) - (chart.*.h * ratio);
    } else {
        ratio = (value - chart.*.slots[@as(c_uint, @intCast(slot))].max) / chart.*.slots[@as(c_uint, @intCast(slot))].range;
        item.y = (chart.*.y + (chart.*.h * (if (ratio < @as(f32, @floatFromInt(@as(c_int, 0)))) -ratio else ratio))) - item.h;
    }
    item.x = chart.*.x + (@as(f32, @floatFromInt(chart.*.slots[@as(c_uint, @intCast(slot))].index)) * item.w);
    item.x = item.x + @as(f32, @floatFromInt(chart.*.slots[@as(c_uint, @intCast(slot))].index));
    if ((!((layout.*.flags & @as(nk_flags, @bitCast(NK_WINDOW_ROM))) != 0) and (in != null)) and (((item.x <= in.*.mouse.pos.x) and (in.*.mouse.pos.x < (item.x + item.w))) and ((item.y <= in.*.mouse.pos.y) and (in.*.mouse.pos.y < (item.y + item.h))))) {
        ret = @as(nk_flags, @bitCast(NK_CHART_HOVERING));
        ret |= @as(nk_flags, @bitCast(if (!(in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].down != 0) and (in.*.mouse.buttons[@as(c_uint, @intCast(NK_BUTTON_LEFT))].clicked != 0)) NK_CHART_CLICKED else @as(c_int, 0)));
        color = chart.*.slots[@as(c_uint, @intCast(slot))].highlight;
    }
    nk_fill_rect(out, item, @as(f32, @floatFromInt(@as(c_int, 0))), color);
    chart.*.slots[@as(c_uint, @intCast(slot))].index += @as(c_int, 1);
    return ret;
}
pub fn nk_combo_begin(arg_ctx: [*c]struct_nk_context, arg_win: [*c]struct_nk_window, arg_size: struct_nk_vec2, arg_is_clicked: nk_bool, arg_header: struct_nk_rect) callconv(.c) nk_bool {
    var ctx = arg_ctx;
    _ = &ctx;
    var win = arg_win;
    _ = &win;
    var size = arg_size;
    _ = &size;
    var is_clicked = arg_is_clicked;
    _ = &is_clicked;
    var header = arg_header;
    _ = &header;
    var popup: [*c]struct_nk_window = undefined;
    _ = &popup;
    var is_open: c_int = 0;
    _ = &is_open;
    var is_active: c_int = 0;
    _ = &is_active;
    var body: struct_nk_rect = undefined;
    _ = &body;
    var hash: nk_hash = undefined;
    _ = &hash;
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx != null) {} else {
                __assert_fail("ctx", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29722))), "nk_bool nk_combo_begin(struct nk_context *, struct nk_window *, struct nk_vec2, nk_bool, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current != null) {} else {
                __assert_fail("ctx->current", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29723))), "nk_bool nk_combo_begin(struct nk_context *, struct nk_window *, struct nk_vec2, nk_bool, struct nk_rect)");
            };
        };
    };
    _ = blk: {
        _ = @sizeOf(c_int);
        break :blk blk_1: {
            break :blk_1 if (ctx.*.current.*.layout != null) {} else {
                __assert_fail("ctx->current->layout", "libs/nuklear/nuklear.h", @as(c_uint, @bitCast(@as(c_int, 29724))), "nk_bool nk_combo_begin(struct nk_context *, struct nk_window *, struct nk_vec2, nk_bool, struct nk_rect)");
            };
        };
    };
    if ((!(ctx != null) or !(ctx.*.current != null)) or !(ctx.*.current.*.layout != null)) return 0;
    popup = win.*.popup.win;
    body.x = header.x;
    body.w = size.x;
    body.y = (header.y + header.h) - ctx.*.style.window.combo_border;
    body.h = size.y;
    hash = blk: {
        const ref = &win.*.popup.combo_count;
        const tmp = ref.*;
        ref.* +%= 1;
        break :blk tmp;
    };
    is_open = if (popup != null) nk_true else nk_false;
    is_active = @intFromBool(((popup != null) and (win.*.popup.name == hash)) and (win.*.popup.type == @as(c_uint, @bitCast(NK_PANEL_COMBO))));
    if (((((is_clicked != 0) and (is_open != 0)) and !(is_active != 0)) or ((is_open != 0) and !(is_active != 0))) or ((!(is_open != 0) and !(is_active != 0)) and !(is_clicked != 0))) return 0;
    if (!(nk_nonblock_begin(ctx, @as(nk_flags, @bitCast(@as(c_int, 0))), body, if ((is_clicked != 0) and (is_open != 0)) nk_rect(@as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0))), @as(f32, @floatFromInt(@as(c_int, 0)))) else header, @as(c_uint, @bitCast(NK_PANEL_COMBO))) != 0)) return 0;
    win.*.popup.type = @as(c_uint, @bitCast(NK_PANEL_COMBO));
    win.*.popup.name = hash;
    return 1;
}
pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 19);
pub const __clang_minor__ = @as(c_int, 1);
pub const __clang_patchlevel__ = @as(c_int, 7);
pub const __clang_version__ = "19.1.7 (https://github.com/ziglang/zig-bootstrap 1c3c59435891bc9caf8cd1d3783773369d191c5f)";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __MEMORY_SCOPE_SYSTEM = @as(c_int, 0);
pub const __MEMORY_SCOPE_DEVICE = @as(c_int, 1);
pub const __MEMORY_SCOPE_WRKGRP = @as(c_int, 2);
pub const __MEMORY_SCOPE_WVFRNT = @as(c_int, 3);
pub const __MEMORY_SCOPE_SINGLE = @as(c_int, 4);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __FPCLASS_SNAN = @as(c_int, 0x0001);
pub const __FPCLASS_QNAN = @as(c_int, 0x0002);
pub const __FPCLASS_NEGINF = @as(c_int, 0x0004);
pub const __FPCLASS_NEGNORMAL = @as(c_int, 0x0008);
pub const __FPCLASS_NEGSUBNORMAL = @as(c_int, 0x0010);
pub const __FPCLASS_NEGZERO = @as(c_int, 0x0020);
pub const __FPCLASS_POSZERO = @as(c_int, 0x0040);
pub const __FPCLASS_POSSUBNORMAL = @as(c_int, 0x0080);
pub const __FPCLASS_POSNORMAL = @as(c_int, 0x0100);
pub const __FPCLASS_POSINF = @as(c_int, 0x0200);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 19.1.7 (https://github.com/ziglang/zig-bootstrap 1c3c59435891bc9caf8cd1d3783773369d191c5f)";
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 0);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-32";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const _LP64 = @as(c_int, 1);
pub const __LP64__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 8);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 64);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 8388608, .decimal);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 32);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 32);
pub const __INTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 8);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 16);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 4);
pub const __SIZEOF_WINT_T__ = @as(c_int, 4);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_long;
pub const __INTMAX_FMTd__ = "ld";
pub const __INTMAX_FMTi__ = "li";
pub const __INTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `L`");
// (no file):95:9
pub const __UINTMAX_TYPE__ = c_ulong;
pub const __UINTMAX_FMTo__ = "lo";
pub const __UINTMAX_FMTu__ = "lu";
pub const __UINTMAX_FMTx__ = "lx";
pub const __UINTMAX_FMTX__ = "lX";
pub const __UINTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`");
// (no file):101:9
pub const __PTRDIFF_TYPE__ = c_long;
pub const __PTRDIFF_FMTd__ = "ld";
pub const __PTRDIFF_FMTi__ = "li";
pub const __INTPTR_TYPE__ = c_long;
pub const __INTPTR_FMTd__ = "ld";
pub const __INTPTR_FMTi__ = "li";
pub const __SIZE_TYPE__ = c_ulong;
pub const __SIZE_FMTo__ = "lo";
pub const __SIZE_FMTu__ = "lu";
pub const __SIZE_FMTx__ = "lx";
pub const __SIZE_FMTX__ = "lX";
pub const __WCHAR_TYPE__ = c_int;
pub const __WINT_TYPE__ = c_uint;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulong;
pub const __UINTPTR_FMTo__ = "lo";
pub const __UINTPTR_FMTu__ = "lu";
pub const __UINTPTR_FMTx__ = "lx";
pub const __UINTPTR_FMTX__ = "lX";
pub const __FLT16_DENORM_MIN__ = @as(f16, 5.9604644775390625e-8);
pub const __FLT16_NORM_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_EPSILON__ = @as(f16, 9.765625e-4);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT16_MIN__ = @as(f16, 6.103515625e-5);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_NORM_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = @as(f64, 4.9406564584124654e-324);
pub const __DBL_NORM_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = @as(f64, 2.2204460492503131e-16);
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = @as(f64, 2.2250738585072014e-308);
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 3.64519953188247460253e-4951);
pub const __LDBL_NORM_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 18);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 21);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 1.08420217248550443401e-19);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 64);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 4932);
pub const __LDBL_MAX_EXP__ = @as(c_int, 16384);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 4931);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 16381);
pub const __LDBL_MIN__ = @as(c_longdouble, 3.36210314311209350626e-4932);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 16);
pub const __WINT_UNSIGNED__ = @as(c_int, 1);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub const __INT64_TYPE__ = c_long;
pub const __INT64_FMTd__ = "ld";
pub const __INT64_FMTi__ = "li";
pub const __INT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `L`");
// (no file):202:9
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `U`");
// (no file):224:9
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulong;
pub const __UINT64_FMTo__ = "lo";
pub const __UINT64_FMTu__ = "lu";
pub const __UINT64_FMTx__ = "lx";
pub const __UINT64_FMTX__ = "lX";
pub const __UINT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`");
// (no file):232:9
pub const __UINT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __INT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_long;
pub const __INT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "ld";
pub const __INT_LEAST64_FMTi__ = "li";
pub const __UINT_LEAST64_TYPE__ = c_ulong;
pub const __UINT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_LEAST64_FMTo__ = "lo";
pub const __UINT_LEAST64_FMTu__ = "lu";
pub const __UINT_LEAST64_FMTx__ = "lx";
pub const __UINT_LEAST64_FMTX__ = "lX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_long;
pub const __INT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "ld";
pub const __INT_FAST64_FMTi__ = "li";
pub const __UINT_FAST64_TYPE__ = c_ulong;
pub const __UINT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_FAST64_FMTo__ = "lo";
pub const __UINT_FAST64_FMTu__ = "lu";
pub const __UINT_FAST64_FMTx__ = "lx";
pub const __UINT_FAST64_FMTX__ = "lX";
pub const __USER_LABEL_PREFIX__ = "";
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __GCC_DESTRUCTIVE_SIZE = @as(c_int, 64);
pub const __GCC_CONSTRUCTIVE_SIZE = @as(c_int, 64);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __SSP_STRONG__ = @as(c_int, 2);
pub const __ELF__ = @as(c_int, 1);
pub const __GCC_ASM_FLAG_OUTPUTS__ = @as(c_int, 1);
pub const __code_model_small__ = @as(c_int, 1);
pub const __amd64__ = @as(c_int, 1);
pub const __amd64 = @as(c_int, 1);
pub const __x86_64 = @as(c_int, 1);
pub const __x86_64__ = @as(c_int, 1);
pub const __SEG_GS = @as(c_int, 1);
pub const __SEG_FS = @as(c_int, 1);
pub const __seg_gs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):366:9
pub const __seg_fs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):367:9
pub const __corei7 = @as(c_int, 1);
pub const __corei7__ = @as(c_int, 1);
pub const __tune_corei7__ = @as(c_int, 1);
pub const __REGISTER_PREFIX__ = "";
pub const __NO_MATH_INLINES = @as(c_int, 1);
pub const __AES__ = @as(c_int, 1);
pub const __PCLMUL__ = @as(c_int, 1);
pub const __LAHF_SAHF__ = @as(c_int, 1);
pub const __LZCNT__ = @as(c_int, 1);
pub const __RDRND__ = @as(c_int, 1);
pub const __FSGSBASE__ = @as(c_int, 1);
pub const __BMI__ = @as(c_int, 1);
pub const __BMI2__ = @as(c_int, 1);
pub const __POPCNT__ = @as(c_int, 1);
pub const __PRFCHW__ = @as(c_int, 1);
pub const __RDSEED__ = @as(c_int, 1);
pub const __ADX__ = @as(c_int, 1);
pub const __MOVBE__ = @as(c_int, 1);
pub const __FMA__ = @as(c_int, 1);
pub const __F16C__ = @as(c_int, 1);
pub const __FXSR__ = @as(c_int, 1);
pub const __XSAVE__ = @as(c_int, 1);
pub const __XSAVEOPT__ = @as(c_int, 1);
pub const __XSAVEC__ = @as(c_int, 1);
pub const __XSAVES__ = @as(c_int, 1);
pub const __CLFLUSHOPT__ = @as(c_int, 1);
pub const __SGX__ = @as(c_int, 1);
pub const __INVPCID__ = @as(c_int, 1);
pub const __CRC32__ = @as(c_int, 1);
pub const __AVX2__ = @as(c_int, 1);
pub const __AVX__ = @as(c_int, 1);
pub const __SSE4_2__ = @as(c_int, 1);
pub const __SSE4_1__ = @as(c_int, 1);
pub const __SSSE3__ = @as(c_int, 1);
pub const __SSE3__ = @as(c_int, 1);
pub const __SSE2__ = @as(c_int, 1);
pub const __SSE2_MATH__ = @as(c_int, 1);
pub const __SSE__ = @as(c_int, 1);
pub const __SSE_MATH__ = @as(c_int, 1);
pub const __MMX__ = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = @as(c_int, 1);
pub const __SIZEOF_FLOAT128__ = @as(c_int, 16);
pub const unix = @as(c_int, 1);
pub const __unix = @as(c_int, 1);
pub const __unix__ = @as(c_int, 1);
pub const linux = @as(c_int, 1);
pub const __linux = @as(c_int, 1);
pub const __linux__ = @as(c_int, 1);
pub const __gnu_linux__ = @as(c_int, 1);
pub const __FLOAT128__ = @as(c_int, 1);
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const __STDC_EMBED_NOT_FOUND__ = @as(c_int, 0);
pub const __STDC_EMBED_FOUND__ = @as(c_int, 1);
pub const __STDC_EMBED_EMPTY__ = @as(c_int, 2);
pub const __GLIBC_MINOR__ = @as(c_int, 39);
pub const _DEBUG = @as(c_int, 1);
pub const __GCC_HAVE_DWARF2_CFI_ASM = @as(c_int, 1);
pub const NK_IMPLEMENTATION = "";
pub const NK_SINGLE_FILE = "";
pub const NK_NUKLEAR_H_ = "";
pub const NK_UNDEFINED = -@as(f32, 1.0);
pub const NK_UTF_INVALID = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFD, .hex);
pub const NK_UTF_SIZE = @as(c_int, 4);
pub const NK_INPUT_MAX = @as(c_int, 16);
pub const NK_MAX_NUMBER_BUFFER = @as(c_int, 64);
pub const NK_SCROLLBAR_HIDING_TIMEOUT = @as(f32, 4.0);
pub const NK_API = @compileError("unable to translate C expr: unexpected token 'extern'");
// libs/nuklear/nuklear.h:273:13
pub const NK_LIB = @compileError("unable to translate C expr: unexpected token 'static'");
// libs/nuklear/nuklear.h:278:13
pub const NK_INTERN = @compileError("unable to translate C expr: unexpected token 'static'");
// libs/nuklear/nuklear.h:284:9
pub const NK_STORAGE = @compileError("unable to translate C expr: unexpected token 'static'");
// libs/nuklear/nuklear.h:285:9
pub const NK_GLOBAL = @compileError("unable to translate C expr: unexpected token 'static'");
// libs/nuklear/nuklear.h:286:9
pub inline fn NK_FLAG(x: anytype) @TypeOf(@as(c_int, 1) << x) {
    _ = &x;
    return @as(c_int, 1) << x;
}
pub const NK_STRINGIFY = @compileError("unable to translate C expr: unexpected token '#'");
// libs/nuklear/nuklear.h:289:9
pub inline fn NK_MACRO_STRINGIFY(x: anytype) @TypeOf(NK_STRINGIFY(x)) {
    _ = &x;
    return NK_STRINGIFY(x);
}
pub const NK_STRING_JOIN_IMMEDIATE = @compileError("unable to translate C expr: unexpected token '##'");
// libs/nuklear/nuklear.h:291:9
pub inline fn NK_STRING_JOIN_DELAY(arg1: anytype, arg2: anytype) @TypeOf(NK_STRING_JOIN_IMMEDIATE(arg1, arg2)) {
    _ = &arg1;
    _ = &arg2;
    return NK_STRING_JOIN_IMMEDIATE(arg1, arg2);
}
pub inline fn NK_STRING_JOIN(arg1: anytype, arg2: anytype) @TypeOf(NK_STRING_JOIN_DELAY(arg1, arg2)) {
    _ = &arg1;
    _ = &arg2;
    return NK_STRING_JOIN_DELAY(arg1, arg2);
}
pub const NK_UNIQUE_NAME = @compileError("unable to translate macro: undefined identifier `__LINE__`");
// libs/nuklear/nuklear.h:298:11
pub const NK_STATIC_ASSERT = @compileError("unable to translate macro: undefined identifier `_dummy_array`");
// libs/nuklear/nuklear.h:302:11
pub const NK_FILE_LINE = @compileError("unable to translate macro: undefined identifier `__FILE__`");
// libs/nuklear/nuklear.h:309:11
pub inline fn NK_MIN(a: anytype, b: anytype) @TypeOf(if (a < b) a else b) {
    _ = &a;
    _ = &b;
    return if (a < b) a else b;
}
pub inline fn NK_MAX(a: anytype, b: anytype) @TypeOf(if (a < b) b else a) {
    _ = &a;
    _ = &b;
    return if (a < b) b else a;
}
pub inline fn NK_CLAMP(i: anytype, v: anytype, x: anytype) @TypeOf(NK_MAX(NK_MIN(v, x), i)) {
    _ = &i;
    _ = &v;
    _ = &x;
    return NK_MAX(NK_MIN(v, x), i);
}
pub const NK_INT8 = i8;
pub const NK_UINT8 = u8;
pub const NK_INT16 = c_short;
pub const NK_UINT16 = c_ushort;
pub const NK_INT32 = c_int;
pub const NK_UINT32 = c_uint;
pub const NK_SIZE_TYPE = c_ulong;
pub const NK_POINTER_TYPE = c_ulong;
pub const NK_BOOL = c_int;
pub const nk_foreach = @compileError("unable to translate C expr: unexpected token 'for'");
// libs/nuklear/nuklear.h:1254:9
pub const nk_tree_push = @compileError("unable to translate macro: undefined identifier `__LINE__`");
// libs/nuklear/nuklear.h:3102:9
pub inline fn nk_tree_push_id(ctx: anytype, @"type": anytype, title: anytype, state: anytype, id: anytype) @TypeOf(nk_tree_push_hashed(ctx, @"type", title, state, NK_FILE_LINE, nk_strlen(NK_FILE_LINE), id)) {
    _ = &ctx;
    _ = &@"type";
    _ = &title;
    _ = &state;
    _ = &id;
    return nk_tree_push_hashed(ctx, @"type", title, state, NK_FILE_LINE, nk_strlen(NK_FILE_LINE), id);
}
pub const nk_tree_image_push = @compileError("unable to translate macro: undefined identifier `__LINE__`");
// libs/nuklear/nuklear.h:3167:9
pub inline fn nk_tree_image_push_id(ctx: anytype, @"type": anytype, img: anytype, title: anytype, state: anytype, id: anytype) @TypeOf(nk_tree_image_push_hashed(ctx, @"type", img, title, state, NK_FILE_LINE, nk_strlen(NK_FILE_LINE), id)) {
    _ = &ctx;
    _ = &@"type";
    _ = &img;
    _ = &title;
    _ = &state;
    _ = &id;
    return nk_tree_image_push_hashed(ctx, @"type", img, title, state, NK_FILE_LINE, nk_strlen(NK_FILE_LINE), id);
}
pub const nk_tree_element_push = @compileError("unable to translate macro: undefined identifier `__LINE__`");
// libs/nuklear/nuklear.h:3277:9
pub inline fn nk_tree_element_push_id(ctx: anytype, @"type": anytype, title: anytype, state: anytype, sel: anytype, id: anytype) @TypeOf(nk_tree_element_push_hashed(ctx, @"type", title, state, sel, NK_FILE_LINE, nk_strlen(NK_FILE_LINE), id)) {
    _ = &ctx;
    _ = &@"type";
    _ = &title;
    _ = &state;
    _ = &sel;
    _ = &id;
    return nk_tree_element_push_hashed(ctx, @"type", title, state, sel, NK_FILE_LINE, nk_strlen(NK_FILE_LINE), id);
}
pub const NK_WIDGET_DISABLED_FACTOR = @as(f32, 0.5);
pub const NK_STRTOD = nk_strtod;
pub const NK_TEXTEDIT_UNDOSTATECOUNT = @as(c_int, 99);
pub const NK_TEXTEDIT_UNDOCHARCOUNT = @as(c_int, 999);
pub const NK_MAX_LAYOUT_ROW_TEMPLATE_COLUMNS = @as(c_int, 16);
pub const NK_CHART_MAX_SLOT = @as(c_int, 4);
pub const NK_WINDOW_MAX_NAME = @as(c_int, 64);
pub const NK_BUTTON_BEHAVIOR_STACK_SIZE = @as(c_int, 8);
pub const NK_FONT_STACK_SIZE = @as(c_int, 8);
pub const NK_STYLE_ITEM_STACK_SIZE = @as(c_int, 16);
pub const NK_FLOAT_STACK_SIZE = @as(c_int, 32);
pub const NK_VECTOR_STACK_SIZE = @as(c_int, 16);
pub const NK_FLAGS_STACK_SIZE = @as(c_int, 32);
pub const NK_COLOR_STACK_SIZE = @as(c_int, 32);
pub const NK_CONFIGURATION_STACK_TYPE = @compileError("unable to translate macro: undefined identifier `nk_config_stack_`");
// libs/nuklear/nuklear.h:5846:9
pub const NK_CONFIG_STACK = @compileError("unable to translate macro: undefined identifier `nk_config_stack_`");
// libs/nuklear/nuklear.h:5851:9
pub const nk_float = f32;
pub const NK_VALUE_PAGE_CAPACITY = @import("std").zig.c_translation.MacroArithmetic.div(@import("std").zig.c_translation.MacroArithmetic.div(NK_MAX(@import("std").zig.c_translation.sizeof(struct_nk_window), @import("std").zig.c_translation.sizeof(struct_nk_panel)), @import("std").zig.c_translation.sizeof(nk_uint)), @as(c_int, 2));
pub const NK_PI = @as(f32, 3.141592654);
pub const NK_PI_HALF = @as(f32, 1.570796326);
pub const NK_MAX_FLOAT_PRECISION = @as(c_int, 2);
pub const NK_UNUSED = @import("std").zig.c_translation.Macros.DISCARD;
pub inline fn NK_SATURATE(x: anytype) @TypeOf(NK_MAX(@as(c_int, 0), NK_MIN(@as(f32, 1.0), x))) {
    _ = &x;
    return NK_MAX(@as(c_int, 0), NK_MIN(@as(f32, 1.0), x));
}
pub const NK_LEN = @compileError("unable to translate C expr: expected ')' instead got '['");
// libs/nuklear/nuklear.h:5978:9
pub inline fn NK_ABS(a: anytype) @TypeOf(if (a < @as(c_int, 0)) -a else a) {
    _ = &a;
    return if (a < @as(c_int, 0)) -a else a;
}
pub inline fn NK_BETWEEN(x: anytype, a: anytype, b: anytype) @TypeOf((a <= x) and (x < b)) {
    _ = &x;
    _ = &a;
    _ = &b;
    return (a <= x) and (x < b);
}
pub inline fn NK_INBOX(px: anytype, py: anytype, x: anytype, y: anytype, w: anytype, h: anytype) @TypeOf((NK_BETWEEN(px, x, x + w) != 0) and (NK_BETWEEN(py, y, y + h) != 0)) {
    _ = &px;
    _ = &py;
    _ = &x;
    _ = &y;
    _ = &w;
    _ = &h;
    return (NK_BETWEEN(px, x, x + w) != 0) and (NK_BETWEEN(py, y, y + h) != 0);
}
pub inline fn NK_INTERSECT(x0: anytype, y0: anytype, w0: anytype, h0: anytype, x1: anytype, y1: anytype, w1: anytype, h1: anytype) @TypeOf((((x1 < (x0 + w0)) and (x0 < (x1 + w1))) and (y1 < (y0 + h0))) and (y0 < (y1 + h1))) {
    _ = &x0;
    _ = &y0;
    _ = &w0;
    _ = &h0;
    _ = &x1;
    _ = &y1;
    _ = &w1;
    _ = &h1;
    return (((x1 < (x0 + w0)) and (x0 < (x1 + w1))) and (y1 < (y0 + h0))) and (y0 < (y1 + h1));
}
pub inline fn NK_CONTAINS(x: anytype, y: anytype, w: anytype, h: anytype, bx: anytype, by: anytype, bw: anytype, bh: anytype) @TypeOf((NK_INBOX(x, y, bx, by, bw, bh) != 0) and (NK_INBOX(x + w, y + h, bx, by, bw, bh) != 0)) {
    _ = &x;
    _ = &y;
    _ = &w;
    _ = &h;
    _ = &bx;
    _ = &by;
    _ = &bw;
    _ = &bh;
    return (NK_INBOX(x, y, bx, by, bw, bh) != 0) and (NK_INBOX(x + w, y + h, bx, by, bw, bh) != 0);
}
pub inline fn nk_vec2_sub(a: anytype, b: anytype) @TypeOf(nk_vec2(a.x - b.x, a.y - b.y)) {
    _ = &a;
    _ = &b;
    return nk_vec2(a.x - b.x, a.y - b.y);
}
pub inline fn nk_vec2_add(a: anytype, b: anytype) @TypeOf(nk_vec2(a.x + b.x, a.y + b.y)) {
    _ = &a;
    _ = &b;
    return nk_vec2(a.x + b.x, a.y + b.y);
}
pub inline fn nk_vec2_len_sqr(a: anytype) @TypeOf((a.x * a.x) + (a.y * a.y)) {
    _ = &a;
    return (a.x * a.x) + (a.y * a.y);
}
pub inline fn nk_vec2_muls(a: anytype, t: anytype) @TypeOf(nk_vec2(a.x * t, a.y * t)) {
    _ = &a;
    _ = &t;
    return nk_vec2(a.x * t, a.y * t);
}
pub const nk_ptr_add = @compileError("unable to translate C expr: unexpected token ')'");
// libs/nuklear/nuklear.h:5994:9
pub const nk_ptr_add_const = @compileError("unable to translate C expr: unexpected token 'const'");
// libs/nuklear/nuklear.h:5995:9
pub inline fn nk_zero_struct(s: anytype) @TypeOf(nk_zero(&s, @import("std").zig.c_translation.sizeof(s))) {
    _ = &s;
    return nk_zero(&s, @import("std").zig.c_translation.sizeof(s));
}
pub inline fn NK_UINT_TO_PTR(x: anytype) ?*anyopaque {
    _ = &x;
    return @import("std").zig.c_translation.cast(?*anyopaque, __PTRDIFF_TYPE__(x));
}
pub inline fn NK_PTR_TO_UINT(x: anytype) nk_size {
    _ = &x;
    return @import("std").zig.c_translation.cast(nk_size, __PTRDIFF_TYPE__(x));
}
pub inline fn NK_ALIGN_PTR(x: anytype, mask: anytype) @TypeOf(NK_UINT_TO_PTR(NK_PTR_TO_UINT(@import("std").zig.c_translation.cast([*c]nk_byte, x) + (mask - @as(c_int, 1))) & ~(mask - @as(c_int, 1)))) {
    _ = &x;
    _ = &mask;
    return NK_UINT_TO_PTR(NK_PTR_TO_UINT(@import("std").zig.c_translation.cast([*c]nk_byte, x) + (mask - @as(c_int, 1))) & ~(mask - @as(c_int, 1)));
}
pub inline fn NK_ALIGN_PTR_BACK(x: anytype, mask: anytype) @TypeOf(NK_UINT_TO_PTR(NK_PTR_TO_UINT(@import("std").zig.c_translation.cast([*c]nk_byte, x)) & ~(mask - @as(c_int, 1)))) {
    _ = &x;
    _ = &mask;
    return NK_UINT_TO_PTR(NK_PTR_TO_UINT(@import("std").zig.c_translation.cast([*c]nk_byte, x)) & ~(mask - @as(c_int, 1)));
}
pub const NK_OFFSETOF = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// libs/nuklear/nuklear.h:6022:9
pub const NK_ALIGNOF = @compileError("unable to translate macro: undefined identifier `c`");
// libs/nuklear/nuklear.h:6039:9
pub const NK_CONTAINER_OF = @compileError("unable to translate C expr: unexpected token ')'");
// libs/nuklear/nuklear.h:6042:9
pub const NK_INTERNAL_H = "";
pub const NK_POOL_DEFAULT_CAPACITY = @as(c_int, 16);
pub const NK_DEFAULT_COMMAND_BUFFER_SIZE = @as(c_int, 4) * @as(c_int, 1024);
pub const NK_BUFFER_DEFAULT_INITIAL_SIZE = @as(c_int, 4) * @as(c_int, 1024);
pub const _ASSERT_H = @as(c_int, 1);
pub const _FEATURES_H = @as(c_int, 1);
pub const __KERNEL_STRICT_NAMES = "";
pub inline fn __GNUC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub inline fn __glibc_clang_prereq(maj: anytype, min: anytype) @TypeOf(((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min);
}
pub const __GLIBC_USE = @compileError("unable to translate macro: undefined identifier `__GLIBC_USE_`");
// /usr/include/features.h:189:9
pub const _DEFAULT_SOURCE = @as(c_int, 1);
pub const __GLIBC_USE_ISOC23 = @as(c_int, 0);
pub const __USE_ISOC11 = @as(c_int, 1);
pub const __USE_ISOC99 = @as(c_int, 1);
pub const __USE_ISOC95 = @as(c_int, 1);
pub const __USE_POSIX_IMPLICITLY = @as(c_int, 1);
pub const _POSIX_SOURCE = @as(c_int, 1);
pub const _POSIX_C_SOURCE = @as(c_long, 200809);
pub const __USE_POSIX = @as(c_int, 1);
pub const __USE_POSIX2 = @as(c_int, 1);
pub const __USE_POSIX199309 = @as(c_int, 1);
pub const __USE_POSIX199506 = @as(c_int, 1);
pub const __USE_XOPEN2K = @as(c_int, 1);
pub const __USE_XOPEN2K8 = @as(c_int, 1);
pub const _ATFILE_SOURCE = @as(c_int, 1);
pub const __WORDSIZE = @as(c_int, 64);
pub const __WORDSIZE_TIME64_COMPAT32 = @as(c_int, 1);
pub const __SYSCALL_WORDSIZE = @as(c_int, 64);
pub const __TIMESIZE = __WORDSIZE;
pub const __USE_TIME_BITS64 = @as(c_int, 1);
pub const __USE_MISC = @as(c_int, 1);
pub const __USE_ATFILE = @as(c_int, 1);
pub const __USE_FORTIFY_LEVEL = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_GETS = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_SCANF = @as(c_int, 0);
pub const __GLIBC_USE_C23_STRTOL = @as(c_int, 0);
pub const _STDC_PREDEF_H = @as(c_int, 1);
pub const __STDC_IEC_559__ = @as(c_int, 1);
pub const __STDC_IEC_60559_BFP__ = @as(c_long, 201404);
pub const __STDC_IEC_559_COMPLEX__ = @as(c_int, 1);
pub const __STDC_IEC_60559_COMPLEX__ = @as(c_long, 201404);
pub const __STDC_ISO_10646__ = @as(c_long, 201706);
pub const __GNU_LIBRARY__ = @as(c_int, 6);
pub const __GLIBC__ = @as(c_int, 2);
pub inline fn __GLIBC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub const _SYS_CDEFS_H = @as(c_int, 1);
pub const __glibc_has_attribute = @compileError("unable to translate macro: undefined identifier `__has_attribute`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:45:10
pub inline fn __glibc_has_builtin(name: anytype) @TypeOf(__has_builtin(name)) {
    _ = &name;
    return __has_builtin(name);
}
pub const __glibc_has_extension = @compileError("unable to translate macro: undefined identifier `__has_extension`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:55:10
pub const __LEAF = "";
pub const __LEAF_ATTR = "";
pub const __THROW = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:79:11
pub const __THROWNL = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:80:11
pub const __NTH = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:81:11
pub const __NTHNL = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:82:11
pub const __COLD = @compileError("unable to translate macro: undefined identifier `__cold__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:102:11
pub inline fn __P(args: anytype) @TypeOf(args) {
    _ = &args;
    return args;
}
pub inline fn __PMT(args: anytype) @TypeOf(args) {
    _ = &args;
    return args;
}
pub const __CONCAT = @compileError("unable to translate C expr: unexpected token '##'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:131:9
pub const __STRING = @compileError("unable to translate C expr: unexpected token '#'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:132:9
pub const __ptr_t = ?*anyopaque;
pub const __BEGIN_DECLS = "";
pub const __END_DECLS = "";
pub const __attribute_overloadable__ = @compileError("unable to translate macro: undefined identifier `__overloadable__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:151:10
pub inline fn __bos(ptr: anytype) @TypeOf(__builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1))) {
    _ = &ptr;
    return __builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1));
}
pub inline fn __bos0(ptr: anytype) @TypeOf(__builtin_object_size(ptr, @as(c_int, 0))) {
    _ = &ptr;
    return __builtin_object_size(ptr, @as(c_int, 0));
}
pub inline fn __glibc_objsize0(__o: anytype) @TypeOf(__bos0(__o)) {
    _ = &__o;
    return __bos0(__o);
}
pub inline fn __glibc_objsize(__o: anytype) @TypeOf(__bos(__o)) {
    _ = &__o;
    return __bos(__o);
}
pub const __warnattr = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:370:10
pub const __errordecl = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:371:10
pub const __flexarr = @compileError("unable to translate C expr: unexpected token '['");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:379:10
pub const __glibc_c99_flexarr_available = @as(c_int, 1);
pub const __REDIRECT = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:410:10
pub const __REDIRECT_NTH = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:417:11
pub const __REDIRECT_NTHNL = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:419:11
pub const __ASMNAME = @compileError("unable to translate C expr: unexpected token ','");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:422:10
pub inline fn __ASMNAME2(prefix: anytype, cname: anytype) @TypeOf(__STRING(prefix) ++ cname) {
    _ = &prefix;
    _ = &cname;
    return __STRING(prefix) ++ cname;
}
pub const __REDIRECT_FORTIFY = __REDIRECT;
pub const __REDIRECT_FORTIFY_NTH = __REDIRECT_NTH;
pub const __attribute_malloc__ = @compileError("unable to translate macro: undefined identifier `__malloc__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:452:10
pub const __attribute_alloc_size__ = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:463:10
pub const __attribute_alloc_align__ = @compileError("unable to translate macro: undefined identifier `__alloc_align__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:469:10
pub const __attribute_pure__ = @compileError("unable to translate macro: undefined identifier `__pure__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:479:10
pub const __attribute_const__ = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:486:10
pub const __attribute_maybe_unused__ = @compileError("unable to translate macro: undefined identifier `__unused__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:492:10
pub const __attribute_used__ = @compileError("unable to translate macro: undefined identifier `__used__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:501:10
pub const __attribute_noinline__ = @compileError("unable to translate macro: undefined identifier `__noinline__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:502:10
pub const __attribute_deprecated__ = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:510:10
pub const __attribute_deprecated_msg__ = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:520:10
pub const __attribute_format_arg__ = @compileError("unable to translate macro: undefined identifier `__format_arg__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:533:10
pub const __attribute_format_strfmon__ = @compileError("unable to translate macro: undefined identifier `__format__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:543:10
pub const __attribute_nonnull__ = @compileError("unable to translate macro: undefined identifier `__nonnull__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:555:11
pub inline fn __nonnull(params: anytype) @TypeOf(__attribute_nonnull__(params)) {
    _ = &params;
    return __attribute_nonnull__(params);
}
pub const __returns_nonnull = @compileError("unable to translate macro: undefined identifier `__returns_nonnull__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:568:10
pub const __attribute_warn_unused_result__ = @compileError("unable to translate macro: undefined identifier `__warn_unused_result__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:577:10
pub const __wur = "";
pub const __always_inline = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:595:10
pub const __attribute_artificial__ = @compileError("unable to translate macro: undefined identifier `__artificial__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:604:10
pub const __extern_inline = @compileError("unable to translate macro: undefined identifier `__gnu_inline__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:622:11
pub const __extern_always_inline = @compileError("unable to translate macro: undefined identifier `__gnu_inline__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:623:11
pub const __fortify_function = __extern_always_inline ++ __attribute_artificial__;
pub const __restrict_arr = @compileError("unable to translate C expr: unexpected token '__restrict'");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:666:10
pub inline fn __glibc_unlikely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 0))) {
    _ = &cond;
    return __builtin_expect(cond, @as(c_int, 0));
}
pub inline fn __glibc_likely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 1))) {
    _ = &cond;
    return __builtin_expect(cond, @as(c_int, 1));
}
pub const __attribute_nonstring__ = "";
pub const __attribute_copy__ = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:715:10
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = @as(c_int, 0);
pub inline fn __LDBL_REDIR1(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return name ++ proto;
}
pub inline fn __LDBL_REDIR(name: anytype, proto: anytype) @TypeOf(name ++ proto) {
    _ = &name;
    _ = &proto;
    return name ++ proto;
}
pub inline fn __LDBL_REDIR1_NTH(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto ++ __THROW) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return name ++ proto ++ __THROW;
}
pub inline fn __LDBL_REDIR_NTH(name: anytype, proto: anytype) @TypeOf(name ++ proto ++ __THROW) {
    _ = &name;
    _ = &proto;
    return name ++ proto ++ __THROW;
}
pub const __LDBL_REDIR2_DECL = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:792:10
pub const __LDBL_REDIR_DECL = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:793:10
pub inline fn __REDIRECT_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT(name, proto, alias)) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return __REDIRECT(name, proto, alias);
}
pub inline fn __REDIRECT_NTH_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT_NTH(name, proto, alias)) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return __REDIRECT_NTH(name, proto, alias);
}
pub const __glibc_macro_warning1 = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:807:10
pub const __glibc_macro_warning = @compileError("unable to translate macro: undefined identifier `GCC`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:808:10
pub const __HAVE_GENERIC_SELECTION = @as(c_int, 1);
pub const __fortified_attr_access = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:853:11
pub const __attr_access = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:854:11
pub const __attr_access_none = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:855:11
pub const __attr_dealloc = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:865:10
pub const __attr_dealloc_free = "";
pub const __attribute_returns_twice__ = @compileError("unable to translate macro: undefined identifier `__returns_twice__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:872:10
pub const __attribute_struct_may_alias__ = @compileError("unable to translate macro: undefined identifier `__may_alias__`");
// /usr/include/x86_64-linux-gnu/sys/cdefs.h:881:10
pub const __stub___compat_bdflush = "";
pub const __stub_chflags = "";
pub const __stub_fchflags = "";
pub const __stub_gtty = "";
pub const __stub_revoke = "";
pub const __stub_setlogin = "";
pub const __stub_sigreturn = "";
pub const __stub_stty = "";
pub const __ASSERT_VOID_CAST = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/assert.h:40:10
pub const _ASSERT_H_DECLS = "";
pub const assert = @compileError("unable to translate macro: undefined identifier `__FILE__`");
// /usr/include/assert.h:118:11
pub const __ASSERT_FUNCTION = @compileError("unable to translate C expr: unexpected token '__extension__'");
// /usr/include/assert.h:140:12
pub const static_assert = @compileError("unable to translate C expr: unexpected token '_Static_assert'");
// /usr/include/assert.h:158:10
pub inline fn NK_ASSERT(expr: anytype) @TypeOf(assert(expr)) {
    _ = &expr;
    return assert(expr);
}
pub const NK_DEFAULT = -@as(c_int, 1);
pub const NK_VSNPRINTF = @compileError("unable to translate macro: undefined identifier `vsnprintf`");
// libs/nuklear/nuklear.h:6093:15
pub const NK_SCHAR_MIN = -@as(c_int, 127);
pub const NK_SCHAR_MAX = @as(c_int, 127);
pub const NK_UCHAR_MIN = @as(c_int, 0);
pub const NK_UCHAR_MAX = @as(c_int, 256);
pub const NK_SSHORT_MIN = -@as(c_int, 32767);
pub const NK_SSHORT_MAX = @as(c_int, 32767);
pub const NK_USHORT_MIN = @as(c_int, 0);
pub const NK_USHORT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const NK_SINT_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const NK_SINT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const NK_UINT_MIN = @as(c_int, 0);
pub const NK_UINT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const NK_FLOAT_PRECISION = @as(f64, 0.00000000000001);
pub const nk_widget_state_reset = @compileError("unable to translate C expr: unexpected token 'if'");
// libs/nuklear/nuklear.h:6141:9
pub const NK_INV_SQRT = nk_inv_sqrt;
pub const NK_SIN = nk_sin;
pub const NK_COS = nk_cos;
pub const NK_ATAN = nk_atan;
pub const NK_ATAN2 = nk_atan2;
pub const NK_MEMCPY = nk_memcopy;
pub const nk_word = c_int;
pub const nk_wsize = @import("std").zig.c_translation.sizeof(nk_word);
pub const nk_wmask = nk_wsize - @as(c_int, 1);
pub const NK_TLOOP = @compileError("unable to translate macro: undefined identifier `t`");
// libs/nuklear/nuklear.h:6813:13
pub const NK_TLOOP1 = @compileError("unable to translate macro: undefined identifier `t`");
// libs/nuklear/nuklear.h:6814:13
pub const NK_MEMSET = nk_memset;
pub const NK_ADJACENCY_BONUS = @as(c_int, 5);
pub const NK_SEPARATOR_BONUS = @as(c_int, 10);
pub const NK_CAMEL_BONUS = @as(c_int, 10);
pub const NK_LEADING_LETTER_PENALTY = -@as(c_int, 3);
pub const NK_MAX_LEADING_LETTER_PENALTY = -@as(c_int, 9);
pub const NK_UNMATCHED_LETTER_PENALTY = -@as(c_int, 1);
pub const NK_DTOA = nk_dtoa;
pub inline fn NK_ROTL(x: anytype, r: anytype) @TypeOf((x << r) | (x >> (@as(c_int, 32) - r))) {
    _ = &x;
    _ = &r;
    return (x << r) | (x >> (@as(c_int, 32) - r));
}
pub inline fn NK_TO_HEX(i: anytype) @TypeOf(if (i <= @as(c_int, 9)) '0' + i else ('A' - @as(c_int, 10)) + i) {
    _ = &i;
    return if (i <= @as(c_int, 9)) '0' + i else ('A' - @as(c_int, 10)) + i;
}
pub const IMG_RGN = @compileError("unable to translate macro: undefined identifier `img`");
// libs/nuklear/nuklear.h:9649:9
pub const STB_INCLUDE_STB_RECT_PACK_H = "";
pub const STB_RECT_PACK_VERSION = @as(c_int, 1);
pub const STBRP_DEF = @compileError("unable to translate C expr: unexpected token 'extern'");
// libs/nuklear/nuklear.h:11180:9
pub const STBRP__MAXVAL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffff, .hex);
pub const __STB_INCLUDE_STB_TRUETYPE_H__ = "";
pub const STBTT_DEF = @compileError("unable to translate C expr: unexpected token 'extern'");
// libs/nuklear/nuklear.h:12235:9
pub inline fn STBTT_POINT_SIZE(x: anytype) @TypeOf(-x) {
    _ = &x;
    return -x;
}
pub const stbtt_vertex_type = c_short;
pub const STBTT_MACSTYLE_DONTCARE = @as(c_int, 0);
pub const STBTT_MACSTYLE_BOLD = @as(c_int, 1);
pub const STBTT_MACSTYLE_ITALIC = @as(c_int, 2);
pub const STBTT_MACSTYLE_UNDERSCORE = @as(c_int, 4);
pub const STBTT_MACSTYLE_NONE = @as(c_int, 8);
pub inline fn NK_COLOR_MAP(NK_COLOR_1: anytype) @TypeOf(NK_COLOR_1(NK_COLOR_TEXT, @as(c_int, 175), @as(c_int, 175), @as(c_int, 175), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_WINDOW, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_HEADER, @as(c_int, 40), @as(c_int, 40), @as(c_int, 40), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_BORDER, @as(c_int, 65), @as(c_int, 65), @as(c_int, 65), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_BUTTON, @as(c_int, 50), @as(c_int, 50), @as(c_int, 50), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_BUTTON_HOVER, @as(c_int, 40), @as(c_int, 40), @as(c_int, 40), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_BUTTON_ACTIVE, @as(c_int, 35), @as(c_int, 35), @as(c_int, 35), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_TOGGLE, @as(c_int, 100), @as(c_int, 100), @as(c_int, 100), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_TOGGLE_HOVER, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_TOGGLE_CURSOR, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SELECT, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SELECT_ACTIVE, @as(c_int, 35), @as(c_int, 35), @as(c_int, 35), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SLIDER, @as(c_int, 38), @as(c_int, 38), @as(c_int, 38), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SLIDER_CURSOR, @as(c_int, 100), @as(c_int, 100), @as(c_int, 100), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SLIDER_CURSOR_HOVER, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SLIDER_CURSOR_ACTIVE, @as(c_int, 150), @as(c_int, 150), @as(c_int, 150), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_PROPERTY, @as(c_int, 38), @as(c_int, 38), @as(c_int, 38), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_EDIT, @as(c_int, 38), @as(c_int, 38), @as(c_int, 38), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_EDIT_CURSOR, @as(c_int, 175), @as(c_int, 175), @as(c_int, 175), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_COMBO, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_CHART, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_CHART_COLOR, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_CHART_COLOR_HIGHLIGHT, @as(c_int, 255), @as(c_int, 0), @as(c_int, 0), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SCROLLBAR, @as(c_int, 40), @as(c_int, 40), @as(c_int, 40), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SCROLLBAR_CURSOR, @as(c_int, 100), @as(c_int, 100), @as(c_int, 100), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SCROLLBAR_CURSOR_HOVER, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SCROLLBAR_CURSOR_ACTIVE, @as(c_int, 150), @as(c_int, 150), @as(c_int, 150), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_TAB_HEADER, @as(c_int, 40), @as(c_int, 40), @as(c_int, 40), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_KNOB, @as(c_int, 38), @as(c_int, 38), @as(c_int, 38), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_KNOB_CURSOR, @as(c_int, 100), @as(c_int, 100), @as(c_int, 100), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_KNOB_CURSOR_HOVER, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_KNOB_CURSOR_ACTIVE, @as(c_int, 150), @as(c_int, 150), @as(c_int, 150), @as(c_int, 255))) {
    _ = &NK_COLOR_1;
    return NK_COLOR_1(NK_COLOR_TEXT, @as(c_int, 175), @as(c_int, 175), @as(c_int, 175), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_WINDOW, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_HEADER, @as(c_int, 40), @as(c_int, 40), @as(c_int, 40), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_BORDER, @as(c_int, 65), @as(c_int, 65), @as(c_int, 65), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_BUTTON, @as(c_int, 50), @as(c_int, 50), @as(c_int, 50), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_BUTTON_HOVER, @as(c_int, 40), @as(c_int, 40), @as(c_int, 40), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_BUTTON_ACTIVE, @as(c_int, 35), @as(c_int, 35), @as(c_int, 35), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_TOGGLE, @as(c_int, 100), @as(c_int, 100), @as(c_int, 100), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_TOGGLE_HOVER, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_TOGGLE_CURSOR, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SELECT, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SELECT_ACTIVE, @as(c_int, 35), @as(c_int, 35), @as(c_int, 35), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SLIDER, @as(c_int, 38), @as(c_int, 38), @as(c_int, 38), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SLIDER_CURSOR, @as(c_int, 100), @as(c_int, 100), @as(c_int, 100), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SLIDER_CURSOR_HOVER, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SLIDER_CURSOR_ACTIVE, @as(c_int, 150), @as(c_int, 150), @as(c_int, 150), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_PROPERTY, @as(c_int, 38), @as(c_int, 38), @as(c_int, 38), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_EDIT, @as(c_int, 38), @as(c_int, 38), @as(c_int, 38), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_EDIT_CURSOR, @as(c_int, 175), @as(c_int, 175), @as(c_int, 175), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_COMBO, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_CHART, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_CHART_COLOR, @as(c_int, 45), @as(c_int, 45), @as(c_int, 45), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_CHART_COLOR_HIGHLIGHT, @as(c_int, 255), @as(c_int, 0), @as(c_int, 0), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SCROLLBAR, @as(c_int, 40), @as(c_int, 40), @as(c_int, 40), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SCROLLBAR_CURSOR, @as(c_int, 100), @as(c_int, 100), @as(c_int, 100), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SCROLLBAR_CURSOR_HOVER, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_SCROLLBAR_CURSOR_ACTIVE, @as(c_int, 150), @as(c_int, 150), @as(c_int, 150), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_TAB_HEADER, @as(c_int, 40), @as(c_int, 40), @as(c_int, 40), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_KNOB, @as(c_int, 38), @as(c_int, 38), @as(c_int, 38), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_KNOB_CURSOR, @as(c_int, 100), @as(c_int, 100), @as(c_int, 100), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_KNOB_CURSOR_HOVER, @as(c_int, 120), @as(c_int, 120), @as(c_int, 120), @as(c_int, 255)) ++ NK_COLOR_1(NK_COLOR_KNOB_CURSOR_ACTIVE, @as(c_int, 150), @as(c_int, 150), @as(c_int, 150), @as(c_int, 255));
}
pub const NK_COLOR = @compileError("unable to translate C expr: unexpected token '{'");
// libs/nuklear/nuklear.h:18512:9
pub const NK_STYLE_PUSH_IMPLEMENATION = @compileError("unable to translate macro: undefined identifier `nk_style_push_`");
// libs/nuklear/nuklear.h:19241:9
pub const NK_STYLE_POP_IMPLEMENATION = @compileError("unable to translate macro: undefined identifier `nk_style_pop_`");
// libs/nuklear/nuklear.h:19258:9
pub inline fn NK_FRAC(x: anytype) @TypeOf(x - @import("std").zig.c_translation.cast(f32, @import("std").zig.c_translation.cast(c_int, nk_roundf(x)))) {
    _ = &x;
    return x - @import("std").zig.c_translation.cast(f32, @import("std").zig.c_translation.cast(c_int, nk_roundf(x)));
}
pub inline fn NK_TEXT_HAS_SELECTION(s: anytype) @TypeOf(s.*.select_start != s.*.select_end) {
    _ = &s;
    return s.*.select_start != s.*.select_end;
}
pub const nk_buffer_marker = struct_nk_buffer_marker;
pub const nk_allocator = struct_nk_allocator;
pub const nk_allocation_type = enum_nk_allocation_type;
pub const nk_memory = struct_nk_memory;
pub const nk_buffer = struct_nk_buffer;
pub const nk_command_buffer = struct_nk_command_buffer;
pub const nk_draw_command = struct_nk_draw_command;
pub const nk_anti_aliasing = enum_nk_anti_aliasing;
pub const nk_draw_null_texture = struct_nk_draw_null_texture;
pub const nk_draw_vertex_layout_element = struct_nk_draw_vertex_layout_element;
pub const nk_convert_config = struct_nk_convert_config;
pub const nk_style_item_type = enum_nk_style_item_type;
pub const nk_color = struct_nk_color;
pub const nk_nine_slice = struct_nk_nine_slice;
pub const nk_style_item_data = union_nk_style_item_data;
pub const nk_style_item = struct_nk_style_item;
pub const nk_clipboard = struct_nk_clipboard;
pub const nk_str = struct_nk_str;
pub const nk_text_undo_record = struct_nk_text_undo_record;
pub const nk_text_undo_state = struct_nk_text_undo_state;
pub const nk_text_edit = struct_nk_text_edit;
pub const nk_draw_list = struct_nk_draw_list;
pub const nk_user_font = struct_nk_user_font;
pub const nk_panel_type = enum_nk_panel_type;
pub const nk_scroll = struct_nk_scroll;
pub const nk_menu_state = struct_nk_menu_state;
pub const nk_panel_row_layout_type = enum_nk_panel_row_layout_type;
pub const nk_chart_type = enum_nk_chart_type;
pub const nk_chart_slot = struct_nk_chart_slot;
pub const nk_chart = struct_nk_chart;
pub const nk_panel = struct_nk_panel;
pub const nk_key = struct_nk_key;
pub const nk_keyboard = struct_nk_keyboard;
pub const nk_mouse_button = struct_nk_mouse_button;
pub const nk_mouse = struct_nk_mouse;
pub const nk_input = struct_nk_input;
pub const nk_cursor = struct_nk_cursor;
pub const nk_style_text = struct_nk_style_text;
pub const nk_style_button = struct_nk_style_button;
pub const nk_style_toggle = struct_nk_style_toggle;
pub const nk_style_selectable = struct_nk_style_selectable;
pub const nk_symbol_type = enum_nk_symbol_type;
pub const nk_style_slider = struct_nk_style_slider;
pub const nk_style_knob = struct_nk_style_knob;
pub const nk_style_progress = struct_nk_style_progress;
pub const nk_style_scrollbar = struct_nk_style_scrollbar;
pub const nk_style_edit = struct_nk_style_edit;
pub const nk_style_property = struct_nk_style_property;
pub const nk_style_chart = struct_nk_style_chart;
pub const nk_style_tab = struct_nk_style_tab;
pub const nk_style_combo = struct_nk_style_combo;
pub const nk_style_header_align = enum_nk_style_header_align;
pub const nk_style_window_header = struct_nk_style_window_header;
pub const nk_style_window = struct_nk_style_window;
pub const nk_style = struct_nk_style;
pub const nk_config_stack_style_item_element = struct_nk_config_stack_style_item_element;
pub const nk_config_stack_style_item = struct_nk_config_stack_style_item;
pub const nk_config_stack_float_element = struct_nk_config_stack_float_element;
pub const nk_config_stack_float = struct_nk_config_stack_float;
pub const nk_config_stack_vec2_element = struct_nk_config_stack_vec2_element;
pub const nk_config_stack_vec2 = struct_nk_config_stack_vec2;
pub const nk_config_stack_flags_element = struct_nk_config_stack_flags_element;
pub const nk_config_stack_flags = struct_nk_config_stack_flags;
pub const nk_config_stack_color_element = struct_nk_config_stack_color_element;
pub const nk_config_stack_color = struct_nk_config_stack_color;
pub const nk_config_stack_user_font_element = struct_nk_config_stack_user_font_element;
pub const nk_config_stack_user_font = struct_nk_config_stack_user_font;
pub const nk_config_stack_button_behavior_element = struct_nk_config_stack_button_behavior_element;
pub const nk_config_stack_button_behavior = struct_nk_config_stack_button_behavior;
pub const nk_configuration_stacks = struct_nk_configuration_stacks;
pub const nk_table = struct_nk_table;
pub const nk_property_state = struct_nk_property_state;
pub const nk_popup_buffer = struct_nk_popup_buffer;
pub const nk_popup_state = struct_nk_popup_state;
pub const nk_edit_state = struct_nk_edit_state;
pub const nk_window = struct_nk_window;
pub const nk_page_data = union_nk_page_data;
pub const nk_page_element = struct_nk_page_element;
pub const nk_page = struct_nk_page;
pub const nk_pool = struct_nk_pool;
pub const nk_context = struct_nk_context;
pub const nk_style_slide = struct_nk_style_slide;
pub const nk_colorf = struct_nk_colorf;
pub const nk_heading = enum_nk_heading;
pub const nk_modify = enum_nk_modify;
pub const nk_orientation = enum_nk_orientation;
pub const nk_collapse_states = enum_nk_collapse_states;
pub const nk_show_states = enum_nk_show_states;
pub const nk_chart_event = enum_nk_chart_event;
pub const nk_color_format = enum_nk_color_format;
pub const nk_popup_type = enum_nk_popup_type;
pub const nk_layout_format = enum_nk_layout_format;
pub const nk_tree_type = enum_nk_tree_type;
pub const nk_keys = enum_nk_keys;
pub const nk_buttons = enum_nk_buttons;
pub const nk_convert_result = enum_nk_convert_result;
pub const nk_command_type = enum_nk_command_type;
pub const nk_command = struct_nk_command;
pub const nk_panel_flags = enum_nk_panel_flags;
pub const nk_widget_layout_states = enum_nk_widget_layout_states;
pub const nk_widget_align = enum_nk_widget_align;
pub const nk_widget_alignment = enum_nk_widget_alignment;
pub const nk_list_view = struct_nk_list_view;
pub const nk_widget_states = enum_nk_widget_states;
pub const nk_text_align = enum_nk_text_align;
pub const nk_text_alignment = enum_nk_text_alignment;
pub const nk_property_kind = enum_nk_property_kind;
pub const nk_property_variant = struct_nk_property_variant;
pub const nk_edit_flags = enum_nk_edit_flags;
pub const nk_edit_types = enum_nk_edit_types;
pub const nk_edit_events = enum_nk_edit_events;
pub const nk_style_colors = enum_nk_style_colors;
pub const nk_style_cursor = enum_nk_style_cursor;
pub const nk_user_font_glyph = struct_nk_user_font_glyph;
pub const nk_memory_status = struct_nk_memory_status;
pub const nk_buffer_allocation_type = enum_nk_buffer_allocation_type;
pub const nk_text_edit_type = enum_nk_text_edit_type;
pub const nk_text_edit_mode = enum_nk_text_edit_mode;
pub const nk_command_scissor = struct_nk_command_scissor;
pub const nk_command_line = struct_nk_command_line;
pub const nk_command_curve = struct_nk_command_curve;
pub const nk_command_rect = struct_nk_command_rect;
pub const nk_command_rect_filled = struct_nk_command_rect_filled;
pub const nk_command_rect_multi_color = struct_nk_command_rect_multi_color;
pub const nk_command_triangle = struct_nk_command_triangle;
pub const nk_command_triangle_filled = struct_nk_command_triangle_filled;
pub const nk_command_circle = struct_nk_command_circle;
pub const nk_command_circle_filled = struct_nk_command_circle_filled;
pub const nk_command_arc = struct_nk_command_arc;
pub const nk_command_arc_filled = struct_nk_command_arc_filled;
pub const nk_command_polygon = struct_nk_command_polygon;
pub const nk_command_polygon_filled = struct_nk_command_polygon_filled;
pub const nk_command_polyline = struct_nk_command_polyline;
pub const nk_command_image = struct_nk_command_image;
pub const nk_command_custom = struct_nk_command_custom;
pub const nk_command_text = struct_nk_command_text;
pub const nk_command_clipping = enum_nk_command_clipping;
pub const nk_panel_set = enum_nk_panel_set;
pub const nk_window_flags = enum_nk_window_flags;
pub const nk_window_insert_location = enum_nk_window_insert_location;
pub const nk_toggle_type = enum_nk_toggle_type;
pub const nk_property_status = enum_nk_property_status;
pub const nk_property_filter = enum_nk_property_filter;
pub const nk_text_find = struct_nk_text_find;
pub const nk_text_edit_row = struct_nk_text_edit_row;
